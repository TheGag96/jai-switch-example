//
// This file was autogenerated.
//



INVALID_HANDLE :: cast(Handle) 0;

NROHEADER_MAGIC :: 0x304f524e;

NROASSETHEADER_MAGIC :: 0x54455341;
NROASSETHEADER_VERSION :: 0;

CUR_PROCESS_HANDLE :: 0xFFFF8001;

CUR_THREAD_HANDLE :: 0xFFFF8000;

MAX_WAIT_OBJECTS :: 0x40;

CMIF_IN_HEADER_MAGIC :: 0x49434653;
CMIF_OUT_HEADER_MAGIC :: 0x4F434653;

NX_SESSION_MGR_MAX_SESSIONS :: 16;

SHA256_HASH_SIZE :: 0x20;

SHA256_BLOCK_SIZE :: 0x40;

ACC_USER_LIST_SIZE :: 8;

FS_MAX_PATH :: 0x301;

FS_SAVEDATA_CURRENT_APPLICATIONID :: 0;

SET_MAX_NAME_SIZE :: 0x48;

AUDREN_TIMER_FREQ_HZ :: 200.0;
AUDREN_TIMER_PERIOD_MS :: 5.0;
AUDREN_SAMPLES_PER_FRAME_32KHZ :: 160;
AUDREN_SAMPLES_PER_FRAME_48KHZ :: 240;

AUDREN_INPUT_PARAM_ALIGNMENT :: 0x1000;
AUDREN_OUTPUT_PARAM_ALIGNMENT :: 0x10;
AUDREN_MEMPOOL_ALIGNMENT :: 0x1000;
AUDREN_BUFFER_ALIGNMENT :: 0x40;

AUDREN_REVISION_1 :: 0x31564552;
AUDREN_REVISION_2 :: 0x32564552;
AUDREN_REVISION_3 :: 0x33564552;
AUDREN_REVISION_4 :: 0x34564552;
AUDREN_REVISION_5 :: 0x35564552;
AUDREN_REVISION_6 :: 0x36564552;

AUDREN_FINAL_MIX_ID :: 0;
AUDREN_UNUSED_MIX_ID :: 0x7FFFFFFF;
AUDREN_UNUSED_SPLITTER_ID :: 0xFFFFFFFF;

AUDREN_DEFAULT_DEVICE_NAME :: "MainAudioOut";

USB_DT_INTERFACE_SIZE :: 9;
USB_DT_ENDPOINT_SIZE :: 7;
USB_DT_DEVICE_SIZE :: 0x12;
USB_DT_SS_ENDPOINT_COMPANION_SIZE :: 6;

USB_ENDPOINT_ADDRESS_MASK :: 0x0f;
USB_ENDPOINT_DIR_MASK :: 0x80;

USB_TRANSFER_TYPE_MASK :: 0x03;

USBDS_DEFAULT_InterfaceNumber :: 0x4;

JOYSTICK_MAX :: 0x7FFF;
JOYSTICK_MIN :: -0x7FFF;

IRS_MAX_CAMERAS :: 0x9;

NSSU_CARDUPDATE_TMEM_SIZE_DEFAULT :: 0x100000;

SPL_RSA_BUFFER_SIZE :: 0x100;

CAPSSC_JPEG_BUFFER_SIZE :: 0x80000;

BINDER_FIRST_CALL_TRANSACTION :: 0x1;

_NV_IOC_NRBITS :: 8;
_NV_IOC_TYPEBITS :: 8;
_NV_IOC_SIZEBITS :: 14;
_NV_IOC_DIRBITS :: 2;

_NV_IOC_NRMASK :: (1 << _NV_IOC_NRBITS)-1;
_NV_IOC_TYPEMASK :: (1 << _NV_IOC_TYPEBITS)-1;
_NV_IOC_SIZEMASK :: (1 << _NV_IOC_SIZEBITS)-1;
_NV_IOC_DIRMASK :: (1 << _NV_IOC_DIRBITS)-1;

_NV_IOC_NRSHIFT :: 0;
_NV_IOC_TYPESHIFT :: _NV_IOC_NRSHIFT+_NV_IOC_NRBITS;
_NV_IOC_SIZESHIFT :: _NV_IOC_TYPESHIFT+_NV_IOC_TYPEBITS;
_NV_IOC_DIRSHIFT :: _NV_IOC_SIZESHIFT+_NV_IOC_SIZEBITS;

_NV_IOC_NONE :: 0;
_NV_IOC_WRITE :: 1;
_NV_IOC_READ :: 2;

NVGPU_ZBC_TYPE_INVALID :: 0;
NVGPU_ZBC_TYPE_COLOR :: 1;
NVGPU_ZBC_TYPE_DEPTH :: 2;

GRC_MOVIEMAKER_WORKMEMORY_SIZE_DEFAULT :: 0x6000000;

NOTIF_MAX_ALARMS :: 8;

PARCEL_MAX_PAYLOAD :: 0x400;

GPFIFO_QUEUE_SIZE :: 0x800;

NXLINK_SERVER_PORT :: 28280;
NXLINK_CLIENT_PORT :: 28771;

PAD_ANY_ID_MASK :: 0x1000100FF;

RINGCON_CAL_MAGIC :: -0x3502;

CONSOLE_COLOR_BOLD :: 1<<0;
CONSOLE_COLOR_FAINT :: 1<<1;
CONSOLE_ITALIC :: 1<<2;
CONSOLE_UNDERLINE :: 1<<3;
CONSOLE_BLINK_SLOW :: 1<<4;
CONSOLE_BLINK_FAST :: 1<<5;
CONSOLE_COLOR_REVERSE :: 1<<6;
CONSOLE_CONCEAL :: 1<<7;
CONSOLE_CROSSED_OUT :: 1<<8;
CONSOLE_FG_CUSTOM :: 1<<9;
CONSOLE_BG_CUSTOM :: 1<<10;

FSDEV_DIRITER_MAGIC :: 0x66736476;

AES_BLOCK_SIZE :: 0x10;

AES_128_KEY_SIZE :: 0x10;

AES_128_NUM_ROUNDS :: 10;

AES_192_KEY_SIZE :: 0x18;

AES_192_NUM_ROUNDS :: 12;

AES_256_KEY_SIZE :: 0x20;

AES_256_NUM_ROUNDS :: 14;

SHA1_HASH_SIZE :: 0x14;

SHA1_BLOCK_SIZE :: 0x40;

vu8 :: u8;
vu16 :: u16;
vu32 :: u32;
vu64 :: u64;

vs8 :: s8;
vs16 :: s16;
vs32 :: s32;
vs64 :: s64;

Handle :: u32;
Result :: u32;
ThreadFunc :: #type (unknown0: *void) -> void #c_call;
VoidFn :: #type () -> void #c_call;

Uuid :: struct {
    uuid: [16] u8; ///< Unique identifier.
}

UtilFloat3 :: struct {
    value: [3] float; ///< 3 floats.
}

/// Module values
Module :: enum u32 {
    Kernel         :: 1;
    Libnx          :: 345;
    HomebrewAbi    :: 346;
    HomebrewLoader :: 347;
    LibnxNvidia    :: 348;
    LibnxBinder    :: 349;
}

/// Kernel error codes
KernelError :: enum u32 {
    OutOfSessions               :: 7;
    InvalidCapabilityDescriptor :: 14;
    NotImplemented              :: 33;
    ThreadTerminating           :: 59;
    OutOfDebugEvents            :: 70;
    InvalidSize                 :: 101;
    InvalidAddress              :: 102;
    ResourceExhausted           :: 103;
    OutOfMemory                 :: 104;
    OutOfHandles                :: 105;
    InvalidMemoryState          :: 106;
    InvalidMemoryPermissions    :: 108;
    InvalidMemoryRange          :: 110;
    InvalidPriority             :: 112;
    InvalidCoreId               :: 113;
    InvalidHandle               :: 114;
    InvalidUserBuffer           :: 115;
    InvalidCombination          :: 116;
    TimedOut                    :: 117;
    Cancelled                   :: 118;
    OutOfRange                  :: 119;
    InvalidEnumValue            :: 120;
    NotFound                    :: 121;
    AlreadyExists               :: 122;
    ConnectionClosed            :: 123;
    UnhandledUserInterrupt      :: 124;
    InvalidState                :: 125;
    ReservedValue               :: 126;
    InvalidHwBreakpoint         :: 127;
    FatalUserException          :: 128;
    OwnedByAnotherProcess       :: 129;
    ConnectionRefused           :: 131;
    OutOfResource               :: 132;
    IpcMapFailed                :: 259;
    IpcCmdbufTooSmall           :: 260;
    NotDebugged                 :: 520;
}

/// libnx error codes
LibnxError :: enum u32 {
    BadReloc                      :: 1;
    OutOfMemory                   :: 2;
    AlreadyMapped                 :: 3;
    BadGetInfo_Stack              :: 4;
    BadGetInfo_Heap               :: 5;
    BadQueryMemory                :: 6;
    AlreadyInitialized            :: 7;
    NotInitialized                :: 8;
    NotFound                      :: 9;
    IoError                       :: 10;
    BadInput                      :: 11;
    BadReent                      :: 12;
    BufferProducerError           :: 13;
    HandleTooEarly                :: 14;
    HeapAllocFailed               :: 15;
    TooManyOverrides              :: 16;
    ParcelError                   :: 17;
    BadGfxInit                    :: 18;
    BadGfxEventWait               :: 19;
    BadGfxQueueBuffer             :: 20;
    BadGfxDequeueBuffer           :: 21;
    AppletCmdidNotFound           :: 22;
    BadAppletReceiveMessage       :: 23;
    BadAppletNotifyRunning        :: 24;
    BadAppletGetCurrentFocusState :: 25;
    BadAppletGetOperationMode     :: 26;
    BadAppletGetPerformanceMode   :: 27;
    BadUsbCommsRead               :: 28;
    BadUsbCommsWrite              :: 29;
    InitFail_SM                   :: 30;
    InitFail_AM                   :: 31;
    InitFail_HID                  :: 32;
    InitFail_FS                   :: 33;
    BadGetInfo_Rng                :: 34;
    JitUnavailable                :: 35;
    WeirdKernel                   :: 36;
    IncompatSysVer                :: 37;
    InitFail_Time                 :: 38;
    TooManyDevOpTabs              :: 39;
    DomainMessageUnknownType      :: 40;
    DomainMessageTooManyObjectIds :: 41;
    AppletFailedToInitialize      :: 42;
    ApmFailedToInitialize         :: 43;
    NvinfoFailedToInitialize      :: 44;
    NvbufFailedToInitialize       :: 45;
    LibAppletBadExit              :: 46;
    InvalidCmifOutHeader          :: 47;
    ShouldNotHappen               :: 48;
    Timeout                       :: 49;
}

/// libnx binder error codes
LibnxBinderError :: enum u32 {
    Unknown            :: 1;
    NoMemory           :: 2;
    InvalidOperation   :: 3;
    BadValue           :: 4;
    BadType            :: 5;
    NameNotFound       :: 6;
    PermissionDenied   :: 7;
    NoInit             :: 8;
    AlreadyExists      :: 9;
    DeadObject         :: 10;
    FailedTransaction  :: 11;
    BadIndex           :: 12;
    NotEnoughData      :: 13;
    WouldBlock         :: 14;
    TimedOut           :: 15;
    UnknownTransaction :: 16;
    FdsNotAllowed      :: 17;
}

/// libnx nvidia error codes
LibnxNvidiaError :: enum u32 {
    Unknown              :: 1;
    NotImplemented       :: 2;
    NotSupported         :: 3;
    NotInitialized       :: 4;
    BadParameter         :: 5;
    Timeout              :: 6;
    InsufficientMemory   :: 7;
    ReadOnlyAttribute    :: 8;
    InvalidState         :: 9;
    InvalidAddress       :: 10;
    InvalidSize          :: 11;
    BadValue             :: 12;
    AlreadyAllocated     :: 13;
    Busy                 :: 14;
    ResourceError        :: 15;
    CountMismatch        :: 16;
    SharedMemoryTooSmall :: 17;
    FileOperationFailed  :: 18;
    IoctlFailed          :: 19;
}

/// Entry for each segment in the codebin.
NroSegment :: struct {
    file_off: u32;
    size:     u32;
}

/// Offset 0x0 in the NRO.
NroStart :: struct {
    unused:     u32;
    mod_offset: u32;
    padding:    [8] u8;
}

/// This follows NroStart, the actual nro-header.
NroHeader :: struct {
    magic:    u32;
    unk1:     u32;
    size:     u32;
    unk2:     u32;
    segments: [3] NroSegment;
    bss_size: u32;
    unk3:     u32;
    build_id: [32] u8;
    padding:  [32] u8;
}

/// Custom asset section.
NroAssetSection :: struct {
    offset: u64;
    size:   u64;
}

/// Custom asset header.
NroAssetHeader :: struct {
    magic:   u32;
    version: u32;
    icon:    NroAssetSection;
    nacp:    NroAssetSection;
    romfs:   NroAssetSection;
}

/// Language entry. These strings are UTF-8.
NacpLanguageEntry :: struct {
    name:   [512] u8;
    author: [256] u8;
}

/// ApplicationNeighborDetectionGroupConfiguration
NacpApplicationNeighborDetectionGroupConfiguration :: struct {
    group_id: u64; ///< GroupId
    key:      [16] u8;
}

/// NeighborDetectionClientConfiguration
NacpNeighborDetectionClientConfiguration :: struct {
    send_group_configuration:        NacpApplicationNeighborDetectionGroupConfiguration; ///< SendGroupConfiguration
    receivable_group_configurations: [16] NacpApplicationNeighborDetectionGroupConfiguration; ///< ReceivableGroupConfigurations
}

/// ApplicationJitConfiguration
NacpApplicationJitConfiguration :: struct {
    flags:       u64; ///< Flags
    memory_size: u64; ///< MemorySize
}

/// ns ApplicationControlProperty
NacpStruct :: struct {
    lang:                                          [16] NacpLanguageEntry; ///< \ref NacpLanguageEntry
    isbn:                                          [37] u8; ///< Isbn
    startup_user_account:                          u8; ///< StartupUserAccount
    user_account_switch_lock:                      u8; ///< UserAccountSwitchLock
    add_on_content_registration_type:              u8; ///< AddOnContentRegistrationType
    attribute_flag:                                u32; ///< AttributeFlag
    supported_language_flag:                       u32; ///< SupportedLanguageFlag
    parental_control_flag:                         u32; ///< ParentalControlFlag
    screenshot:                                    u8; ///< Screenshot
    video_capture:                                 u8; ///< VideoCapture
    data_loss_confirmation:                        u8; ///< DataLossConfirmation
    play_log_policy:                               u8; ///< PlayLogPolicy
    presence_group_id:                             u64; ///< PresenceGroupId
    rating_age:                                    [32] s8; ///< RatingAge
    display_version:                               [16] u8; ///< DisplayVersion
    add_on_content_base_id:                        u64; ///< AddOnContentBaseId
    save_data_owner_id:                            u64; ///< SaveDataOwnerId
    user_account_save_data_size:                   u64; ///< UserAccountSaveDataSize
    user_account_save_data_journal_size:           u64; ///< UserAccountSaveDataJournalSize
    device_save_data_size:                         u64; ///< DeviceSaveDataSize
    device_save_data_journal_size:                 u64; ///< DeviceSaveDataJournalSize
    bcat_delivery_cache_storage_size:              u64; ///< BcatDeliveryCacheStorageSize
    application_error_code_category:               u64; ///< ApplicationErrorCodeCategory
    local_communication_id:                        [8] u64; ///< LocalCommunicationId
    logo_type:                                     u8; ///< LogoType
    logo_handling:                                 u8; ///< LogoHandling
    runtime_add_on_content_install:                u8; ///< RuntimeAddOnContentInstall
    runtime_parameter_delivery:                    u8; ///< RuntimeParameterDelivery
    reserved_x30f4:                                [2] u8; ///< Reserved
    crash_report:                                  u8; ///< CrashReport
    hdcp:                                          u8; ///< Hdcp
    pseudo_device_id_seed:                         u64; ///< SeedForPseudoDeviceId
    bcat_passphrase:                               [65] u8; ///< BcatPassphrase
    startup_user_account_option:                   u8; ///< StartupUserAccountOption
    reserved_for_user_account_save_data_operation: [6] u8; ///< ReservedForUserAccountSaveDataOperation
    user_account_save_data_size_max:               u64; ///< UserAccountSaveDataSizeMax
    user_account_save_data_journal_size_max:       u64; ///< UserAccountSaveDataJournalSizeMax
    device_save_data_size_max:                     u64; ///< DeviceSaveDataSizeMax
    device_save_data_journal_size_max:             u64; ///< DeviceSaveDataJournalSizeMax
    temporary_storage_size:                        u64; ///< TemporaryStorageSize
    cache_storage_size:                            u64; ///< CacheStorageSize
    cache_storage_journal_size:                    u64; ///< CacheStorageJournalSize
    cache_storage_data_and_journal_size_max:       u64; ///< CacheStorageDataAndJournalSizeMax
    cache_storage_index_max:                       u16; ///< CacheStorageIndexMax
    reserved_x318a:                                [6] u8; ///< Reserved
    play_log_queryable_application_id:             [16] u64; ///< PlayLogQueryableApplicationId
    play_log_query_capability:                     u8; ///< PlayLogQueryCapability
    repair_flag:                                   u8; ///< RepairFlag
    program_index:                                 u8; ///< ProgramIndex
    required_network_service_license_on_launch:    u8; ///< RequiredNetworkServiceLicenseOnLaunchFlag
    reserved_x3214:                                u32; ///< Reserved
    neighbor_detection_client_configuration:       NacpNeighborDetectionClientConfiguration; ///< NeighborDetectionClientConfiguration
    jit_configuration:                             NacpApplicationJitConfiguration; ///< JitConfiguration
    reserved_x33c0:                                [3136] u8; ///< Reserved
}

/// Get the NacpLanguageEntry from the input nacp corresponding to the current system language (this may fallback to other languages when needed). Output langentry is NULL if none found / content of entry is empty.
/// If you're using ns you may want to use \ref nsGetApplicationDesiredLanguage instead.
nacpGetLanguageEntry :: (nacp: *NacpStruct, langentry: **NacpLanguageEntry) -> Result #foreign libnx;

/**
* @brief Performs a data cache flush on the specified buffer.
* @param addr Address of the buffer.
* @param size Size of the buffer, in bytes.
* @remarks Cache flush is defined as Clean + Invalidate.
* @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
*/
armDCacheFlush :: (addr: *void, size: u64) -> void #foreign libnx;

/**
* @brief Performs a data cache clean on the specified buffer.
* @param addr Address of the buffer.
* @param size Size of the buffer, in bytes.
* @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
*/
armDCacheClean :: (addr: *void, size: u64) -> void #foreign libnx;

/**
* @brief Performs an instruction cache invalidation clean on the specified buffer.
* @param addr Address of the buffer.
* @param size Size of the buffer, in bytes.
* @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
*/
armICacheInvalidate :: (addr: *void, size: u64) -> void #foreign libnx;

/**
* @brief Performs a data cache zeroing operation on the specified buffer.
* @param addr Address of the buffer.
* @param size Size of the buffer, in bytes.
* @note The start and end addresses of the buffer are forcibly rounded to cache line boundaries (read from CTR_EL0 system register).
*/
armDCacheZero :: (addr: *void, size: u64) -> void #foreign libnx;

/// Armv8 CPU register.
CpuRegister :: union {
    x: u64; ///< 64-bit AArch64 register view.
    w: u32; ///< 32-bit AArch64 register view.
    r: u32; ///< AArch32 register view.
}

/// Armv8 NEON register.
FpuRegister :: union {
    d: float64; ///< 64-bit double-precision view.
    s: float; ///< 32-bit single-precision view.
}

/// Armv8 register group. @ref svcGetThreadContext3 uses @ref RegisterGroup_All.
RegisterGroup :: enum u32 {
    CpuGprs :: 1;
    CpuSprs :: 2;
    FpuGprs :: 4;
    FpuSprs :: 8;

    CpuAll  :: 3;
    FpuAll  :: 12;
    All     :: 15;
}

/// This is for \ref ThreadExceptionDump error_desc.
ThreadExceptionDesc :: enum u32 {
    InstructionAbort :: 256;
    MisalignedPC     :: 258;
    MisalignedSP     :: 259;
    SError           :: 262;
    BadSVC           :: 769;
    Trap             :: 260;
    Other            :: 257;
}

/// Thread context structure (register dump)
ThreadContext :: struct {
    cpu_gprs: [29] CpuRegister; ///< GPRs 0..28. Note: also contains AArch32 SPRs.
    fp:       u64; ///< Frame pointer (x29) (AArch64). For AArch32, check r11.
    lr:       u64; ///< Link register (x30) (AArch64). For AArch32, check r14.
    sp:       u64; ///< Stack pointer (AArch64). For AArch32, check r13.
    pc:       CpuRegister; ///< Program counter.
    psr:      u32; ///< PSTATE or cpsr.

    fpu_gprs: [32] FpuRegister; ///< 32 general-purpose NEON registers.
    fpcr:     u32; ///< Floating-point control register.
    fpsr:     u32; ///< Floating-point status register.

    tpidr:    u64; ///< EL0 Read/Write Software Thread ID Register.
}

/// Thread exception dump structure.
ThreadExceptionDump :: struct {
    error_desc: u32; ///< See \ref ThreadExceptionDesc.
    pad:        [3] u32;

    cpu_gprs:   [29] CpuRegister; ///< GPRs 0..28. Note: also contains AArch32 registers.
    fp:         CpuRegister; ///< Frame pointer.
    lr:         CpuRegister; ///< Link register.
    sp:         CpuRegister; ///< Stack pointer.
    pc:         CpuRegister; ///< Program counter (elr_el1).

    padding:    u64;

    fpu_gprs:   [32] FpuRegister; ///< 32 general-purpose NEON registers.

    pstate:     u32; ///< pstate & 0xFF0FFE20
    afsr0:      u32;
    afsr1:      u32;
    esr:        u32;

    far:        CpuRegister; ///< Fault Address Register.
}

ThreadExceptionFrameA64 :: struct {
    cpu_gprs: [9] u64; ///< GPRs 0..8.
    lr:       u64;
    sp:       u64;
    elr_el1:  u64;
    pstate:   u32; ///< pstate & 0xFF0FFE20
    afsr0:    u32;
    afsr1:    u32;
    esr:      u32;
    far:      u64;
}

ThreadExceptionFrameA32 :: struct {
    cpu_gprs:  [8] u32; ///< GPRs 0..7.
    sp:        u32;
    lr:        u32;
    elr_el1:   u32;
    tpidr_el0: u32; ///< tpidr_el0 = 1
    cpsr:      u32; ///< cpsr & 0xFF0FFE20
    afsr0:     u32;
    afsr1:     u32;
    esr:       u32;
    far:       u32;
}

/// Memory type enumeration (lower 8 bits of \ref MemoryState)
MemoryType :: enum u32 {
    Unmapped            :: 0;
    Io                  :: 1;
    Normal              :: 2;
    CodeStatic          :: 3;
    CodeMutable         :: 4;
    Heap                :: 5;
    SharedMem           :: 6;
    WeirdMappedMem      :: 7;
    ModuleCodeStatic    :: 8;
    ModuleCodeMutable   :: 9;
    IpcBuffer0          :: 10;
    MappedMemory        :: 11;
    ThreadLocal         :: 12;
    TransferMemIsolated :: 13;
    TransferMem         :: 14;
    ProcessMem          :: 15;
    Reserved            :: 16;
    IpcBuffer1          :: 17;
    IpcBuffer3          :: 18;
    KernelStack         :: 19;
    CodeReadOnly        :: 20;
    CodeWritable        :: 21;
    Coverage            :: 22;
    Insecure            :: 23;
}

/// Memory state bitmasks.
MemoryState :: enum u32 {
    Type                       :: 255;
    PermChangeAllowed          :: 256;
    ForceRwByDebugSyscalls     :: 512;
    IpcSendAllowed_Type0       :: 1024;
    IpcSendAllowed_Type3       :: 2048;
    IpcSendAllowed_Type1       :: 4096;
    ProcessPermChangeAllowed   :: 16384;
    MapAllowed                 :: 32768;
    UnmapProcessCodeMemAllowed :: 65536;
    TransferMemAllowed         :: 131072;
    QueryPAddrAllowed          :: 262144;
    MapDeviceAllowed           :: 524288;
    MapDeviceAlignedAllowed    :: 1048576;
    IpcBufferAllowed           :: 2097152;
    IsPoolAllocated            :: 4194304;
    IsRefCounted               :: 4194304;
    MapProcessAllowed          :: 8388608;
    AttrChangeAllowed          :: 16777216;
    CodeMemAllowed             :: 33554432;
}

/// Memory attribute bitmasks.
MemoryAttribute :: enum u32 {
    IsBorrowed         :: 1;
    IsIpcMapped        :: 2;
    IsDeviceMapped     :: 4;
    IsUncached         :: 8;
    IsPermissionLocked :: 16;
}

/// Memory permission bitmasks.
Permission :: enum u32 {
    None     :: 0;
    R        :: 1;
    W        :: 2;
    X        :: 4;
    Rw       :: 3;
    Rx       :: 5;
    DontCare :: 268435456;
}

/// Memory information structure.
MemoryInfo :: struct {
    addr:            u64; ///< Base address.
    size:            u64; ///< Size.
    type:            u32; ///< Memory type (see lower 8 bits of \ref MemoryState).
    attr:            u32; ///< Memory attributes (see \ref MemoryAttribute).
    perm:            u32; ///< Memory permissions (see \ref Permission).
    ipc_refcount:    u32; ///< IPC reference count.
    device_refcount: u32; ///< Device reference count.
    padding:         u32; ///< Padding.
}

/// Physical memory information structure.
PhysicalMemoryInfo :: struct {
    physical_address: u64; ///< Physical address.
    virtual_address:  u64; ///< Virtual address.
    size:             u64; ///< Size.
}

/// Secure monitor arguments.
SecmonArgs :: struct {
    X: [8] u64; ///< Values of X0 through X7.
}

/// Break reasons
BreakReason :: enum u32 {
    Panic                :: 0;
    Assert               :: 1;
    User                 :: 2;
    PreLoadDll           :: 3;
    PostLoadDll          :: 4;
    PreUnloadDll         :: 5;
    PostUnloadDll        :: 6;
    CppException         :: 7;

    NotificationOnlyFlag :: 2147483648;
}

/// Code memory mapping operations
CodeMapOperation :: enum u32 {
    MapOwner   :: 0;
    MapSlave   :: 1;
    UnmapOwner :: 2;
    UnmapSlave :: 3;
}

/// Limitable Resources.
LimitableResource :: enum u32 {
    Memory           :: 0;
    Threads          :: 1;
    Events           :: 2;
    TransferMemories :: 3;
    Sessions         :: 4;
}

/// Thread Activity.
ThreadActivity :: enum u32 {
    Runnable :: 0;
    Paused   :: 1;
}

/// Process Information.
ProcessInfoType :: enum u32 {
    ProcessState :: 0;
}

/// Process States.
ProcessState :: enum u32 {
    Created         :: 0;
    CreatedAttached :: 1;
    Running         :: 2;
    Crashed         :: 3;
    RunningAttached :: 4;
    Exiting         :: 5;
    Exited          :: 6;
    DebugSuspended  :: 7;
}

/// Process Activity.
ProcessActivity :: enum u32 {
    Runnable :: 0;
    Paused   :: 1;
}

/// Debug Thread Parameters.
DebugThreadParam :: enum u32 {
    ActualPriority :: 0;
    State          :: 1;
    IdealCore      :: 2;
    CurrentCore    :: 3;
    CoreMask       :: 4;
}

/// GetInfo IDs.
InfoType :: enum u32 {
    CoreMask                    :: 0;
    PriorityMask                :: 1;
    AliasRegionAddress          :: 2;
    AliasRegionSize             :: 3;
    HeapRegionAddress           :: 4;
    HeapRegionSize              :: 5;
    TotalMemorySize             :: 6;
    UsedMemorySize              :: 7;
    DebuggerAttached            :: 8;
    ResourceLimit               :: 9;
    IdleTickCount               :: 10;
    RandomEntropy               :: 11;
    AslrRegionAddress           :: 12;
    AslrRegionSize              :: 13;
    StackRegionAddress          :: 14;
    StackRegionSize             :: 15;
    SystemResourceSizeTotal     :: 16;
    SystemResourceSizeUsed      :: 17;
    ProgramId                   :: 18;
    InitialProcessIdRange       :: 19;
    UserExceptionContextAddress :: 20;
    TotalNonSystemMemorySize    :: 21;
    UsedNonSystemMemorySize     :: 22;
    IsApplication               :: 23;
    FreeThreadCount             :: 24;
    ThreadTickCount             :: 25;
    IsSvcPermitted              :: 26;

    ThreadTickCountDeprecated   :: 4026531842;
}

/// GetSystemInfo IDs.
SystemInfoType :: enum u32 {
    TotalPhysicalMemorySize :: 0;
    UsedPhysicalMemorySize  :: 1;
    InitialProcessIdRange   :: 2;
}

/// GetInfo Idle/Thread Tick Count Sub IDs.
TickCountInfo :: enum u64 {
    Core0 :: 0;
    Core1 :: 1;
    Core2 :: 2;
    Core3 :: 3;

    Total :: 18446744073709551615;
}

/// GetInfo InitialProcessIdRange Sub IDs.
InitialProcessIdRangeInfo :: enum u32 {
    Minimum :: 0;
    Maximum :: 1;
}

/// GetSystemInfo PhysicalMemory Sub IDs.
PhysicalMemorySystemInfo :: enum u32 {
    Application  :: 0;
    Applet       :: 1;
    System       :: 2;
    SystemUnsafe :: 3;
}

/// SleepThread yield types.
YieldType :: enum s32 {
    WithoutCoreMigration :: 0;
    WithCoreMigration    :: -1;
    ToAnyThread          :: -2;
}

/// SignalToAddress behaviors.
SignalType :: enum u32 {
    Signal                                          :: 0;
    SignalAndIncrementIfEqual                       :: 1;
    SignalAndModifyBasedOnWaitingThreadCountIfEqual :: 2;
}

/// WaitForAddress behaviors.
ArbitrationType :: enum u32 {
    WaitIfLessThan             :: 0;
    DecrementAndWaitIfLessThan :: 1;
    WaitIfEqual                :: 2;
}

/// Context of a scheduled thread.
LastThreadContext :: struct {
    fp: u64; ///< Frame Pointer for the thread.
    sp: u64; ///< Stack Pointer for the thread.
    lr: u64; ///< Link Register for the thread.
    pc: u64; ///< Program Counter for the thread.
}

/// Memory mapping type.
MemoryMapping :: enum u32 {
    IoRegister :: 0;
    Uncached   :: 1;
    Memory     :: 2;
}

/// Io Pools.
IoPoolType :: enum u32 {
    PcieA2 :: 0;
}

/**
* @brief Set the process heap to a given size. It can both extend and shrink the heap.
* @param[out] out_addr Variable to which write the address of the heap (which is randomized and fixed by the kernel)
* @param[in] size Size of the heap, must be a multiple of 0x200000 and [2.0.0+] less than 0x18000000.
* @return Result code.
* @note Syscall number 0x01.
*/
svcSetHeapSize :: (out_addr: **void, size: u64) -> Result #foreign libnx;

/**
* @brief Set the memory permissions of a (page-aligned) range of memory.
* @param[in] addr Start address of the range.
* @param[in] size Size of the range, in bytes.
* @param[in] perm Permissions (see \ref Permission).
* @return Result code.
* @remark Perm_X is not allowed. Setting write-only is not allowed either (Perm_W).
*         This can be used to move back and forth between Perm_None, Perm_R and Perm_Rw.
* @note Syscall number 0x02.
*/
svcSetMemoryPermission :: (addr: *void, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Set the memory attributes of a (page-aligned) range of memory.
* @param[in] addr Start address of the range.
* @param[in] size Size of the range, in bytes.
* @param[in] val0 State0
* @param[in] val1 State1
* @return Result code.
* @remark See <a href="https://switchbrew.org/wiki/SVC#svcSetMemoryAttribute">switchbrew.org Wiki</a> for more details.
* @note Syscall number 0x03.
*/
svcSetMemoryAttribute :: (addr: *void, size: u64, val0: u32, val1: u32) -> Result #foreign libnx;

/**
* @brief Maps a memory range into a different range. Mainly used for adding guard pages around stack.
* Source range gets reprotected to Perm_None (it can no longer be accessed), and \ref MemAttr_IsBorrowed is set in the source \ref MemoryAttribute.
* @param[in] dst_addr Destination address.
* @param[in] src_addr Source address.
* @param[in] size Size of the range.
* @return Result code.
* @note Syscall number 0x04.
*/
svcMapMemory :: (dst_addr: *void, src_addr: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Unmaps a region that was previously mapped with \ref svcMapMemory.
* @param[in] dst_addr Destination address.
* @param[in] src_addr Source address.
* @param[in] size Size of the range.
* @return Result code.
* @note Syscall number 0x05.
*/
svcUnmapMemory :: (dst_addr: *void, src_addr: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Query information about an address. Will always fetch the lowest page-aligned mapping that contains the provided address.
* @param[out] meminfo_ptr \ref MemoryInfo structure which will be filled in.
* @param[out] pageinfo Page information which will be filled in.
* @param[in] addr Address to query.
* @return Result code.
* @note Syscall number 0x06.
*/
svcQueryMemory :: (meminfo_ptr: *MemoryInfo, pageinfo: *u32, addr: u64) -> Result #foreign libnx;

/**
* @brief Exits the current process.
* @note Syscall number 0x07.
*/
svcExitProcess :: () -> void #foreign libnx;

/**
* @brief Creates a thread.
* @return Result code.
* @note Syscall number 0x08.
*/
svcCreateThread :: (out: *Handle, entry: *void, arg: *void, stack_top: *void, prio: s32, cpuid: s32) -> Result #foreign libnx;

/**
* @brief Starts a freshly created thread.
* @return Result code.
* @note Syscall number 0x09.
*/
svcStartThread :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Exits the current thread.
* @note Syscall number 0x0A.
*/
svcExitThread :: () -> void #foreign libnx;

/**
* @brief Sleeps the current thread for the specified amount of time.
* @param[in] nano Number of nanoseconds to sleep, or \ref YieldType for yield.
* @note Syscall number 0x0B.
*/
svcSleepThread :: (nano: s64) -> void #foreign libnx;

/**
* @brief Gets a thread's priority.
* @return Result code.
* @note Syscall number 0x0C.
*/
svcGetThreadPriority :: (priority: *s32, handle: Handle) -> Result #foreign libnx;

/**
* @brief Sets a thread's priority.
* @return Result code.
* @note Syscall number 0x0D.
*/
svcSetThreadPriority :: (handle: Handle, priority: u32) -> Result #foreign libnx;

/**
* @brief Gets a thread's core mask.
* @return Result code.
* @note Syscall number 0x0E.
*/
svcGetThreadCoreMask :: (preferred_core: *s32, affinity_mask: *u64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Sets a thread's core mask.
* @return Result code.
* @note Syscall number 0x0F.
*/
svcSetThreadCoreMask :: (handle: Handle, preferred_core: s32, affinity_mask: u32) -> Result #foreign libnx;

/**
* @brief Gets the current processor's number.
* @return The current processor's number.
* @note Syscall number 0x10.
*/
svcGetCurrentProcessorNumber :: () -> u32 #foreign libnx;

/**
* @brief Sets an event's signalled status.
* @return Result code.
* @note Syscall number 0x11.
*/
svcSignalEvent :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Clears an event's signalled status.
* @return Result code.
* @note Syscall number 0x12.
*/
svcClearEvent :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Maps a block of shared memory.
* @return Result code.
* @note Syscall number 0x13.
*/
svcMapSharedMemory :: (handle: Handle, addr: *void, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Unmaps a block of shared memory.
* @return Result code.
* @note Syscall number 0x14.
*/
svcUnmapSharedMemory :: (handle: Handle, addr: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Creates a block of transfer memory.
* @return Result code.
* @note Syscall number 0x15.
*/
svcCreateTransferMemory :: (out: *Handle, addr: *void, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Closes a handle, decrementing the reference count of the corresponding kernel object.
* This might result in the kernel freeing the object.
* @param handle Handle to close.
* @return Result code.
* @note Syscall number 0x16.
*/
svcCloseHandle :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Resets a signal.
* @return Result code.
* @note Syscall number 0x17.
*/
svcResetSignal :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Waits on one or more synchronization objects, optionally with a timeout.
* @return Result code.
* @note Syscall number 0x18.
* @note \p handleCount must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
* @note This is the raw syscall, which can be cancelled by \ref svcCancelSynchronization or other means. \ref waitHandles or \ref waitMultiHandle should normally be used instead.
*/
svcWaitSynchronization :: (index: *s32, handles: *Handle, handleCount: s32, timeout: u64) -> Result #foreign libnx;

/**
* @brief Waits a \ref svcWaitSynchronization operation being done on a synchronization object in another thread.
* @return Result code.
* @note Syscall number 0x19.
*/
svcCancelSynchronization :: (thread: Handle) -> Result #foreign libnx;

/**
* @brief Arbitrates a mutex lock operation in userspace.
* @return Result code.
* @note Syscall number 0x1A.
*/
svcArbitrateLock :: (wait_tag: u32, tag_location: *u32, self_tag: u32) -> Result #foreign libnx;

/**
* @brief Arbitrates a mutex unlock operation in userspace.
* @return Result code.
* @note Syscall number 0x1B.
*/
svcArbitrateUnlock :: (tag_location: *u32) -> Result #foreign libnx;

/**
* @brief Performs a condition variable wait operation in userspace.
* @return Result code.
* @note Syscall number 0x1C.
*/
svcWaitProcessWideKeyAtomic :: (key: *u32, tag_location: *u32, self_tag: u32, timeout: u64) -> Result #foreign libnx;

/**
* @brief Performs a condition variable wake-up operation in userspace.
* @note Syscall number 0x1D.
*/
svcSignalProcessWideKey :: (key: *u32, num: s32) -> void #foreign libnx;

/**
* @brief Gets the current system tick.
* @return The current system tick.
* @note Syscall number 0x1E.
*/
svcGetSystemTick :: () -> u64 #foreign libnx;

/**
* @brief Connects to a registered named port.
* @return Result code.
* @note Syscall number 0x1F.
*/
svcConnectToNamedPort :: (session: *Handle, name: *u8) -> Result #foreign libnx;

/**
* @brief Sends a light IPC synchronization request to a session.
* @return Result code.
* @note Syscall number 0x20.
*/
svcSendSyncRequestLight :: (session: Handle) -> Result #foreign libnx;

/**
* @brief Sends an IPC synchronization request to a session.
* @return Result code.
* @note Syscall number 0x21.
*/
svcSendSyncRequest :: (session: Handle) -> Result #foreign libnx;

/**
* @brief Sends an IPC synchronization request to a session from an user allocated buffer.
* @return Result code.
* @remark size must be allocated to 0x1000 bytes.
* @note Syscall number 0x22.
*/
svcSendSyncRequestWithUserBuffer :: (usrBuffer: *void, size: u64, session: Handle) -> Result #foreign libnx;

/**
* @brief Sends an IPC synchronization request to a session from an user allocated buffer (asynchronous version).
* @return Result code.
* @remark size must be allocated to 0x1000 bytes.
* @note Syscall number 0x23.
*/
svcSendAsyncRequestWithUserBuffer :: (handle: *Handle, usrBuffer: *void, size: u64, session: Handle) -> Result #foreign libnx;

/**
* @brief Gets the PID associated with a process.
* @return Result code.
* @note Syscall number 0x24.
*/
svcGetProcessId :: (processID: *u64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Gets the TID associated with a process.
* @return Result code.
* @note Syscall number 0x25.
*/
svcGetThreadId :: (threadID: *u64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Breaks execution.
* @param[in] breakReason Break reason (see \ref BreakReason).
* @param[in] address Address of the buffer to pass to the debugger.
* @param[in] size Size of the buffer to pass to the debugger.
* @return Result code.
* @note Syscall number 0x26.
*/
svcBreak :: (breakReason: u32, address: __uintptr_t, size: __uintptr_t) -> Result #foreign libnx;

/**
* @brief Outputs debug text, if used during debugging.
* @param[in] str Text to output.
* @param[in] size Size of the text in bytes.
* @return Result code.
* @note Syscall number 0x27.
*/
svcOutputDebugString :: (str: *u8, size: u64) -> Result #foreign libnx;

/**
* @brief Returns from an exception.
* @param[in] res Result code.
* @note Syscall number 0x28.
*/
svcReturnFromException :: (res: Result) -> void #foreign libnx;

/**
* @brief Retrieves information about the system, or a certain kernel object.
* @param[out] out Variable to which store the information.
* @param[in] id0 First ID of the property to retrieve.
* @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
* @param[in] id1 Second ID of the property to retrieve.
* @return Result code.
* @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetInfo">switchbrew.org wiki</a>.
* @note Syscall number 0x29.
*/
svcGetInfo :: (out: *u64, id0: u32, handle: Handle, id1: u64) -> Result #foreign libnx;

/**
* @brief Flushes the entire data cache (by set/way).
* @note Syscall number 0x2A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
* @warning This syscall is dangerous, and should not be used.
*/
svcFlushEntireDataCache :: () -> void #foreign libnx;

/**
* @brief Flushes data cache for a virtual address range.
* @param[in] address Address of region to flush.
* @param[in] size Size of region to flush.
* @remark armDCacheFlush should be used instead of this syscall whenever possible.
* @note Syscall number 0x2B.
*/
svcFlushDataCache :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Maps new heap memory at the desired address. [3.0.0+]
* @return Result code.
* @note Syscall number 0x2C.
*/
svcMapPhysicalMemory :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapPhysicalMemory. [3.0.0+]
* @return Result code.
* @note Syscall number 0x2D.
*/
svcUnmapPhysicalMemory :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets information about a thread that will be scheduled in the future. [5.0.0+]
* @param[out] out_context Output \ref LastThreadContext for the thread that will be scheduled.
* @param[out] out_thread_id Output thread id for the thread that will be scheduled.
* @param[in] debug Debug handle.
* @param[in] ns Nanoseconds in the future to get scheduled thread at.
* @return Result code.
* @note Syscall number 0x2E.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetDebugFutureThreadInfo :: (out_context: *LastThreadContext, out_thread_id: *u64, debug: Handle, ns: s64) -> Result #foreign libnx;

/**
* @brief Gets information about the previously-scheduled thread.
* @param[out] out_context Output \ref LastThreadContext for the previously scheduled thread.
* @param[out] out_tls_address Output tls address for the previously scheduled thread.
* @param[out] out_flags Output flags for the previously scheduled thread.
* @return Result code.
* @note Syscall number 0x2F.
*/
svcGetLastThreadInfo :: (out_context: *LastThreadContext, out_tls_address: *u64, out_flags: *u32) -> Result #foreign libnx;

/**
* @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
* @return Result code.
* @note Syscall number 0x30.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetResourceLimitLimitValue :: (out: *s64, reslimit_h: Handle, which: LimitableResource) -> Result #foreign libnx;

/**
* @brief Gets the maximum value a LimitableResource can have, for a Resource Limit handle.
* @return Result code.
* @note Syscall number 0x31.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetResourceLimitCurrentValue :: (out: *s64, reslimit_h: Handle, which: LimitableResource) -> Result #foreign libnx;

/**
* @brief Configures the pause/unpause status of a thread.
* @return Result code.
* @note Syscall number 0x32.
*/
svcSetThreadActivity :: (thread: Handle, paused: ThreadActivity) -> Result #foreign libnx;

/**
* @brief Dumps the registers of a thread paused by @ref svcSetThreadActivity (register groups: all).
* @param[out] ctx Output thread context (register dump).
* @param[in] thread Thread handle.
* @return Result code.
* @note Syscall number 0x33.
* @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
*/
svcGetThreadContext3 :: (ctx: *ThreadContext, thread: Handle) -> Result #foreign libnx;

/**
* @brief Arbitrates an address depending on type and value. [4.0.0+]
* @param[in] address Address to arbitrate.
* @param[in] arb_type \ref ArbitrationType to use.
* @param[in] value Value to arbitrate on.
* @param[in] timeout Maximum time in nanoseconds to wait.
* @return Result code.
* @note Syscall number 0x34.
*/
svcWaitForAddress :: (address: *void, arb_type: u32, value: s32, timeout: s64) -> Result #foreign libnx;

/**
* @brief Signals (and updates) an address depending on type and value. [4.0.0+]
* @param[in] address Address to arbitrate.
* @param[in] signal_type \ref SignalType to use.
* @param[in] value Value to arbitrate on.
* @param[in] count Number of waiting threads to signal.
* @return Result code.
* @note Syscall number 0x35.
*/
svcSignalToAddress :: (address: *void, signal_type: u32, value: s32, count: s32) -> Result #foreign libnx;

/**
* @brief Sets thread preemption state (used during abort/panic). [8.0.0+]
* @note Syscall number 0x36.
*/
svcSynchronizePreemptionState :: () -> void #foreign libnx;

/**
* @brief Gets the peak value a LimitableResource has had, for a Resource Limit handle. [11.0.0+]
* @return Result code.
* @note Syscall number 0x37.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetResourceLimitPeakValue :: (out: *s64, reslimit_h: Handle, which: LimitableResource) -> Result #foreign libnx;

/**
* @brief Creates an IO Pool. [13.0.0+]
* @return Result code.
* @note Syscall number 0x39.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateIoPool :: (out_handle: *Handle, pool_type: u32) -> Result #foreign libnx;

/**
* @brief Creates an IO Region. [13.0.0+]
* @return Result code.
* @note Syscall number 0x3A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateIoRegion :: (out_handle: *Handle, io_pool_h: Handle, physical_address: u64, size: u64, memory_mapping: u32, perm: u32) -> Result #foreign libnx;

///@name Debugging
///@{
/**
* @brief Causes the kernel to dump debug information. [1.0.0-3.0.2]
* @param[in] dump_info_type Type of information to dump.
* @param[in] arg0 Argument to the debugging operation.
* @note Syscall number 0x3C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcDumpInfo :: (dump_info_type: u32, arg0: u64) -> void #foreign libnx;

/**
* @brief Performs a debugging operation on the kernel. [4.0.0+]
* @param[in] kern_debug_type Type of debugging operation to perform.
* @param[in] arg0 First argument to the debugging operation.
* @param[in] arg1 Second argument to the debugging operation.
* @param[in] arg2 Third argument to the debugging operation.
* @note Syscall number 0x3C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcKernelDebug :: (kern_debug_type: u32, arg0: u64, arg1: u64, arg2: u64) -> void #foreign libnx;

/**
* @brief Performs a debugging operation on the kernel. [4.0.0+]
* @param[in] kern_trace_state Type of tracing the kernel should perform.
* @note Syscall number 0x3D.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcChangeKernelTraceState :: (kern_trace_state: u32) -> void #foreign libnx;

/**
* @brief Creates an IPC session.
* @return Result code.
* @note Syscall number 0x40.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateSession :: (server_handle: *Handle, client_handle: *Handle, unk0: u32, unk1: u64) -> Result #foreign libnx;

/**
* @brief Accepts an IPC session.
* @return Result code.
* @note Syscall number 0x41.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcAcceptSession :: (session_handle: *Handle, port_handle: Handle) -> Result #foreign libnx;

/**
* @brief Performs light IPC input/output.
* @return Result code.
* @param[in] handle Server or port handle to act on.
* @note Syscall number 0x42.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcReplyAndReceiveLight :: (handle: Handle) -> Result #foreign libnx;

/**
* @brief Performs IPC input/output.
* @return Result code.
* @note Syscall number 0x43.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcReplyAndReceive :: (index: *s32, handles: *Handle, handleCount: s32, replyTarget: Handle, timeout: u64) -> Result #foreign libnx;

/**
* @brief Performs IPC input/output from an user allocated buffer.
* @return Result code.
* @note Syscall number 0x44.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcReplyAndReceiveWithUserBuffer :: (index: *s32, usrBuffer: *void, size: u64, handles: *Handle, handleCount: s32, replyTarget: Handle, timeout: u64) -> Result #foreign libnx;

/**
* @brief Creates a system event.
* @return Result code.
* @note Syscall number 0x45.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateEvent :: (server_handle: *Handle, client_handle: *Handle) -> Result #foreign libnx;

/**
* @brief Maps an IO Region. [13.0.0+]
* @return Result code.
* @note Syscall number 0x46.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapIoRegion :: (io_region_h: Handle, address: *void, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapIoRegion. [13.0.0+]
* @return Result code.
* @note Syscall number 0x47.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapIoRegion :: (io_region_h: Handle, address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Maps unsafe memory (usable for GPU DMA) for a system module at the desired address. [5.0.0+]
* @return Result code.
* @note Syscall number 0x48.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapPhysicalMemoryUnsafe :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
* @return Result code.
* @note Syscall number 0x49.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapPhysicalMemoryUnsafe :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Sets the system-wide limit for unsafe memory mappable using \ref svcMapPhysicalMemoryUnsafe. [5.0.0+]
* @return Result code.
* @note Syscall number 0x4A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetUnsafeLimit :: (size: u64) -> Result #foreign libnx;

/**
* @brief Creates code memory in the caller's address space [4.0.0+].
* @return Result code.
* @note Syscall number 0x4B.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateCodeMemory :: (code_handle: *Handle, src_addr: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Maps code memory in the caller's address space [4.0.0+].
* @return Result code.
* @note Syscall number 0x4C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcControlCodeMemory :: (code_handle: Handle, op: CodeMapOperation, dst_addr: *void, size: u64, perm: u64) -> Result #foreign libnx;

/**
* @brief Causes the system to enter deep sleep.
* @note Syscall number 0x4D.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSleepSystem :: () -> void #foreign libnx;

/**
* @brief Reads/writes a protected MMIO register.
* @return Result code.
* @note Syscall number 0x4E.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcReadWriteRegister :: (outVal: *u32, regAddr: u64, rwMask: u32, inVal: u32) -> Result #foreign libnx;

/**
* @brief Configures the pause/unpause status of a process.
* @return Result code.
* @note Syscall number 0x4F.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetProcessActivity :: (process: Handle, paused: ProcessActivity) -> Result #foreign libnx;

/**
* @brief Creates a block of shared memory.
* @return Result code.
* @note Syscall number 0x50.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateSharedMemory :: (out: *Handle, size: u64, local_perm: u32, other_perm: u32) -> Result #foreign libnx;

/**
* @brief Maps a block of transfer memory.
* @return Result code.
* @note Syscall number 0x51.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapTransferMemory :: (tmem_handle: Handle, addr: *void, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Unmaps a block of transfer memory.
* @return Result code.
* @note Syscall number 0x52.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapTransferMemory :: (tmem_handle: Handle, addr: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Creates an event and binds it to a specific hardware interrupt.
* @return Result code.
* @note Syscall number 0x53.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateInterruptEvent :: (handle: *Handle, irqNum: u64, flag: u32) -> Result #foreign libnx;

/**
* @brief Queries information about a certain virtual address, including its physical address.
* @return Result code.
* @note Syscall number 0x54.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcQueryPhysicalAddress :: (out: *PhysicalMemoryInfo, virtaddr: u64) -> Result #foreign libnx;

/**
* @brief Returns a virtual address mapped to a given IO range.
* @return Result code.
* @note Syscall number 0x55.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
* @warning Only exists on [10.0.0+]. For older versions use \ref svcLegacyQueryIoMapping.
*/
svcQueryMemoryMapping :: (virtaddr: *u64, out_size: *u64, physaddr: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Returns a virtual address mapped to a given IO range.
* @return Result code.
* @note Syscall number 0x55.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
* @warning Only exists on [1.0.0-9.2.0]. For newer versions use \ref svcQueryMemoryMapping.
*/
svcLegacyQueryIoMapping :: (virtaddr: *u64, physaddr: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Creates a virtual address space for binding device address spaces.
* @return Result code.
* @note Syscall number 0x56.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateDeviceAddressSpace :: (handle: *Handle, dev_addr: u64, dev_size: u64) -> Result #foreign libnx;

/**
* @brief Attaches a device address space to a device.
* @return Result code.
* @note Syscall number 0x57.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcAttachDeviceAddressSpace :: (device: u64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Detaches a device address space from a device.
* @return Result code.
* @note Syscall number 0x58.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcDetachDeviceAddressSpace :: (device: u64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Maps an attached device address space to an userspace address.
* @return Result code.
* @remark The userspace destination address must have the \ref MemState_MapDeviceAllowed bit set.
* @note Syscall number 0x59.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapDeviceAddressSpaceByForce :: (handle: Handle, proc_handle: Handle, map_addr: u64, dev_size: u64, dev_addr: u64, option: u32) -> Result #foreign libnx;

/**
* @brief Maps an attached device address space to an userspace address.
* @return Result code.
* @remark The userspace destination address must have the \ref MemState_MapDeviceAlignedAllowed bit set.
* @note Syscall number 0x5A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapDeviceAddressSpaceAligned :: (handle: Handle, proc_handle: Handle, map_addr: u64, dev_size: u64, dev_addr: u64, option: u32) -> Result #foreign libnx;

/**
* @brief Maps an attached device address space to an userspace address. [1.0.0-12.1.0]
* @return Result code.
* @remark The userspace destination address must have the \ref MemState_MapDeviceAlignedAllowed bit set.
* @note Syscall number 0x5B.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapDeviceAddressSpace :: (out_mapped_size: *u64, handle: Handle, proc_handle: Handle, map_addr: u64, dev_size: u64, dev_addr: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Unmaps an attached device address space from an userspace address.
* @return Result code.
* @note Syscall number 0x5C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapDeviceAddressSpace :: (handle: Handle, proc_handle: Handle, map_addr: u64, map_size: u64, dev_addr: u64) -> Result #foreign libnx;

/**
* @brief Invalidates data cache for a virtual address range within a process.
* @param[in] address Address of region to invalidate.
* @param[in] size Size of region to invalidate.
* @note Syscall number 0x5D.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcInvalidateProcessDataCache :: (process: Handle, address: __uintptr_t, size: u64) -> Result #foreign libnx;

/**
* @brief Stores data cache for a virtual address range within a process.
* @param[in] address Address of region to store.
* @param[in] size Size of region to store.
* @note Syscall number 0x5E.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcStoreProcessDataCache :: (process: Handle, address: __uintptr_t, size: u64) -> Result #foreign libnx;

/**
* @brief Flushes data cache for a virtual address range within a process.
* @param[in] address Address of region to flush.
* @param[in] size Size of region to flush.
* @note Syscall number 0x5F.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcFlushProcessDataCache :: (process: Handle, address: __uintptr_t, size: u64) -> Result #foreign libnx;

/**
* @brief Debugs an active process.
* @return Result code.
* @note Syscall number 0x60.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcDebugActiveProcess :: (debug: *Handle, processID: u64) -> Result #foreign libnx;

/**
* @brief Breaks an active debugging session.
* @return Result code.
* @note Syscall number 0x61.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcBreakDebugProcess :: (debug: Handle) -> Result #foreign libnx;

/**
* @brief Terminates the process of an active debugging session.
* @return Result code.
* @note Syscall number 0x62.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcTerminateDebugProcess :: (debug: Handle) -> Result #foreign libnx;

/**
* @brief Gets an incoming debug event from a debugging session.
* @return Result code.
* @note Syscall number 0x63.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetDebugEvent :: (event_out: *void, debug: Handle) -> Result #foreign libnx;

/**
* @brief Continues a debugging session.
* @return Result code.
* @note Syscall number 0x64.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
* @warning Only exists on [3.0.0+]. For older versions use \ref svcLegacyContinueDebugEvent.
*/
svcContinueDebugEvent :: (debug: Handle, flags: u32, tid_list: *u64, num_tids: u32) -> Result #foreign libnx;

/**
* @brief Continues a debugging session.
* @return Result code.
* @note Syscall number 0x64.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
* @warning Only exists on [1.0.0-2.3.0]. For newer versions use \ref svcContinueDebugEvent.
*/
svcLegacyContinueDebugEvent :: (debug: Handle, flags: u32, threadID: u64) -> Result #foreign libnx;

/**
* @brief Gets the context (dump the registers) of a thread in a debugging session.
* @return Result code.
* @param[out] ctx Output thread context (register dump).
* @param[in] debug Debug handle.
* @param[in] threadID ID of the thread to dump the context of.
* @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
* @note Syscall number 0x67.
* @warning Official kernel will not dump any CPU GPR if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetDebugThreadContext :: (ctx: *ThreadContext, debug: Handle, threadID: u64, flags: u32) -> Result #foreign libnx;

/**
* @brief Gets the context (dump the registers) of a thread in a debugging session.
* @return Result code.
* @param[in] debug Debug handle.
* @param[in] threadID ID of the thread to set the context of.
* @param[in] ctx Input thread context (register dump).
* @param[in] flags Register groups to select, combination of @ref RegisterGroup flags.
* @note Syscall number 0x68.
* @warning Official kernel will return an error if the thread is currently executing a system call (except @ref svcBreak and @ref svcReturnFromException).
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetDebugThreadContext :: (debug: Handle, threadID: u64, ctx: *ThreadContext, flags: u32) -> Result #foreign libnx;

/**
* @brief Retrieves a list of all running processes.
* @return Result code.
* @note Syscall number 0x65.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetProcessList :: (num_out: *s32, pids_out: *u64, max_pids: u32) -> Result #foreign libnx;

/**
* @brief Retrieves a list of all threads for a debug handle (or zero).
* @return Result code.
* @note Syscall number 0x66.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetThreadList :: (num_out: *s32, tids_out: *u64, max_tids: u32, debug: Handle) -> Result #foreign libnx;

/**
* @brief Queries memory information from a process that is being debugged.
* @return Result code.
* @note Syscall number 0x69.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcQueryDebugProcessMemory :: (meminfo_ptr: *MemoryInfo, pageinfo: *u32, debug: Handle, addr: u64) -> Result #foreign libnx;

/**
* @brief Reads memory from a process that is being debugged.
* @return Result code.
* @note Syscall number 0x6A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcReadDebugProcessMemory :: (buffer: *void, debug: Handle, addr: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Writes to memory in a process that is being debugged.
* @return Result code.
* @note Syscall number 0x6B.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcWriteDebugProcessMemory :: (debug: Handle, buffer: *void, addr: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Sets one of the hardware breakpoints.
* @return Result code.
* @note Syscall number 0x6C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetHardwareBreakPoint :: (which: u32, flags: u64, value: u64) -> Result #foreign libnx;

/**
* @brief Gets parameters from a thread in a debugging session.
* @return Result code.
* @note Syscall number 0x6D.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetDebugThreadParam :: (out_64: *u64, out_32: *u32, debug: Handle, threadID: u64, param: DebugThreadParam) -> Result #foreign libnx;

/**
* @brief Retrieves privileged information about the system, or a certain kernel object.
* @param[out] out Variable to which store the information.
* @param[in] id0 First ID of the property to retrieve.
* @param[in] handle Handle of the object to retrieve information from, or \ref INVALID_HANDLE to retrieve information about the system.
* @param[in] id1 Second ID of the property to retrieve.
* @return Result code.
* @remark The full list of property IDs can be found on the <a href="https://switchbrew.org/wiki/SVC#svcGetSystemInfo">switchbrew.org wiki</a>.
* @note Syscall number 0x6F.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetSystemInfo :: (out: *u64, id0: u64, handle: Handle, id1: u64) -> Result #foreign libnx;

/**
* @brief Creates a port.
* @return Result code.
* @note Syscall number 0x70.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreatePort :: (portServer: *Handle, portClient: *Handle, max_sessions: s32, is_light: bool, name: *u8) -> Result #foreign libnx;

/**
* @brief Manages a named port.
* @return Result code.
* @note Syscall number 0x71.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcManageNamedPort :: (portServer: *Handle, name: *u8, maxSessions: s32) -> Result #foreign libnx;

/**
* @brief Manages a named port.
* @return Result code.
* @note Syscall number 0x72.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcConnectToPort :: (session: *Handle, port: Handle) -> Result #foreign libnx;

/**
* @brief Sets the memory permissions for the specified memory with the supplied process handle.
* @param[in] proc Process handle.
* @param[in] addr Address of the memory.
* @param[in] size Size of the memory.
* @param[in] perm Permissions (see \ref Permission).
* @return Result code.
* @remark This returns an error (0xD801) when \p perm is >0x5, hence -WX and RWX are not allowed.
* @note Syscall number 0x73.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetProcessMemoryPermission :: (proc: Handle, addr: u64, size: u64, perm: u32) -> Result #foreign libnx;

/**
* @brief Maps the src address from the supplied process handle into the current process.
* @param[in] dst Address to which map the memory in the current process.
* @param[in] proc Process handle.
* @param[in] src Source mapping address.
* @param[in] size Size of the memory.
* @return Result code.
* @remark This allows mapping code and rodata with RW- permission.
* @note Syscall number 0x74.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapProcessMemory :: (dst: *void, proc: Handle, src: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapProcessMemory.
* @param[in] dst Destination mapping address
* @param[in] proc Process handle.
* @param[in] src Address of the memory in the process.
* @param[in] size Size of the memory.
* @return Result code.
* @remark This allows mapping code and rodata with RW- permission.
* @note Syscall number 0x75.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapProcessMemory :: (dst: *void, proc: Handle, src: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Equivalent to \ref svcQueryMemory, for another process.
* @param[out] meminfo_ptr \ref MemoryInfo structure which will be filled in.
* @param[out] pageinfo Page information which will be filled in.
* @param[in] proc Process handle.
* @param[in] addr Address to query.
* @return Result code.
* @note Syscall number 0x76.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcQueryProcessMemory :: (meminfo_ptr: *MemoryInfo, pageinfo: *u32, proc: Handle, addr: u64) -> Result #foreign libnx;

/**
* @brief Maps normal heap in a certain process as executable code (used when loading NROs).
* @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
* @param[in] dst Destination mapping address.
* @param[in] src Source mapping address.
* @param[in] size Size of the mapping.
* @return Result code.
* @note Syscall number 0x77.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcMapProcessCodeMemory :: (proc: Handle, dst: u64, src: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapProcessCodeMemory.
* @param[in] proc Process handle (cannot be \ref CUR_PROCESS_HANDLE).
* @param[in] dst Destination mapping address.
* @param[in] src Source mapping address.
* @param[in] size Size of the mapping.
* @return Result code.
* @note Syscall number 0x78.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcUnmapProcessCodeMemory :: (proc: Handle, dst: u64, src: u64, size: u64) -> Result #foreign libnx;

/**
* @brief Creates a new process.
* @return Result code.
* @note Syscall number 0x79.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateProcess :: (out: *Handle, proc_info: *void, caps: *u32, cap_num: u64) -> Result #foreign libnx;

/**
* @brief Starts executing a freshly created process.
* @return Result code.
* @note Syscall number 0x7A.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcStartProcess :: (proc: Handle, main_prio: s32, default_cpu: s32, stack_size: u32) -> Result #foreign libnx;

/**
* @brief Terminates a running process.
* @return Result code.
* @note Syscall number 0x7B.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcTerminateProcess :: (proc: Handle) -> Result #foreign libnx;

/**
* @brief Gets a \ref ProcessInfoType for a process.
* @return Result code.
* @note Syscall number 0x7C.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcGetProcessInfo :: (out: *s64, proc: Handle, which: ProcessInfoType) -> Result #foreign libnx;

/**
* @brief Creates a new Resource Limit handle.
* @return Result code.
* @note Syscall number 0x7D.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCreateResourceLimit :: (out: *Handle) -> Result #foreign libnx;

/**
* @brief Sets the value for a \ref LimitableResource for a Resource Limit handle.
* @return Result code.
* @note Syscall number 0x7E.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcSetResourceLimitLimitValue :: (reslimit: Handle, which: LimitableResource, value: u64) -> Result #foreign libnx;

/**
* @brief Calls a secure monitor function (TrustZone, EL3).
* @param regs Arguments to pass to the secure monitor.
* @note Syscall number 0x7F.
* @warning This is a privileged syscall. Use \ref envIsSyscallHinted to check if it is available.
*/
svcCallSecureMonitor :: (regs: *SecmonArgs) -> void #foreign libnx;

/**
* @brief Maps new insecure memory at the desired address. [15.0.0+]
* @return Result code.
* @note Syscall number 0x90.
*/
svcMapInsecurePhysicalMemory :: (address: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Undoes the effects of \ref svcMapInsecureMemory. [15.0.0+]
* @return Result code.
* @note Syscall number 0x91.
*/
svcUnmapInsecurePhysicalMemory :: (address: *void, size: u64) -> Result #foreign libnx;

/// Mutex datatype, defined in newlib.
Mutex :: _LOCK_T;

/// Recursive mutex datatype, defined in newlib.
RMutex :: _LOCK_RECURSIVE_T;

/**
* @brief Locks a mutex.
* @param m Mutex object.
*/
mutexLock :: (m: *Mutex) -> void #foreign libnx;

/**
* @brief Attempts to lock a mutex without waiting.
* @param m Mutex object.
* @return 1 if the mutex has been acquired successfully, and 0 on contention.
*/
mutexTryLock :: (m: *Mutex) -> bool #foreign libnx;

/**
* @brief Unlocks a mutex.
* @param m Mutex object.
*/
mutexUnlock :: (m: *Mutex) -> void #foreign libnx;

/**
* @brief Gets whether the current thread owns the mutex.
* @param m Mutex object.
* @return 1 if the mutex is locked by the current thread, and 0 otherwise.
*/
mutexIsLockedByCurrentThread :: (m: *Mutex) -> bool #foreign libnx;

/**
* @brief Locks a recursive mutex.
* @param m Recursive mutex object.
*/
rmutexLock :: (m: *RMutex) -> void #foreign libnx;

/**
* @brief Attempts to lock a recursive mutex without waiting.
* @param m Recursive mutex object.
* @return 1 if the mutex has been acquired successfully, and 0 on contention.
*/
rmutexTryLock :: (m: *RMutex) -> bool #foreign libnx;

/**
* @brief Unlocks a recursive mutex.
* @param m Recursive mutex object.
*/
rmutexUnlock :: (m: *RMutex) -> void #foreign libnx;

WaitableMethods :: struct {}

WaitableNode :: struct {
    prev: *WaitableNode;
    next: *WaitableNode;
}

Waitable :: struct {
    vt:    *WaitableMethods;
    list:  WaitableNode;
    mutex: Mutex;
}

WaiterType :: enum u32 {
    Handle          :: 0;
    HandleWithClear :: 1;
    Waitable        :: 2;
}

/// Waiter structure, representing any generic waitable synchronization object; both kernel-mode and user-mode.
Waiter :: struct {
    type: WaiterType;

    union {
        handle:   Handle;
        waitable: *Waitable;
    }
}

/**
* @brief Waits for an arbitrary number of generic waitable synchronization objects, optionally with a timeout.
* @param[out] idx_out Variable that will received the index of the signalled object.
* @param[in] objects Array containing \ref Waiter structures.
* @param[in] num_objects Number of objects in the array.
* @param[in] timeout Timeout (in nanoseconds).
* @return Result code.
* @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
*/
waitObjects :: (idx_out: *s32, objects: *Waiter, num_objects: s32, timeout: u64) -> Result #foreign libnx;

/**
* @brief Waits for an arbitrary number of kernel synchronization objects, optionally with a timeout. This function replaces \ref svcWaitSynchronization.
* @param[out] idx_out Variable that will received the index of the signalled object.
* @param[in] handles Array containing handles.
* @param[in] num_handles Number of handles in the array.
* @param[in] timeout Timeout (in nanoseconds).
* @return Result code.
* @note The number of objects must not be greater than \ref MAX_WAIT_OBJECTS. This is a Horizon kernel limitation.
*/
waitHandles :: (idx_out: *s32, handles: *Handle, num_handles: s32, timeout: u64) -> Result #foreign libnx;

/// Transfer memory information structure.
TransferMemory :: struct {
    handle:   Handle; ///< Kernel object handle.
    size:     u64; ///< Size of the transfer memory object.
    perm:     Permission; ///< Permissions of the transfer memory object.
    src_addr: *void; ///< Address of the source backing memory.
    map_addr: *void; ///< Address to which the transfer memory object is mapped.
}

/**
* @brief Creates a transfer memory object.
* @param t Transfer memory information structure that will be filled in.
* @param size Size of the transfer memory object to create.
* @param perm Permissions with which to protect the transfer memory in the local process.
* @return Result code.
*/
tmemCreate :: (t: *TransferMemory, size: u64, perm: Permission) -> Result #foreign libnx;

/**
* @brief Creates a transfer memory object from existing memory.
* @param t Transfer memory information structure that will be filled in.
* @param buf Pointer to a page-aligned buffer.
* @param size Size of the transfer memory object to create.
* @param perm Permissions with which to protect the transfer memory in the local process.
* @return Result code.
*/
tmemCreateFromMemory :: (t: *TransferMemory, buf: *void, size: u64, perm: Permission) -> Result #foreign libnx;

/**
* @brief Loads a transfer memory object coming from a remote process.
* @param t Transfer memory information structure which will be filled in.
* @param handle Handle of the transfer memory object.
* @param size Size of the transfer memory object that is being loaded.
* @param perm Permissions which the transfer memory is expected to have in the process that owns the memory.
* @warning This is a privileged operation; in normal circumstances applications shouldn't use this function.
*/
tmemLoadRemote :: (t: *TransferMemory, handle: Handle, size: u64, perm: Permission) -> void #foreign libnx;

/**
* @brief Maps a transfer memory object.
* @param t Transfer memory information structure.
* @return Result code.
* @warning This is a privileged operation; in normal circumstances applications cannot use this function.
*/
tmemMap :: (t: *TransferMemory) -> Result #foreign libnx;

/**
* @brief Unmaps a transfer memory object.
* @param t Transfer memory information structure.
* @return Result code.
* @warning This is a privileged operation; in normal circumstances applications cannot use this function.
*/
tmemUnmap :: (t: *TransferMemory) -> Result #foreign libnx;

/**
* @brief Closes handle of a transfer memory object.
* @param t Transfer memory information structure.
* @return Result code.
*/
tmemCloseHandle :: (t: *TransferMemory) -> Result #foreign libnx;

/**
* @brief Waits until source backing memory permissions match perm.
* @param t Transfer memory information structure.
* @param perm Permissions which the source backing memory is expected to have before return.
* @return Result code.
*/
tmemWaitForPermission :: (t: *TransferMemory, perm: Permission) -> Result #foreign libnx;

/**
* @brief Frees up resources used by a transfer memory object, unmapping and closing handles, etc.
* @param t Transfer memory information structure.
* @return Result code.
*/
tmemClose :: (t: *TransferMemory) -> Result #foreign libnx;

/// Shared memory information structure.
SharedMemory :: struct {
    handle:   Handle; ///< Kernel object handle.
    size:     u64; ///< Size of the shared memory object.
    perm:     Permission; ///< Permissions.
    map_addr: *void; ///< Address to which the shared memory object is mapped.
}

/**
* @brief Creates a shared memory object.
* @param s Shared memory information structure which will be filled in.
* @param size Size of the shared memory object to create.
* @param local_perm Permissions with which the shared memory object will be mapped in the local process.
* @param remote_perm Permissions with which the shared memory object will be mapped in the remote process (can be Perm_DontCare).
* @return Result code.
* @warning This is a privileged operation; in normal circumstances applications cannot use this function.
*/
shmemCreate :: (s: *SharedMemory, size: u64, local_perm: Permission, remote_perm: Permission) -> Result #foreign libnx;

/**
* @brief Loads a shared memory object coming from a remote process.
* @param s Shared memory information structure which will be filled in.
* @param handle Handle of the shared memory object.
* @param size Size of the shared memory object that is being loaded.
* @param perm Permissions with which the shared memory object will be mapped in the local process.
*/
shmemLoadRemote :: (s: *SharedMemory, handle: Handle, size: u64, perm: Permission) -> void #foreign libnx;

/**
* @brief Maps a shared memory object.
* @param s Shared memory information structure.
* @return Result code.
*/
shmemMap :: (s: *SharedMemory) -> Result #foreign libnx;

/**
* @brief Unmaps a shared memory object.
* @param s Shared memory information structure.
* @return Result code.
*/
shmemUnmap :: (s: *SharedMemory) -> Result #foreign libnx;

/**
* @brief Frees up resources used by a shared memory object, unmapping and closing handles, etc.
* @param s Shared memory information structure.
* @return Result code.
*/
shmemClose :: (s: *SharedMemory) -> Result #foreign libnx;

/// Kernel-mode event structure.
Event :: struct {
    revent:    Handle; ///< Read-only event handle
    wevent:    Handle; ///< Write-only event handle
    autoclear: bool; ///< Autoclear flag
}

/**
* @brief Creates a kernel-mode event.
* @param[out] t Pointer to \ref Event structure.
* @param[in] autoclear Autoclear flag.
* @return Result code.
* @warning This is a privileged operation; in normal circumstances applications shouldn't use this function.
*/
eventCreate :: (t: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief Loads a kernel-mode event obtained from IPC.
* @param[out] t Pointer to \ref Event structure.
* @param[in] handle Read-only event handle.
* @param[in] autoclear Autoclear flag.
*/
eventLoadRemote :: (t: *Event, handle: Handle, autoclear: bool) -> void #foreign libnx;

/**
* @brief Closes a kernel-mode event.
* @param[in] t Pointer to \ref Event structure.
*/
eventClose :: (t: *Event) -> void #foreign libnx;

/**
* @brief Waits on a kernel-mode event.
* @param[in] t Pointer to \ref Event structure.
* @param[in] timeout Timeout in nanoseconds (pass UINT64_MAX to wait indefinitely).
* @return Result code.
*/
eventWait :: (t: *Event, timeout: u64) -> Result #foreign libnx;

/**
* @brief Signals a kernel-mode event.
* @param[in] t Pointer to \ref Event structure.
* @return Result code.
* @note This function only works for events initialized with \ref eventCreate, it doesn't work with events initialized with \ref eventLoadRemote.
* @warning This is a privileged operation; in normal circumstances applications shouldn't use this function.
*/
eventFire :: (t: *Event) -> Result #foreign libnx;

/**
* @brief Clears a kernel-mode event.
* @param[in] t Pointer to \ref Event structure.
* @return Result code.
* @note This function shouldn't be used on autoclear events.
*/
eventClear :: (t: *Event) -> Result #foreign libnx;

/// User-mode light event structure.
LEvent :: struct {
    counter:   u32;
    autoclear: bool;
}

/**
* @brief Waits on a user-mode light event.
* @param[in] le Pointer to \ref LEvent structure.
* @param[in] timeout_ns Timeout in nanoseconds (pass UINT64_MAX to wait indefinitely).
* @return true if wait succeeded, false if wait timed out.
*/
leventWait :: (le: *LEvent, timeout_ns: u64) -> bool #foreign libnx;

/**
* @brief Polls a user-mode light event.
* @param[in] le Pointer to \ref LEvent structure.
* @return true if event is signaled, false otherwise.
*/
leventTryWait :: (le: *LEvent) -> bool #foreign libnx;

/**
* @brief Signals a user-mode light event.
* @param[in] le Pointer to \ref LEvent structure.
*/
leventSignal :: (le: *LEvent) -> void #foreign libnx;

/**
* @brief Clears a user-mode light event.
* @param[in] le Pointer to \ref LEvent structure.
*/
leventClear :: (le: *LEvent) -> void #foreign libnx;

/// User-mode event object.
UEvent :: struct {
    waitable:   Waitable;
    signal:     bool;
    auto_clear: bool;
}

/**
* @brief Creates a user-mode event.
* @param[out] e UEvent object.
* @param[in] auto_clear Whether to automatically clear the event.
* @note It is safe to wait on this event with several threads simultaneously.
* @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
*/
ueventCreate :: (e: *UEvent, auto_clear: bool) -> void #foreign libnx;

/**
* @brief Clears the event signal.
* @param[in] e UEvent object.
*/
ueventClear :: (e: *UEvent) -> void #foreign libnx;

/**
* @brief Signals the event.
* @param[in] e UEvent object.
*/
ueventSignal :: (e: *UEvent) -> void #foreign libnx;

/// Valid types for a user-mode timer.
TimerType :: enum u32 {
    OneShot   :: 0;
    Repeating :: 1;
}

/**
* @brief Creates a user-mode timer.
* @param[out] t UTimer object.
* @param[in] interval Interval (in nanoseconds).
* @param[in] type Type of timer to create (see \ref TimerType).
* @note The timer is stopped when it is created. Use \ref utimerStart to start it.
* @note It is safe to wait on this timer with several threads simultaneously.
* @note If more than one thread is listening on it, at least one thread will get the signal. No other guarantees.
* @note For a repeating timer: If the timer triggers twice before you wait on it, you will only get one signal.
*/
utimerCreate :: (t: *UTimer, interval: u64, type: TimerType) -> void #foreign libnx;

/**
* @brief Starts the timer.
* @param[in] t UTimer object.
*/
utimerStart :: (t: *UTimer) -> void #foreign libnx;

/**
* @brief Stops the timer.
* @param[in] t UTimer object.
*/
utimerStop :: (t: *UTimer) -> void #foreign libnx;

/// Condition variable.
CondVar :: u32;

/**
* @brief Waits on a condition variable with a timeout.
* @param[in] c Condition variable object.
* @param[in] m Mutex object to use inside the condition variable.
* @param[in] timeout Timeout in nanoseconds.
* @return Result code (0xEA01 on timeout).
* @remark On function return, the underlying mutex is acquired.
*/
condvarWaitTimeout :: (c: *CondVar, m: *Mutex, timeout: u64) -> Result #foreign libnx;

/// Read/write lock structure.
RwLock :: struct {
    mutex:               Mutex;
    condvar_reader_wait: CondVar;
    condvar_writer_wait: CondVar;
    read_lock_count:     u32;
    read_waiter_count:   u32;
    write_lock_count:    u32;
    write_waiter_count:  u32;
    write_owner_tag:     u32;
}

/**
* @brief Initializes the read/write lock.
* @param r Read/write lock object.
*/
rwlockInit :: (r: *RwLock) -> void #foreign libnx;

/**
* @brief Locks the read/write lock for reading.
* @param r Read/write lock object.
*/
rwlockReadLock :: (r: *RwLock) -> void #foreign libnx;

/**
* @brief Attempts to lock the read/write lock for reading without waiting.
* @param r Read/write lock object.
* @return 1 if the mutex has been acquired successfully, and 0 on contention.
*/
rwlockTryReadLock :: (r: *RwLock) -> bool #foreign libnx;

/**
* @brief Unlocks the read/write lock for reading.
* @param r Read/write lock object.
*/
rwlockReadUnlock :: (r: *RwLock) -> void #foreign libnx;

/**
* @brief Locks the read/write lock for writing.
* @param r Read/write lock object.
*/
rwlockWriteLock :: (r: *RwLock) -> void #foreign libnx;

/**
* @brief Attempts to lock the read/write lock for writing without waiting.
* @param r Read/write lock object.
* @return 1 if the mutex has been acquired successfully, and 0 on contention.
*/
rwlockTryWriteLock :: (r: *RwLock) -> bool #foreign libnx;

/**
* @brief Unlocks the read/write lock for writing.
* @param r Read/write lock object.
*/
rwlockWriteUnlock :: (r: *RwLock) -> void #foreign libnx;

/**
* @brief Checks if the write lock is held by the current thread.
* @param r Read/write lock object.
* @return 1 if the current hold holds the write lock, and 0 if it does not.
*/
rwlockIsWriteLockHeldByCurrentThread :: (r: *RwLock) -> bool #foreign libnx;

/**
* @brief Checks if the read/write lock is owned by the current thread.
* @param r Read/write lock object.
* @return 1 if the current hold holds the write lock or if it holds read locks acquired
*         while it held the write lock, and 0 if it does not.
*/
rwlockIsOwnedByCurrentThread :: (r: *RwLock) -> bool #foreign libnx;

/// Thread information structure.
Thread :: struct {
    handle:         Handle; ///< Thread handle.
    owns_stack_mem: bool; ///< Whether the stack memory is automatically allocated.
    stack_mem:      *void; ///< Pointer to stack memory.
    stack_mirror:   *void; ///< Pointer to stack memory mirror.
    stack_sz:       u64; ///< Stack size.
    tls_array:      **void;
    next:           *Thread;
    prev_next:      **Thread;
}

/**
* @brief Creates a thread.
* @param t Thread information structure which will be filled in.
* @param entry Entrypoint of the thread.
* @param arg Argument to pass to the entrypoint.
* @param stack_mem Memory to use as backing for stack/tls/reent. Must be page-aligned. NULL argument means to allocate new memory.
* @param stack_sz  If stack_mem is NULL, size to use for stack. If stack_mem is non-NULL, size to use for stack + reent + tls (must be page-aligned).
* @param prio Thread priority (0x00~0x3F); 0x2C is the usual priority of the main thread, 0x3B is a special priority on cores 0..2 that enables preemptive multithreading (0x3F on core 3).
* @param cpuid ID of the core on which to create the thread (0~3); or -2 to use the default core for the current process.
* @return Result code.
*/
threadCreate :: (t: *Thread, entry: ThreadFunc, arg: *void, stack_mem: *void, stack_sz: u64, prio: s32, cpuid: s32) -> Result #foreign libnx;

/**
* @brief Starts the execution of a thread.
* @param t Thread information structure.
* @return Result code.
*/
threadStart :: (t: *Thread) -> Result #foreign libnx;

/**
* @brief Exits the current thread immediately.
*/
threadExit :: () -> void #foreign libnx;

/**
* @brief Waits for a thread to finish executing.
* @param t Thread information structure.
* @return Result code.
*/
threadWaitForExit :: (t: *Thread) -> Result #foreign libnx;

/**
* @brief Frees up resources associated with a thread.
* @param t Thread information structure.
* @return Result code.
*/
threadClose :: (t: *Thread) -> Result #foreign libnx;

/**
* @brief Pauses the execution of a thread.
* @param t Thread information structure.
* @return Result code.
*/
threadPause :: (t: *Thread) -> Result #foreign libnx;

/**
* @brief Resumes the execution of a thread, after having been paused.
* @param t Thread information structure.
* @return Result code.
*/
threadResume :: (t: *Thread) -> Result #foreign libnx;

/**
* @brief Dumps the registers of a thread paused by @ref threadPause (register groups: all).
* @param[out] ctx Output thread context (register dump).
* @param t Thread information structure.
* @return Result code.
* @warning Official kernel will not dump x0..x18 if the thread is currently executing a system call, and prior to 6.0.0 doesn't dump TPIDR_EL0.
*/
threadDumpContext :: (ctx: *ThreadContext, t: *Thread) -> Result #foreign libnx;

/**
* @brief Gets a pointer to the current thread structure.
* @return Thread information structure.
*/
threadGetSelf :: () -> *Thread #foreign libnx;

/**
* @brief Gets the raw handle to the current thread.
* @return The current thread's handle.
*/
threadGetCurHandle :: () -> Handle #foreign libnx;

/**
* @brief Allocates a TLS slot.
* @param destructor Function to run automatically when a thread exits.
* @return TLS slot ID on success, or a negative value on failure.
*/
threadTlsAlloc :: (destructor: #type (unknown0: *void) -> void #c_call) -> s32 #foreign libnx;

/**
* @brief Retrieves the value stored in a TLS slot.
* @param slot_id TLS slot ID.
* @return Value.
*/
threadTlsGet :: (slot_id: s32) -> *void #foreign libnx;

/**
* @brief Stores the specified value into a TLS slot.
* @param slot_id TLS slot ID.
* @param value Value.
*/
threadTlsSet :: (slot_id: s32, value: *void) -> void #foreign libnx;

/**
* @brief Frees a TLS slot.
* @param slot_id TLS slot ID.
*/
threadTlsFree :: (slot_id: s32) -> void #foreign libnx;

/// Semaphore structure.
Semaphore :: struct {
    condvar: CondVar; ///< Condition variable object.
    mutex:   Mutex; ///< Mutex object.
    count:   u64; ///< Internal counter.
}

/**
* @brief Initializes a semaphore and its internal counter.
* @param s Semaphore object.
* @param initial_count initial value for internal counter (typically the # of free resources).
*/
semaphoreInit :: (s: *Semaphore, initial_count: u64) -> void #foreign libnx;

/**
* @brief Increments the Semaphore to allow other threads to continue.
* @param s Semaphore object.
*/
semaphoreSignal :: (s: *Semaphore) -> void #foreign libnx;

/**
* @brief Decrements Semaphore and waits if 0.
* @param s Semaphore object.
*/
semaphoreWait :: (s: *Semaphore) -> void #foreign libnx;

/**
* @brief Attempts to get lock without waiting.
* @param s Semaphore object.
* @return true if no wait and successful lock, false otherwise.
*/
semaphoreTryWait :: (s: *Semaphore) -> bool #foreign libnx;

VirtmemReservation :: struct {}

/// Locks the virtual memory manager mutex.
virtmemLock :: () -> void #foreign libnx;

/// Unlocks the virtual memory manager mutex.
virtmemUnlock :: () -> void #foreign libnx;

/**
* @brief Finds a random slice of free general purpose address space.
* @param size Desired size of the slice (rounded up to page alignment).
* @param guard_size Desired size of the unmapped guard areas surrounding the slice  (rounded up to page alignment).
* @return Pointer to the slice of address space, or NULL on failure.
* @note The virtual memory manager mutex must be held during the find-and-map process (see \ref virtmemLock and \ref virtmemUnlock).
*/
virtmemFindAslr :: (size: u64, guard_size: u64) -> *void #foreign libnx;

/**
* @brief Finds a random slice of free stack address space.
* @param size Desired size of the slice (rounded up to page alignment).
* @param guard_size Desired size of the unmapped guard areas surrounding the slice  (rounded up to page alignment).
* @return Pointer to the slice of address space, or NULL on failure.
* @note The virtual memory manager mutex must be held during the find-and-map process (see \ref virtmemLock and \ref virtmemUnlock).
*/
virtmemFindStack :: (size: u64, guard_size: u64) -> *void #foreign libnx;

/**
* @brief Finds a random slice of free code memory address space.
* @param size Desired size of the slice (rounded up to page alignment).
* @param guard_size Desired size of the unmapped guard areas surrounding the slice  (rounded up to page alignment).
* @return Pointer to the slice of address space, or NULL on failure.
* @note The virtual memory manager mutex must be held during the find-and-map process (see \ref virtmemLock and \ref virtmemUnlock).
*/
virtmemFindCodeMemory :: (size: u64, guard_size: u64) -> *void #foreign libnx;

/**
* @brief Reserves a range of memory address space.
* @param mem Pointer to the address space slice.
* @param size Size of the slice.
* @return Pointer to a reservation object, or NULL on failure.
* @remark This function is intended to be used in lieu of a memory map operation when the memory won't be mapped straight away.
* @note The virtual memory manager mutex must be held during the find-and-reserve process (see \ref virtmemLock and \ref virtmemUnlock).
*/
virtmemAddReservation :: (mem: *void, size: u64) -> *VirtmemReservation #foreign libnx;

/**
* @brief Releases a memory address space reservation.
* @param rv Reservation to release.
* @note The virtual memory manager mutex must be held before calling this function (see \ref virtmemLock and \ref virtmemUnlock).
*/
virtmemRemoveReservation :: (rv: *VirtmemReservation) -> void #foreign libnx;

/**
* @brief Fills a buffer with random data.
* @param buf Pointer to the buffer.
* @param len Size of the buffer in bytes.
*/
randomGet :: (buf: *void, len: u64) -> void #foreign libnx;

/**
* @brief Returns a random 64-bit value.
* @return Random value.
*/
randomGet64 :: () -> u64 #foreign libnx;

/// JIT implementation type.
JitType :: enum u32 {
    SetProcessMemoryPermission :: 0;
    CodeMemory                 :: 1;
}

/// JIT buffer object.
Jit :: struct {
    type:          JitType;
    size:          u64;
    src_addr:      *void;
    rx_addr:       *void;
    rw_addr:       *void;
    is_executable: bool;
    union {
        handle: Handle;
        rv:     *VirtmemReservation;
    }
}

/**
* @brief Creates a JIT buffer.
* @param j JIT buffer.
* @param size Size of the JIT buffer.
* @return Result code.
*/
jitCreate :: (j: *Jit, size: u64) -> Result #foreign libnx;

/**
* @brief Transition a JIT buffer to have writable permission.
* @param j JIT buffer.
* @return Result code.
*/
jitTransitionToWritable :: (j: *Jit) -> Result #foreign libnx;

/**
* @brief Transition a JIT buffer to have executable permission.
* @param j JIT buffer.
* @return Result code.
*/
jitTransitionToExecutable :: (j: *Jit) -> Result #foreign libnx;

/**
* @brief Destroys a JIT buffer.
* @param j JIT buffer.
* @return Result code.
*/
jitClose :: (j: *Jit) -> Result #foreign libnx;

/// Barrier structure.
Barrier :: struct {
    count:   u64; ///< Number of threads to reach the barrier.
    total:   u64; ///< Number of threads to wait on.
    mutex:   Mutex;
    condvar: CondVar;
}

/**
* @brief Initializes a barrier and the number of threads to wait on.
* @param b Barrier object.
* @param thread_count Initial value for the number of threads the barrier must wait for.
*/
barrierInit :: (b: *Barrier, thread_count: u64) -> void #foreign libnx;

/**
* @brief Forces threads to wait until all threads have called barrierWait.
* @param b Barrier object.
*/
barrierWait :: (b: *Barrier) -> void #foreign libnx;

HipcMetadata :: struct {
    type:             u32;
    num_send_statics: u32;
    num_send_buffers: u32;
    num_recv_buffers: u32;
    num_exch_buffers: u32;
    num_data_words:   u32;
    num_recv_statics: u32; // also accepts HIPC_AUTO_RECV_STATIC
    send_pid:         u32;
    num_copy_handles: u32;
    num_move_handles: u32;
}

HipcRequest :: struct {
    send_statics: *HipcStaticDescriptor;
    send_buffers: *HipcBufferDescriptor;
    recv_buffers: *HipcBufferDescriptor;
    exch_buffers: *HipcBufferDescriptor;
    data_words:   *u32;
    recv_list:    *HipcRecvListEntry;
    copy_handles: *Handle;
    move_handles: *Handle;
}

HipcParsedRequest :: struct {
    meta: HipcMetadata;
    data: HipcRequest;
    pid:  u64;
}

HipcResponse :: struct {
    pid:              u64;
    num_statics:      u32;
    num_data_words:   u32;
    num_copy_handles: u32;
    num_move_handles: u32;
    statics:          *HipcStaticDescriptor;
    data_words:       *u32;
    copy_handles:     *Handle;
    move_handles:     *Handle;
}

HipcBufferMode :: enum u32 {
    Normal    :: 0;
    NonSecure :: 1;
    Invalid   :: 2;
    NonDevice :: 3;
}

CmifCommandType :: enum u32 {
    Invalid            :: 0;
    LegacyRequest      :: 1;
    Close              :: 2;
    LegacyControl      :: 3;
    Request            :: 4;
    Control            :: 5;
    RequestWithContext :: 6;
    ControlWithContext :: 7;
}

CmifDomainRequestType :: enum u32 {
    Invalid     :: 0;
    SendMessage :: 1;
    Close       :: 2;
}

CmifInHeader :: struct {
    magic:      u32;
    version:    u32;
    command_id: u32;
    token:      u32;
}

CmifOutHeader :: struct {
    magic:   u32;
    version: u32;
    result:  Result;
    token:   u32;
}

CmifDomainInHeader :: struct {
    type:           u8;
    num_in_objects: u8;
    data_size:      u16;
    object_id:      u32;
    padding:        u32;
    token:          u32;
}

CmifDomainOutHeader :: struct {
    num_out_objects: u32;
    padding:         [3] u32;
}

CmifRequestFormat :: struct {
    object_id:              u32;
    request_id:             u32;
    _context:               u32;
    data_size:              u32;
    server_pointer_size:    u32;
    num_in_auto_buffers:    u32;
    num_out_auto_buffers:   u32;
    num_in_buffers:         u32;
    num_out_buffers:        u32;
    num_inout_buffers:      u32;
    num_in_pointers:        u32;
    num_out_pointers:       u32;
    num_out_fixed_pointers: u32;
    num_objects:            u32;
    num_handles:            u32;
    send_pid:               u32;
}

CmifRequest :: struct {
    hipc:                HipcRequest;
    data:                *void;
    out_pointer_sizes:   *u16;
    objects:             *u32;
    server_pointer_size: u32;
    cur_in_ptr_id:       u32;
}

CmifResponse :: struct {
    data:         *void;
    objects:      *u32;
    copy_handles: *Handle;
    move_handles: *Handle;
}

/// Service object structure
Service :: struct {
    session:             Handle;
    own_handle:          u32;
    object_id:           u32;
    pointer_buffer_size: u16;
}

SfBufferAttr :: enum u32 {
    In                             :: 1;
    Out                            :: 2;
    HipcMapAlias                   :: 4;
    HipcPointer                    :: 8;
    FixedSize                      :: 16;
    HipcAutoSelect                 :: 32;
    HipcMapTransferAllowsNonSecure :: 64;
    HipcMapTransferAllowsNonDevice :: 128;
}

SfBufferAttrs :: struct {
    attr0: u32;
    attr1: u32;
    attr2: u32;
    attr3: u32;
    attr4: u32;
    attr5: u32;
    attr6: u32;
    attr7: u32;
}

SfBuffer :: struct {
    ptr:  *void;
    size: u64;
}

SfOutHandleAttr :: enum u32 {
    None     :: 0;
    HipcCopy :: 1;
    HipcMove :: 2;
}

SfOutHandleAttrs :: struct {
    attr0: SfOutHandleAttr;
    attr1: SfOutHandleAttr;
    attr2: SfOutHandleAttr;
    attr3: SfOutHandleAttr;
    attr4: SfOutHandleAttr;
    attr5: SfOutHandleAttr;
    attr6: SfOutHandleAttr;
    attr7: SfOutHandleAttr;
}

SfDispatchParams :: struct {
    target_session:   Handle;
    _context:         u32;

    buffer_attrs:     SfBufferAttrs;
    buffers:          [8] SfBuffer;

    in_send_pid:      bool;

    in_num_objects:   u32;
    in_objects:       [8] *Service;

    in_num_handles:   u32;
    in_handles:       [8] Handle;

    out_num_objects:  u32;
    out_objects:      *Service;

    out_handle_attrs: SfOutHandleAttrs;
    out_handles:      *Handle;
}

SessionMgr :: struct {
    sessions:     [16] Handle;
    num_sessions: u32;
    free_mask:    u32;
    mutex:        Mutex;
    condvar:      CondVar;
    num_waiters:  u32;
}

sessionmgrCreate :: (mgr: *SessionMgr, root_session: Handle, num_sessions: u32) -> Result #foreign libnx;
sessionmgrClose :: (mgr: *SessionMgr) -> void #foreign libnx;
sessionmgrAttachClient :: (mgr: *SessionMgr) -> s32 #foreign libnx;
sessionmgrDetachClient :: (mgr: *SessionMgr, slot: s32) -> void #foreign libnx;

TipcCommandType :: enum u32 {
    Close :: 15;
}

/// tipc Service object structure
TipcService :: struct {
    session: Handle;
}

TipcDispatchParams :: struct {
    buffer_attrs:     SfBufferAttrs;
    buffers:          [8] SfBuffer;

    in_send_pid:      bool;

    in_num_handles:   u32;
    in_handles:       [8] Handle;

    out_num_objects:  u32;
    out_objects:      *TipcService;

    out_handle_attrs: SfOutHandleAttrs;
    out_handles:      *Handle;
}

TipcRequestFormat :: struct {
    request_id:        u32;
    data_size:         u32;
    num_in_buffers:    u32;
    num_out_buffers:   u32;
    num_inout_buffers: u32;
    num_handles:       u32;
    send_pid:          u32;
}

/// Structure representing a service name (null terminated, remaining characters set to zero).
SmServiceName :: struct {
    name: [8] u8;
}

/**
* @brief Initializes SM.
* @return Result code.
* @note This function is already called in the default application startup code (before main() is called).
*/
smInitialize :: () -> Result #foreign libnx;

/**
* @brief Uninitializes SM.
* @return Result code.
* @note This function is already handled in the default application exit code (after main() returns).
*/
smExit :: () -> void #foreign libnx;

/**
* @brief Requests a service from SM, allowing overrides.
* @param[out] service_out Service structure which will be filled in.
* @param[in] name Name of the service to request.
* @return Result code.
*/
smGetServiceWrapper :: (service_out: *Service, name: SmServiceName) -> Result #foreign libnx;

/**
* @brief Requests a service from SM, as an IPC session handle directly
* @param[out] handle_out Variable containing IPC session handle.
* @param[in] name Name of the service to request.
* @return Result code.
*/
smGetServiceOriginal :: (handle_out: *Handle, name: SmServiceName) -> Result #foreign libnx;

/**
* @brief Retrieves an overriden service in the homebrew environment.
* @param[in] name Name of the service to request.
* @return IPC session handle.
*/
smGetServiceOverride :: (name: SmServiceName) -> Handle #foreign libnx;

/**
* @brief Creates and registers a new service within SM.
* @param[out] handle_out Variable containing IPC port handle.
* @param[in] name Name of the service.
* @param[in] is_light "Is light"
* @param[in] max_sessions Maximum number of concurrent sessions that the service will accept.
* @return Result code.
*/
smRegisterService :: (handle_out: *Handle, name: SmServiceName, is_light: bool, max_sessions: s32) -> Result #foreign libnx;

/// Same as \ref smRegisterService, but always using cmif serialization.
smRegisterServiceCmif :: (handle_out: *Handle, name: SmServiceName, is_light: bool, max_sessions: s32) -> Result #foreign libnx;

/// Same as \ref smRegisterService, but always using tipc serialization.
smRegisterServiceTipc :: (handle_out: *Handle, name: SmServiceName, is_light: bool, max_sessions: s32) -> Result #foreign libnx;

/**
* @brief Unregisters a previously registered service in SM.
* @param[in] name Name of the service.
* @return Result code.
*/
smUnregisterService :: (name: SmServiceName) -> Result #foreign libnx;

/// Same as \ref smUnregisterService, but always using cmif serialization.
smUnregisterServiceCmif :: (name: SmServiceName) -> Result #foreign libnx;

/// Same as \ref smUnregisterService, but always using tipc serialization.
smUnregisterServiceTipc :: (name: SmServiceName) -> Result #foreign libnx;

/**
* @brief Detaches the current SM session.
* @note After this function is called, the rest of the SM API cannot be used.
* @note Only available on [11.0.0-11.0.1], or Atmosphère.
*/
smDetachClient :: () -> Result #foreign libnx;

/// Same as \ref smDetachClient, but always using cmif serialization.
smDetachClientCmif :: () -> Result #foreign libnx;

/// Same as \ref smDetachClient, but always using tipc serialization.
smDetachClientTipc :: () -> Result #foreign libnx;

/**
* @brief Gets the Service session used to communicate with SM.
* @return Pointer to service session used to communicate with SM.
*/
smGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets the TipcService session used to communicate with SM.
* @return Pointer to tipc service session used to communicate with SM.
* @note Only available on [12.0.0+], or Atmosphère.
*/
smGetServiceSessionTipc :: () -> *TipcService #foreign libnx;

/**
* @brief Overrides a service with a custom IPC service handle.
* @param[in] name Name of the service.
* @param[in] handle IPC session handle.
*/
smAddOverrideHandle :: (name: SmServiceName, handle: Handle) -> void #foreign libnx;

/// Initialize sm:m.
smManagerInitialize :: () -> Result #foreign libnx;

/// Exit sm:m.
smManagerExit :: () -> void #foreign libnx;

smManagerRegisterProcess :: (pid: u64, acid_sac: *void, acid_sac_size: u64, aci0_sac: *void, aci0_sac_size: u64) -> Result #foreign libnx;
smManagerUnregisterProcess :: (pid: u64) -> Result #foreign libnx;

/// Initialize sm:m exclusively for tipc (requires <12.0.0 and non-Atmosphere).
smManagerCmifInitialize :: () -> Result #foreign libnx;

/// Exit sm:m exclusively for tipc (requires <12.0.0 and non-Atmosphere).
smManagerCmifExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual sm:m service session (requires <12.0.0 and non-Atmosphere).
smManagerCmifGetServiceSession :: () -> *Service #foreign libnx;

smManagerCmifRegisterProcess :: (pid: u64, acid_sac: *void, acid_sac_size: u64, aci0_sac: *void, aci0_sac_size: u64) -> Result #foreign libnx;
smManagerCmifUnregisterProcess :: (pid: u64) -> Result #foreign libnx;

/// Initialize sm:m exclusively for tipc (requires 12.0.0+ or Atmosphere).
smManagerTipcInitialize :: () -> Result #foreign libnx;

/// Exit sm:m exclusively for tipc (requires 12.0.0+ or Atmosphere).
smManagerTipcExit :: () -> void #foreign libnx;

/// Gets the TipcService object for the actual sm:m service session (requires 12.0.0+ or Atmosphere).
smManagerTipcGetServiceSession :: () -> *TipcService #foreign libnx;

smManagerTipcRegisterProcess :: (pid: u64, acid_sac: *void, acid_sac_size: u64, aci0_sac: *void, aci0_sac_size: u64) -> Result #foreign libnx;
smManagerTipcUnregisterProcess :: (pid: u64) -> Result #foreign libnx;

/// Context for SHA256 operations.
Sha256Context :: struct {
    intermediate_hash: [8] u32;
    buffer:            [64] u8;
    bits_consumed:     u64;
    num_buffered:      u64;
    finalized:         bool;
}

/// Initialize a SHA256 context.
sha256ContextCreate :: (out: *Sha256Context) -> void #foreign libnx;

/// Updates SHA256 context with data to hash
sha256ContextUpdate :: (ctx: *Sha256Context, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output hash, finalizes the context.
sha256ContextGetHash :: (ctx: *Sha256Context, dst: *void) -> void #foreign libnx;

/// Simple all-in-one SHA256 calculator.
sha256CalculateHash :: (dst: *void, src: *void, size: u64) -> void #foreign libnx;

/// StorageId
NcmStorageId :: enum u32 {
    None          :: 0;
    Host          :: 1;
    GameCard      :: 2;
    BuiltInSystem :: 3;
    BuiltInUser   :: 4;
    SdCard        :: 5;
    _Any          :: 6;
}

/// ContentType
NcmContentType :: enum u32 {
    Meta             :: 0;
    Program          :: 1;
    Data             :: 2;
    Control          :: 3;
    HtmlDocument     :: 4;
    LegalInformation :: 5;
    DeltaFragment    :: 6;
}

/// ContentMetaType
NcmContentMetaType :: enum u32 {
    Unknown              :: 0;
    SystemProgram        :: 1;
    SystemData           :: 2;
    SystemUpdate         :: 3;
    BootImagePackage     :: 4;
    BootImagePackageSafe :: 5;
    Application          :: 128;
    Patch                :: 129;
    AddOnContent         :: 130;
    Delta                :: 131;
    DataPatch            :: 132;
}

/// ContentMetaAttribute
NcmContentMetaAttribute :: enum u32 {
    None                :: 0;
    IncludesExFatDriver :: 1;
    Rebootless          :: 2;
    Compacted           :: 4;
}

/// ContentInstallType
NcmContentInstallType :: enum u32 {
    Full         :: 0;
    FragmentOnly :: 1;
    Unknown      :: 7;
}

/// ContentMetaPlatform
NcmContentMetaPlatform :: enum u32 {
    Nx :: 0;
}

/// ContentId
NcmContentId :: struct {
    c: [16] u8; ///< Id
}

/// PlaceHolderId
NcmPlaceHolderId :: struct {
    uuid: Uuid; ///< UUID
}

/// ContentMetaKey
NcmContentMetaKey :: struct {
    id:           u64; ///< Id.
    version:      u32; ///< Version.
    type:         u8; ///< \ref NcmContentMetaType
    install_type: u8; ///< \ref NcmContentInstallType
    padding:      [2] u8; ///< Padding.
}

/// ApplicationContentMetaKey
NcmApplicationContentMetaKey :: struct {
    key:            NcmContentMetaKey; ///< \ref NcmContentMetaKey
    application_id: u64; ///< ApplicationId.
}

/// ContentInfo
NcmContentInfo :: struct {
    content_id:   NcmContentId; ///< \ref NcmContentId
    size_low:     u32; ///< Content size (low).
    size_high:    u8; ///< Content size (high).
    attr:         u8; ///< Content attributes.
    content_type: u8; ///< \ref NcmContentType.
    id_offset:    u8; ///< Offset of this content. Unused by most applications.
}

/// PackagedContentInfo
NcmPackagedContentInfo :: struct {
    hash: [32] u8;
    info: NcmContentInfo;
}

/// ContentMetaInfo
NcmContentMetaInfo :: struct {
    id:      u64; ///< Id.
    version: u32; ///< Version.
    type:    u8; ///< \ref NcmContentMetaType
    attr:    u8; ///< \ref NcmContentMetaAttribute
    padding: [2] u8; ///< Padding.
}

/// ContentMetaHeader
NcmContentMetaHeader :: struct {
    extended_header_size: u16; ///< Size of optional struct that comes after this one.
    content_count:        u16; ///< Number of NcmContentInfos after the extra bytes.
    content_meta_count:   u16; ///< Number of NcmContentMetaInfos that come after the NcmContentInfos.
    attributes:           u8; ///< Usually None (0).
    storage_id:           u8; ///< Usually None (0).
}

/// ApplicationMetaExtendedHeader
NcmApplicationMetaExtendedHeader :: struct {
    patch_id:                     u64; ///< PatchId of this application's patch.
    required_system_version:      u32; ///< Firmware version required by this application.
    required_application_version: u32; ///< [9.0.0+] Owner application version required by this application. Previously padding.
}

/// PatchMetaExtendedHeader
NcmPatchMetaExtendedHeader :: struct {
    application_id:          u64; ///< ApplicationId of this patch's corresponding application.
    required_system_version: u32; ///< Firmware version required by this patch.
    extended_data_size:      u32; ///< Size of the extended data following the NcmContentInfos.
    reserved:                [8] u8; ///< Unused.
}

/// AddOnContentMetaExtendedHeader [15.0.0+]
NcmAddOnContentMetaExtendedHeader :: struct {
    application_id:               u64; ///< ApplicationId of this add-on-content's corresponding application.
    required_application_version: u32; ///< Version of the application required by this add-on-content.
    content_accessibilities:      u8; ///< Content accessibilities.
    padding:                      [3] u8; ///< Padding.
    data_patch_id:                u64; ///< DataPatchId of this add-on-content's corresponding data patch.
}

/// LegacyAddOnContentMetaExtendedHeader [1.0.0-14.1.2]
NcmLegacyAddOnContentMetaExtendedHeader :: struct {
    application_id:               u64; ///< ApplicationId of this add-on-content's corresponding application.
    required_application_version: u32; ///< Version of the application required by this add-on-content.
    padding:                      u32; ///< Padding.
}

/// DataPatchMetaExtendedHeader
NcmDataPatchMetaExtendedHeader :: struct {
    data_id:                      u64; ///< DataId of this data patch's corresponding add-on-content.
    application_id:               u64; ///< ApplicationId of this data patch's add-on-content's corresponding application.
    required_application_version: u32; ///< Version of the application required by this data patch.
    extended_data_size:           u32; ///< Size of the extended data following the NcmContentInfos.
    padding:                      u64; ///< Padding.
}

/// SystemUpdateMetaExtendedHeader
NcmSystemUpdateMetaExtendedHeader :: struct {
    extended_data_size: u32; ///< Size of the extended data after NcmContentInfos and NcmContentMetaInfos.
}

/// ProgramLocation
NcmProgramLocation :: struct {
    program_id: u64; ///< ProgramId
    storageID:  u8; ///< \ref NcmStorageId
    pad:        [7] u8; ///< Padding
}

AccountServiceType :: enum u32 {
    Application   :: 0;
    System        :: 1;
    Administrator :: 2;
}

/// Profile
AccountProfile :: struct {
    s: Service; ///< IProfile
}

/// Account UserId.
AccountUid :: struct {
    uid: [2] u64; ///< UserId. All-zero is invalid / Uid not set. See also \ref accountUidIsValid.
}

/// UserData
AccountUserData :: struct {
    unk_x0:                u32; ///< Unknown.
    iconID:                u32; ///< Icon ID. 0 = Mii, the rest are character icon IDs.
    iconBackgroundColorID: u8; ///< Profile icon background color ID
    unk_x9:                [7] u8; ///< Unknown.
    miiID:                 [16] u8; ///< Some ID related to the Mii? All zeros when a character icon is used.
    unk_x20:               [96] u8; ///< Usually zeros?
}

/// ProfileBase
AccountProfileBase :: struct {
    uid:               AccountUid; ///< \ref AccountUid
    lastEditTimestamp: u64; ///< POSIX UTC timestamp, for the last account edit.
    nickname:          [32] u8; ///< UTF-8 Nickname.
}

/// NetworkServiceAccountId
AccountNetworkServiceAccountId :: struct {
    id: u64; ///< Id.
}

/// Initialize account.
accountInitialize :: (service_type: AccountServiceType) -> Result #foreign libnx;

/// Exit account.
accountExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual account service session.
accountGetServiceSession :: () -> *Service #foreign libnx;

/// Get the total number of user profiles.
accountGetUserCount :: (user_count: *s32) -> Result #foreign libnx;

/**
* @brief Get a list of all userIds. The returned list will never be larger than ACC_USER_LIST_SIZE.
* @param uids Pointer to array of userIds.
* @param max_uids Maximum number of userIds to return.
* @param actual_total The actual total number of userIds found.
*/
accountListAllUsers :: (uids: *AccountUid, max_uids: s32, actual_total: *s32) -> Result #foreign libnx;

/// Get the userId for the last opened user.
accountGetLastOpenedUser :: (uid: *AccountUid) -> Result #foreign libnx;

/// Get an AccountProfile for the specified userId.
accountGetProfile :: (out: *AccountProfile, uid: AccountUid) -> Result #foreign libnx;

/// IsUserRegistrationRequestPermitted
accountIsUserRegistrationRequestPermitted :: (out: *bool) -> Result #foreign libnx;

/// TrySelectUserWithoutInteraction
accountTrySelectUserWithoutInteraction :: (uid: *AccountUid, is_network_service_account_required: bool) -> Result #foreign libnx;

/// Close the AccountProfile.
accountProfileClose :: (profile: *AccountProfile) -> void #foreign libnx;

/// Get \ref AccountUserData and \ref AccountProfileBase for the specified profile, userdata is optional (can be NULL).
accountProfileGet :: (profile: *AccountProfile, userdata: *AccountUserData, profilebase: *AccountProfileBase) -> Result #foreign libnx;

/// Get the icon image size.
accountProfileGetImageSize :: (profile: *AccountProfile, image_size: *u32) -> Result #foreign libnx;

/// Load the JPEG profile icon, valid for both Miis and character icons. The output image_size is the same as the one from \ref accountProfileGetImageSize.
accountProfileLoadImage :: (profile: *AccountProfile, buf: *void, len: u64, image_size: *u32) -> Result #foreign libnx;

/// Gets the userId which was selected by the profile-selector applet (if any), prior to launching the currently running Application.
/// This gets the cached PreselectedUser loaded during accountInitialize, when PreselectedUser is available.
accountGetPreselectedUser :: (uid: *AccountUid) -> Result #foreign libnx;

FsRightsId :: struct {
    c: [16] u8;
}

FsFileSystem :: struct {
    s: Service;
}

FsFile :: struct {
    s: Service;
}

FsDir :: struct {
    s: Service;
}

FsStorage :: struct {
    s: Service;
}

FsSaveDataInfoReader :: struct {
    s: Service;
}

FsEventNotifier :: struct {
    s: Service;
}

FsDeviceOperator :: struct {
    s: Service;
}

/// Directory entry.
FsDirectoryEntry :: struct {
    name:      [769] u8; ///< Entry name.
    pad:       [3] u8;
    type:      s8; ///< See FsDirEntryType.
    pad2:      [3] u8; ///< ?
    file_size: s64; ///< File size.
}

/// SaveDataAttribute
FsSaveDataAttribute :: struct {
    application_id:      u64; ///< ApplicationId of the savedata to access when accessing other programs' savedata via SaveData, otherwise FS_SAVEDATA_CURRENT_APPLICATIONID.
    uid:                 AccountUid; ///< \ref AccountUid for the user-specific savedata to access, otherwise 0 for common savedata.
    system_save_data_id: u64; ///< SystemSaveDataId, 0 for ::FsSaveDataType_Account.
    save_data_type:      u8; ///< \ref FsSaveDataType
    save_data_rank:      u8; ///< \ref FsSaveDataRank
    save_data_index:     u16; ///< SaveDataIndex
    pad_x24:             u32; ///< Padding.
    unk_x28:             u64; ///< 0 for ::FsSaveDataType_System/::FsSaveDataType_Account.
    unk_x30:             u64; ///< 0 for ::FsSaveDataType_System/::FsSaveDataType_Account.
    unk_x38:             u64; ///< 0 for ::FsSaveDataType_System/::FsSaveDataType_Account.
}

/// SaveDataExtraData
FsSaveDataExtraData :: struct {
    attr:         FsSaveDataAttribute; ///< \ref FsSaveDataAttribute
    owner_id:     u64; ///< ProgramId of the owner of this save data. 0 for ::FsSaveDataType_System.
    timestamp:    u64; ///< POSIX timestamp.
    flags:        u32; ///< \ref FsSaveDataFlags
    unk_x54:      u32; ///< Normally 0. Possibly unused?
    data_size:    s64; ///< Usable save data size.
    journal_size: s64; ///< Journal size of the save data.
    commit_id:    u64; ///< Id of the latest commit.
    unused:       [400] u8; ///< Uninitialized.
}

/// SaveDataMetaInfo
FsSaveDataMetaInfo :: struct {
    size:     u32;
    type:     u8; ///< \ref FsSaveDataMetaType
    reserved: [11] u8;
}

/// SaveDataCreationInfo
FsSaveDataCreationInfo :: struct {
    save_data_size:     s64; ///< Size of the save data.
    journal_size:       s64; ///< Journal size of the save data.
    available_size:     u64; ///< AvailableSize
    owner_id:           u64; ///< ProgramId of the owner of this save data. 0 for ::FsSaveDataType_System.
    flags:              u32; ///< \ref FsSaveDataFlags
    save_data_space_id: u8; ///< \ref FsSaveDataSpaceId
    unk:                u8; ///< 0 for ::FsSaveDataType_System.
    padding:            [26] u8; ///< Uninitialized for ::FsSaveDataType_System.
}

/// SaveDataInfo
FsSaveDataInfo :: struct {
    save_data_id:        u64; ///< SaveDataId
    save_data_space_id:  u8; ///< \ref FsSaveDataSpaceId
    save_data_type:      u8; ///< \ref FsSaveDataType
    pad:                 [6] u8; ///< Padding.
    uid:                 AccountUid; ///< FsSave::userID
    system_save_data_id: u64; ///< FsSaveDataAttribute::system_save_data_id
    application_id:      u64; ///< ApplicationId for ::FsSaveDataType_Account.
    size:                u64; ///< Raw saveimage size.
    save_data_index:     u16; ///< SaveDataIndex
    save_data_rank:      u8; ///< \ref FsSaveDataRank
    unk_x3b:             [37] u8; ///< Unknown. Usually zeros?
}

/// SaveDataFilter
FsSaveDataFilter :: struct {
    filter_by_application_id:      bool; ///< Filter by \ref FsSaveDataAttribute::application_id
    filter_by_save_data_type:      bool; ///< Filter by \ref FsSaveDataAttribute::save_data_type
    filter_by_user_id:             bool; ///< Filter by \ref FsSaveDataAttribute::uid
    filter_by_system_save_data_id: bool; ///< Filter by \ref FsSaveDataAttribute::system_save_data_id
    filter_by_index:               bool; ///< Filter by \ref FsSaveDataAttribute::save_data_index
    save_data_rank:                u8; ///< \ref FsSaveDataRank
    padding:                       [2] u8; ///< Padding
    attr:                          FsSaveDataAttribute; ///< \ref FsSaveDataAttribute
}

FsTimeStampRaw :: struct {
    created:  u64; ///< POSIX timestamp.
    modified: u64; ///< POSIX timestamp.
    accessed: u64; ///< POSIX timestamp.
    is_valid: u8; ///< 0x1 when the timestamps are set.
    padding:  [7] u8;
}

/// This is nn::fssystem::ArchiveMacKey. Used by \ref setsysGetThemeKey and \ref setsysSetThemeKey. Does not appear to be in use elsewhere.
FsArchiveMacKey :: struct {
    key: [16] u8;
}

/// Returned by fsFsGetEntryType.
FsDirEntryType :: enum u32 {
    Dir  :: 0;
    File :: 1;
}

/// For use with fsFsOpenFile.
FsOpenMode :: enum u32 {
    Read   :: 1;
    Write  :: 2;
    Append :: 4;
}

/// For use with fsFsCreateFile.
FsCreateOption :: enum u32 {
    BigFile :: 1;
}

/// For use with fsFsOpenDirectory.
FsDirOpenMode :: enum u32 {
    ReadDirs   :: 1;
    ReadFiles  :: 2;
    NoFileSize :: 2147483648;
}

/// For use with fsFileRead.
FsReadOption :: enum u32 {
    None :: 0;
}

/// For use with fsFileWrite.
FsWriteOption :: enum u32 {
    None  :: 0;
    Flush :: 1;
}

FsContentStorageId :: enum u32 {
    System  :: 0;
    User    :: 1;
    SdCard  :: 2;
    System0 :: 3;
}

FsCustomStorageId :: enum u32 {
    System :: 0;
    SdCard :: 1;
}

/// ImageDirectoryId
FsImageDirectoryId :: enum u32 {
    Nand :: 0;
    Sd   :: 1;
}

/// SaveDataSpaceId
FsSaveDataSpaceId :: enum s32 {
    System       :: 0;
    User         :: 1;
    SdSystem     :: 2;
    Temporary    :: 3;
    SdUser       :: 4;
    ProperSystem :: 100;
    SafeMode     :: 101;

    All          :: -1;
}

/// SaveDataType
FsSaveDataType :: enum u32 {
    System     :: 0;
    Account    :: 1;
    Bcat       :: 2;
    Device     :: 3;
    Temporary  :: 4;
    Cache      :: 5;
    SystemBcat :: 6;
}

/// SaveDataRank
FsSaveDataRank :: enum u32 {
    Primary   :: 0;
    Secondary :: 1;
}

/// SaveDataFlags
FsSaveDataFlags :: enum u32 {
    KeepAfterResettingSystemSaveData                    :: 1;
    KeepAfterRefurbishment                              :: 2;
    KeepAfterResettingSystemSaveDataWithoutUserSaveData :: 4;
    NeedsSecureDelete                                   :: 8;
}

/// SaveDataMetaType
FsSaveDataMetaType :: enum u32 {
    None             :: 0;
    Thumbnail        :: 1;
    ExtensionContext :: 2;
}

FsGameCardAttribute :: enum u32 {
    AutoBootFlag                         :: 1;
    HistoryEraseFlag                     :: 2;
    RepairToolFlag                       :: 4;
    DifferentRegionCupToTerraDeviceFlag  :: 8;
    DifferentRegionCupToGlobalDeviceFlag :: 16;
}

FsGameCardPartition :: enum u32 {
    Update :: 0;
    Normal :: 1;
    Secure :: 2;
    Logo   :: 3;
}

FsGameCardHandle :: struct {
    value: u32;
}

FsGameCardUpdatePartitionInfo :: struct {
    version: u32;
    pad:     [4] u8;
    id:      u64;
}

FsRangeInfo :: struct {
    aes_ctr_key_type:     u32; ///< Contains bitflags describing how data is AES encrypted.
    speed_emulation_type: u32; ///< Contains bitflags describing how data is emulated.
    reserved:             [14] u32;
}

FsOperationId :: enum u32 {
    Clear           :: 0;
    ClearSignature  :: 1;
    InvalidateCache :: 2;
    QueryRange      :: 3;
}

/// BisPartitionId
FsBisPartitionId :: enum u32 {
    BootPartition1Root              :: 0;

    BootPartition2Root              :: 10;

    UserDataRoot                    :: 20;
    BootConfigAndPackage2Part1      :: 21;
    BootConfigAndPackage2Part2      :: 22;
    BootConfigAndPackage2Part3      :: 23;
    BootConfigAndPackage2Part4      :: 24;
    BootConfigAndPackage2Part5      :: 25;
    BootConfigAndPackage2Part6      :: 26;
    CalibrationBinary               :: 27;
    CalibrationFile                 :: 28;
    SafeMode                        :: 29;
    User                            :: 30;
    System                          :: 31;
    SystemProperEncryption          :: 32;
    SystemProperPartition           :: 33;
    SignedSystemPartitionOnSafeMode :: 34;
    DeviceTreeBlob                  :: 35;
    System0                         :: 36;
}

/// FileSystemType
FsFileSystemType :: enum u32 {
    Logo               :: 2;
    ContentControl     :: 3;
    ContentManual      :: 4;
    ContentMeta        :: 5;
    ContentData        :: 6;
    ApplicationPackage :: 7;
    RegisteredUpdate   :: 8;
}

/// FileSystemQueryId
FsFileSystemQueryId :: enum u32 {
    SetConcatenationFileAttribute        :: 0;
    IsValidSignedSystemPartitionOnSdCard :: 2;
}

/// FsPriority
FsPriority :: enum u32 {
    Normal     :: 0;
    Realtime   :: 1;
    Low        :: 2;
    Background :: 3;
}

/// FsContentAttributes
FsContentAttributes :: enum u32 {
    None :: 0;
    All  :: 15;
}

/// For use with fsOpenHostFileSystemWithOption
FsMountHostOption :: enum u32 {
    Flag_None                :: 0;
    Flag_PseudoCaseSensitive :: 1;
}

/// FsStorageErrorInfo
FsStorageErrorInfo :: struct {
    num_activation_failures:          u32;
    num_activation_error_corrections: u32;
    num_read_write_failures:          u32;
    num_read_write_error_corrections: u32;
}

/// FatFatError
FatFatError :: struct {
    error:       s32;
    extra_error: s32;
    drive_id:    s32;
    name:        [16] u8;
    reserved:    [4] u8;
}

/// FatFatReportInfo1
FatFatReportInfo1 :: struct {
    open_file_peak_count:      u16;
    open_directory_peak_count: u16;
}

/// FatFatReportInfo2
FatFatReportInfo2 :: struct {
    open_unique_file_entry_peak_count:      u16;
    open_unique_directory_entry_peak_count: u16;
}

/// FatFatSafeInfo
FatFatSafeInfo :: struct {
    result:            u32;
    error_number:      u32;
    safe_error_number: u32;
}

/// FsFileSystemProxyErrorInfo
FsFileSystemProxyErrorInfo :: struct {
    rom_fs_remount_for_data_corruption_count:              u32;
    rom_fs_unrecoverable_data_corruption_by_remount_count: u32;
    fat_fs_error:                                          FatFatError;
    rom_fs_recovered_by_invalidate_cache_count:            u32;
    save_data_index_count:                                 u32;
    bis_system_fat_report_info_1:                          FatFatReportInfo1;
    bis_user_fat_report_info_1:                            FatFatReportInfo1;
    sd_card_fat_report_info_1:                             FatFatReportInfo1;
    bis_system_fat_report_info_2:                          FatFatReportInfo2;
    bis_user_fat_report_info_2:                            FatFatReportInfo2;
    sd_card_fat_report_info_2:                             FatFatReportInfo2;
    rom_fs_deep_retry_start_count:                         u32;
    rom_fs_unrecoverable_by_game_card_access_failed_count: u32;
    bis_system_fat_safe_info:                              FatFatSafeInfo;
    bis_user_fat_safe_info:                                FatFatSafeInfo;

    reserved:                                              [24] u8;
}

/// FsMemoryReportInfo
FsMemoryReportInfo :: struct {
    pooled_buffer_peak_free_size:                                u64;
    pooled_buffer_retried_count:                                 u64;
    pooled_buffer_reduce_allocation_count:                       u64;
    buffer_manager_peak_free_size:                               u64;
    buffer_manager_retried_count:                                u64;
    exp_heap_peak_free_size:                                     u64;
    buffer_pool_peak_free_size:                                  u64;
    patrol_read_allocate_buffer_success_count:                   u64;
    patrol_read_allocate_buffer_failure_count:                   u64;
    buffer_manager_peak_total_allocatable_size:                  u64;
    buffer_pool_max_allocate_size:                               u64;
    pooled_buffer_failed_ideal_allocation_count_on_async_access: u64;

    reserved:                                                    [32] u8;
}

/// FsGameCardErrorReportInfo
FsGameCardErrorReportInfo :: struct {
    game_card_crc_error_num:          u16;
    reserved1:                        u16;
    asic_crc_error_num:               u16;
    reserved2:                        u16;
    refresh_num:                      u16;
    reserved3:                        u16;
    retry_limit_out_num:              u16;
    timeout_retry_num:                u16;
    asic_reinitialize_failure_detail: u16;
    insertion_count:                  u16;
    removal_count:                    u16;
    asic_reinitialize_num:            u16;
    initialize_count:                 u32;
    asic_reinitialize_failure_num:    u16;
    awaken_failure_num:               u16;
    reserved4:                        u16;
    refresh_succeeded_count:          u16;
    last_read_error_page_address:     u32;
    last_read_error_page_count:       u32;
    awaken_count:                     u32;
    read_count_from_insert:           u32;
    read_count_from_awaken:           u32;
    reserved5:                        [8] u8;
}

/// Initialize fsp-srv. Used automatically during app startup.
fsInitialize :: () -> Result #foreign libnx;

/// Exit fsp-srv. Used automatically during app exit.
fsExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual fsp-srv service session.
fsGetServiceSession :: () -> *Service #foreign libnx;

/// [5.0.0+] Configures the \ref FsPriority of all filesystem commands issued within the current thread.
fsSetPriority :: (prio: FsPriority) -> void #foreign libnx;

/// Mount requested filesystem type from content file
fsOpenFileSystem :: (out: *FsFileSystem, fsType: FsFileSystemType, contentPath: *u8) -> Result #foreign libnx;
fsOpenDataFileSystemByCurrentProcess :: (out: *FsFileSystem) -> Result #foreign libnx;
fsOpenFileSystemWithPatch :: (out: *FsFileSystem, id: u64, fsType: FsFileSystemType) -> Result #foreign libnx;
fsOpenFileSystemWithId :: (out: *FsFileSystem, id: u64, fsType: FsFileSystemType, contentPath: *u8, attr: FsContentAttributes) -> Result #foreign libnx;
fsOpenDataFileSystemByProgramId :: (out: *FsFileSystem, program_id: u64) -> Result #foreign libnx;
fsOpenBisFileSystem :: (out: *FsFileSystem, partitionId: FsBisPartitionId, _string: *u8) -> Result #foreign libnx;
fsOpenBisStorage :: (out: *FsStorage, partitionId: FsBisPartitionId) -> Result #foreign libnx;

/// Do not call this directly, see fs_dev.h.
fsOpenSdCardFileSystem :: (out: *FsFileSystem) -> Result #foreign libnx;

fsOpenHostFileSystem :: (out: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsOpenHostFileSystemWithOption :: (out: *FsFileSystem, path: *u8, flags: u32) -> Result #foreign libnx;

fsDeleteSaveDataFileSystem :: (application_id: u64) -> Result #foreign libnx;
fsCreateSaveDataFileSystem :: (attr: *FsSaveDataAttribute, creation_info: *FsSaveDataCreationInfo, meta: *FsSaveDataMetaInfo) -> Result #foreign libnx;
fsCreateSaveDataFileSystemBySystemSaveDataId :: (attr: *FsSaveDataAttribute, creation_info: *FsSaveDataCreationInfo) -> Result #foreign libnx;
fsDeleteSaveDataFileSystemBySaveDataSpaceId :: (save_data_space_id: FsSaveDataSpaceId, saveID: u64) -> Result #foreign libnx;
fsDeleteSaveDataFileSystemBySaveDataAttribute :: (save_data_space_id: FsSaveDataSpaceId, attr: *FsSaveDataAttribute) -> Result #foreign libnx;

fsIsExFatSupported :: (out: *bool) -> Result #foreign libnx;

fsOpenGameCardFileSystem :: (out: *FsFileSystem, handle: *FsGameCardHandle, partition: FsGameCardPartition) -> Result #foreign libnx;

fsExtendSaveDataFileSystem :: (save_data_space_id: FsSaveDataSpaceId, saveID: u64, dataSize: s64, journalSize: s64) -> Result #foreign libnx;

fsOpenSaveDataFileSystem :: (out: *FsFileSystem, save_data_space_id: FsSaveDataSpaceId, attr: *FsSaveDataAttribute) -> Result #foreign libnx;
fsOpenSaveDataFileSystemBySystemSaveDataId :: (out: *FsFileSystem, save_data_space_id: FsSaveDataSpaceId, attr: *FsSaveDataAttribute) -> Result #foreign libnx;
fsOpenReadOnlySaveDataFileSystem :: (out: *FsFileSystem, save_data_space_id: FsSaveDataSpaceId, attr: *FsSaveDataAttribute) -> Result #foreign libnx;

fsReadSaveDataFileSystemExtraDataBySaveDataSpaceId :: (buf: *void, len: u64, save_data_space_id: FsSaveDataSpaceId, saveID: u64) -> Result #foreign libnx;
fsReadSaveDataFileSystemExtraData :: (buf: *void, len: u64, saveID: u64) -> Result #foreign libnx;
fsWriteSaveDataFileSystemExtraData :: (buf: *void, len: u64, save_data_space_id: FsSaveDataSpaceId, saveID: u64) -> Result #foreign libnx;

fsOpenSaveDataInfoReader :: (out: *FsSaveDataInfoReader, save_data_space_id: FsSaveDataSpaceId) -> Result #foreign libnx;

fsOpenSaveDataInfoReaderWithFilter :: (out: *FsSaveDataInfoReader, save_data_space_id: FsSaveDataSpaceId, save_data_filter: *FsSaveDataFilter) -> Result #foreign libnx;

fsOpenImageDirectoryFileSystem :: (out: *FsFileSystem, image_directory_id: FsImageDirectoryId) -> Result #foreign libnx;
fsOpenContentStorageFileSystem :: (out: *FsFileSystem, content_storage_id: FsContentStorageId) -> Result #foreign libnx;
fsOpenCustomStorageFileSystem :: (out: *FsFileSystem, custom_storage_id: FsCustomStorageId) -> Result #foreign libnx;

fsOpenDataStorageByCurrentProcess :: (out: *FsStorage) -> Result #foreign libnx;
fsOpenDataStorageByProgramId :: (out: *FsStorage, program_id: u64) -> Result #foreign libnx;
/// <[3.0.0+]
fsOpenDataStorageByDataId :: (out: *FsStorage, dataId: u64, storageId: NcmStorageId) -> Result #foreign libnx;
fsOpenPatchDataStorageByCurrentProcess :: (out: *FsStorage) -> Result #foreign libnx;

fsOpenDeviceOperator :: (out: *FsDeviceOperator) -> Result #foreign libnx;
fsOpenSdCardDetectionEventNotifier :: (out: *FsEventNotifier) -> Result #foreign libnx;

fsIsSignedSystemPartitionOnSdCardValid :: (out: *bool) -> Result #foreign libnx;

fsGetProgramId :: (out: *u64, path: *u8, attr: FsContentAttributes) -> Result #foreign libnx;

/// Retrieves the rights id corresponding to the content path. Only available on [2.0.0-15.0.1].
fsGetRightsIdByPath :: (path: *u8, out_rights_id: *FsRightsId) -> Result #foreign libnx;

/// Retrieves the rights id and key generation corresponding to the content path. Only available on [3.0.0+], attr is ignored before [16.0.0].
fsGetRightsIdAndKeyGenerationByPath :: (path: *u8, attr: FsContentAttributes, out_key_generation: *u8, out_rights_id: *FsRightsId) -> Result #foreign libnx;

fsDisableAutoSaveDataCreation :: () -> Result #foreign libnx;

fsSetGlobalAccessLogMode :: (mode: u32) -> Result #foreign libnx;
fsGetGlobalAccessLogMode :: (out_mode: *u32) -> Result #foreign libnx;
fsOutputAccessLogToSdCard :: (log: *u8, size: u64) -> Result #foreign libnx;

fsGetAndClearErrorInfo :: (out: *FsFileSystemProxyErrorInfo) -> Result #foreign libnx;

fsGetAndClearMemoryReportInfo :: (out: *FsMemoryReportInfo) -> Result #foreign libnx;

/// Only available on [7.0.0+].
fsGetProgramIndexForAccessLog :: (out_program_index: *u32, out_program_count: *u32) -> Result #foreign libnx;

// Wrapper(s) for fsCreateSaveDataFileSystem.
fsCreate_TemporaryStorage :: (application_id: u64, owner_id: u64, size: s64, flags: u32) -> Result #foreign libnx;

// Wrapper(s) for fsCreateSaveDataFileSystemBySystemSaveDataId.
fsCreate_SystemSaveDataWithOwner :: (save_data_space_id: FsSaveDataSpaceId, system_save_data_id: u64, uid: AccountUid, owner_id: u64, size: s64, journal_size: s64, flags: u32) -> Result #foreign libnx;
fsCreate_SystemSaveData :: (save_data_space_id: FsSaveDataSpaceId, system_save_data_id: u64, size: s64, journal_size: s64, flags: u32) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystem.
/// See \ref FsSaveDataAttribute for application_id and uid.
fsOpen_SaveData :: (out: *FsFileSystem, application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Wrapper for fsOpenReadOnlySaveDataFileSystem.
/// Only available on [2.0.0+].
/// See \ref FsSaveDataAttribute for application_id and uid.
fsOpen_SaveDataReadOnly :: (out: *FsFileSystem, application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystem, for opening BcatSaveData.
fsOpen_BcatSaveData :: (out: *FsFileSystem, application_id: u64) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystem, for opening DeviceSaveData.
/// See \ref FsSaveDataAttribute for application_id.
fsOpen_DeviceSaveData :: (out: *FsFileSystem, application_id: u64) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystem, for opening TemporaryStorage.
/// Only available on [3.0.0+].
fsOpen_TemporaryStorage :: (out: *FsFileSystem) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystem, for opening CacheStorage.
/// Only available on [3.0.0+].
/// See \ref FsSaveDataAttribute for application_id.
fsOpen_CacheStorage :: (out: *FsFileSystem, application_id: u64, save_data_index: u16) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystemBySystemSaveDataId, for opening SystemSaveData.
/// WARNING: You can brick when writing to SystemSaveData, if the data is corrupted etc.
fsOpen_SystemSaveData :: (out: *FsFileSystem, save_data_space_id: FsSaveDataSpaceId, system_save_data_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Wrapper for fsOpenSaveDataFileSystemBySystemSaveDataId, for opening SystemBcatSaveData.
/// Only available on [4.0.0+].
fsOpen_SystemBcatSaveData :: (out: *FsFileSystem, system_save_data_id: u64) -> Result #foreign libnx;

// IFileSystem
fsFsCreateFile :: (fs: *FsFileSystem, path: *u8, size: s64, option: u32) -> Result #foreign libnx;
fsFsDeleteFile :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsFsCreateDirectory :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsFsDeleteDirectory :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsFsDeleteDirectoryRecursively :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsFsRenameFile :: (fs: *FsFileSystem, cur_path: *u8, new_path: *u8) -> Result #foreign libnx;
fsFsRenameDirectory :: (fs: *FsFileSystem, cur_path: *u8, new_path: *u8) -> Result #foreign libnx;
fsFsGetEntryType :: (fs: *FsFileSystem, path: *u8, out: *FsDirEntryType) -> Result #foreign libnx;
fsFsOpenFile :: (fs: *FsFileSystem, path: *u8, mode: u32, out: *FsFile) -> Result #foreign libnx;
fsFsOpenDirectory :: (fs: *FsFileSystem, path: *u8, mode: u32, out: *FsDir) -> Result #foreign libnx;
fsFsCommit :: (fs: *FsFileSystem) -> Result #foreign libnx;
fsFsGetFreeSpace :: (fs: *FsFileSystem, path: *u8, out: *s64) -> Result #foreign libnx;
fsFsGetTotalSpace :: (fs: *FsFileSystem, path: *u8, out: *s64) -> Result #foreign libnx;
fsFsGetFileTimeStampRaw :: (fs: *FsFileSystem, path: *u8, out: *FsTimeStampRaw) -> Result #foreign libnx;
fsFsCleanDirectoryRecursively :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;
fsFsQueryEntry :: (fs: *FsFileSystem, out: *void, out_size: u64, in: *void, in_size: u64, path: *u8, query_id: FsFileSystemQueryId) -> Result #foreign libnx;
fsFsClose :: (fs: *FsFileSystem) -> void #foreign libnx;

/// Uses \ref fsFsQueryEntry to set the archive bit on the specified absolute directory path.
/// This will cause HOS to treat the directory as if it were a file containing the directory's concatenated contents.
fsFsSetConcatenationFileAttribute :: (fs: *FsFileSystem, path: *u8) -> Result #foreign libnx;

/// Wrapper for fsFsQueryEntry with FsFileSystemQueryId_IsValidSignedSystemPartitionOnSdCard.
/// Only available on [8.0.0+].
fsFsIsValidSignedSystemPartitionOnSdCard :: (fs: *FsFileSystem, out: *bool) -> Result #foreign libnx;

// IFile
fsFileRead :: (f: *FsFile, off: s64, buf: *void, read_size: u64, option: u32, bytes_read: *u64) -> Result #foreign libnx;
fsFileWrite :: (f: *FsFile, off: s64, buf: *void, write_size: u64, option: u32) -> Result #foreign libnx;
fsFileFlush :: (f: *FsFile) -> Result #foreign libnx;
fsFileSetSize :: (f: *FsFile, sz: s64) -> Result #foreign libnx;
fsFileGetSize :: (f: *FsFile, out: *s64) -> Result #foreign libnx;
fsFileOperateRange :: (f: *FsFile, op_id: FsOperationId, off: s64, len: s64, out: *FsRangeInfo) -> Result #foreign libnx;
fsFileClose :: (f: *FsFile) -> void #foreign libnx;

// IDirectory
fsDirRead :: (d: *FsDir, total_entries: *s64, max_entries: u64, buf: *FsDirectoryEntry) -> Result #foreign libnx;
fsDirGetEntryCount :: (d: *FsDir, count: *s64) -> Result #foreign libnx;
fsDirClose :: (d: *FsDir) -> void #foreign libnx;

// IStorage
fsStorageRead :: (s: *FsStorage, off: s64, buf: *void, read_size: u64) -> Result #foreign libnx;
fsStorageWrite :: (s: *FsStorage, off: s64, buf: *void, write_size: u64) -> Result #foreign libnx;
fsStorageFlush :: (s: *FsStorage) -> Result #foreign libnx;
fsStorageSetSize :: (s: *FsStorage, sz: s64) -> Result #foreign libnx;
fsStorageGetSize :: (s: *FsStorage, out: *s64) -> Result #foreign libnx;
fsStorageOperateRange :: (s: *FsStorage, op_id: FsOperationId, off: s64, len: s64, out: *FsRangeInfo) -> Result #foreign libnx;
fsStorageClose :: (s: *FsStorage) -> void #foreign libnx;

/// Read FsSaveDataInfo data into the buf array.
fsSaveDataInfoReaderRead :: (s: *FsSaveDataInfoReader, buf: *FsSaveDataInfo, max_entries: u64, total_entries: *s64) -> Result #foreign libnx;
fsSaveDataInfoReaderClose :: (s: *FsSaveDataInfoReader) -> void #foreign libnx;

// IEventNotifier
fsEventNotifierGetEventHandle :: (e: *FsEventNotifier, out: *Event, autoclear: bool) -> Result #foreign libnx;
fsEventNotifierClose :: (e: *FsEventNotifier) -> void #foreign libnx;

// IDeviceOperator
fsDeviceOperatorIsSdCardInserted :: (d: *FsDeviceOperator, out: *bool) -> Result #foreign libnx;
fsDeviceOperatorGetSdCardSpeedMode :: (d: *FsDeviceOperator, out: *s64) -> Result #foreign libnx;
fsDeviceOperatorGetSdCardCid :: (d: *FsDeviceOperator, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorGetSdCardUserAreaSize :: (d: *FsDeviceOperator, out: *s64) -> Result #foreign libnx;
fsDeviceOperatorGetSdCardProtectedAreaSize :: (d: *FsDeviceOperator, out: *s64) -> Result #foreign libnx;
fsDeviceOperatorGetAndClearSdCardErrorInfo :: (d: *FsDeviceOperator, out: *FsStorageErrorInfo, out_log_size: *s64, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorGetMmcCid :: (d: *FsDeviceOperator, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorGetMmcSpeedMode :: (d: *FsDeviceOperator, out: *s64) -> Result #foreign libnx;
fsDeviceOperatorGetMmcPatrolCount :: (d: *FsDeviceOperator, out: *u32) -> Result #foreign libnx;
fsDeviceOperatorGetAndClearMmcErrorInfo :: (d: *FsDeviceOperator, out: *FsStorageErrorInfo, out_log_size: *s64, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorGetMmcExtendedCsd :: (d: *FsDeviceOperator, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorIsGameCardInserted :: (d: *FsDeviceOperator, out: *bool) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardHandle :: (d: *FsDeviceOperator, out: *FsGameCardHandle) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardUpdatePartitionInfo :: (d: *FsDeviceOperator, handle: *FsGameCardHandle, out: *FsGameCardUpdatePartitionInfo) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardAttribute :: (d: *FsDeviceOperator, handle: *FsGameCardHandle, out: *u8) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardIdSet :: (d: *FsDeviceOperator, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardErrorReportInfo :: (d: *FsDeviceOperator, out: *FsGameCardErrorReportInfo) -> Result #foreign libnx;
fsDeviceOperatorGetGameCardDeviceId :: (d: *FsDeviceOperator, dst: *void, dst_size: u64, size: s64) -> Result #foreign libnx;
fsDeviceOperatorClose :: (d: *FsDeviceOperator) -> void #foreign libnx;

FsCodeInfo :: struct {
    signature: [256] u8;
    hash:      [32] u8;
    is_signed: bool;
    reserved:  [3] u8;
}

/// Initialize fsp-ldr.
fsldrInitialize :: () -> Result #foreign libnx;

/// Exit fsp-ldr.
fsldrExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual fsp-ldr service session.
fsldrGetServiceSession :: () -> *Service #foreign libnx;

fsldrOpenCodeFileSystem :: (out_code_info: *FsCodeInfo, tid: u64, path: *u8, attr: FsContentAttributes, out: *FsFileSystem) -> Result #foreign libnx;
fsldrIsArchivedProgram :: (pid: u64, out: *bool) -> Result #foreign libnx;

/// Initialize fsp-pr.
fsprInitialize :: () -> Result #foreign libnx;

/// Exit fsp-pr.
fsprExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual fsp-pr service session.
fsprGetServiceSession :: () -> *Service #foreign libnx;

fsprRegisterProgram :: (pid: u64, tid: u64, sid: NcmStorageId, fs_access_header: *void, fah_size: u64, fs_access_control: *void, fac_size: u64) -> Result #foreign libnx;
fsprUnregisterProgram :: (pid: u64) -> Result #foreign libnx;
fsprSetCurrentProcess :: () -> Result #foreign libnx;
fsprSetEnabledProgramVerification :: (enabled: bool) -> Result #foreign libnx;

/// PerformanceMode
ApmPerformanceMode :: enum s32 {
    Invalid :: -1;
    Normal  :: 0;
    Boost   :: 1;
}

/// CpuBoostMode. With \ref appletSetCpuBoostMode, only values 0/1 are available. This allows using higher clock rates.
ApmCpuBoostMode :: enum u32 {
    Normal   :: 0;
    FastLoad :: 1;
    Type2    :: 2;
}

/// Initialize apm. Used automatically by \ref appletInitialize with AppletType_Application.
apmInitialize :: () -> Result #foreign libnx;

/// Exit apm. Used automatically by \ref appletExit with AppletType_Application.
apmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual apm service session.
apmGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for ISession.
apmGetServiceSession_Session :: () -> *Service #foreign libnx;

/**
* @brief Gets the current ApmPerformanceMode.
* @param[out] out_performanceMode ApmPerformanceMode
*/
apmGetPerformanceMode :: (out_performanceMode: *ApmPerformanceMode) -> Result #foreign libnx;

/**
* @brief Sets the PerformanceConfiguration for the specified PerformanceMode.
* @param[in] PerformanceMode \ref ApmPerformanceMode
* @param[in] PerformanceConfiguration PerformanceConfiguration
*/
apmSetPerformanceConfiguration :: (PerformanceMode: ApmPerformanceMode, PerformanceConfiguration: u32) -> Result #foreign libnx;

/**
* @brief Gets the PerformanceConfiguration for the specified PerformanceMode.
* @param[in] PerformanceMode \ref ApmPerformanceMode
* @param[out] PerformanceConfiguration PerformanceConfiguration
*/
apmGetPerformanceConfiguration :: (PerformanceMode: ApmPerformanceMode, PerformanceConfiguration: *u32) -> Result #foreign libnx;

/// PlayEventType
PdmPlayEventType :: enum u32 {
    Applet              :: 0;
    Account             :: 1;
    PowerStateChange    :: 2;
    OperationModeChange :: 3;
    Initialize          :: 4;
}

/// AppletEventType
PdmAppletEventType :: enum u32 {
    Launch      :: 0;
    Exit        :: 1;
    InFocus     :: 2;
    OutOfFocus  :: 3;
    OutOfFocus4 :: 4;
    Exit5       :: 5;
    Exit6       :: 6;
}

/// PlayLogPolicy
PdmPlayLogPolicy :: enum u32 {
    All      :: 0;
    LogOnly  :: 1;
    None     :: 2;
    Unknown3 :: 3;
}

/// AppletEventV1. AppletEvent for [1.0.0-15.0.1], converted to \ref PdmAppletEvent when needed.
/// Timestamp format, converted from PosixTime: total minutes since epoch UTC 1999/12/31 00:00:00.
/// See \ref pdmPlayTimestampToPosix.
PdmAppletEventV1 :: struct {
    program_id:        u64; ///< ProgramId.
    entry_index:       u32; ///< Entry index.
    timestamp_user:    u32; ///< See PdmPlayEvent::timestamp_user, with the above timestamp format.
    timestamp_network: u32; ///< See PdmPlayEvent::timestamp_network, with the above timestamp format.
    event_type:        u8; ///< \ref PdmAppletEventType
    pad:               [3] u8; ///< Padding.
}

/// AppletEvent. AppletEvent for [16.0.0+], converted from \ref PdmAppletEventV1 on [1.0.0-15.0.1].
PdmAppletEvent :: struct {
    program_id:        u64; ///< ProgramId.
    entry_index:       u32; ///< Entry index.
    pad:               u32; ///< Padding
    timestamp_user:    u64; ///< See PdmPlayEvent::timestamp_user.
    timestamp_network: u64; ///< See PdmPlayEvent::timestamp_network.
    event_type:        u8; ///< \ref PdmAppletEventType
    pad2:              [7] u8; ///< Padding.
}

/// PlayStatisticsV1. PlayStatistics for [1.0.0-15.0.1], converted to \ref PdmPlayStatistics when needed.
PdmPlayStatisticsV1 :: struct {
    program_id:              u64; ///< ProgramId.

    first_entry_index:       u32; ///< Entry index for the first time the program was played.
    first_timestamp_user:    u32; ///< See PdmAppletEventV1::timestamp_user. This is for the first time the program was played.
    first_timestamp_network: u32; ///< See PdmAppletEventV1::timestamp_network. This is for the first time the program was played.

    last_entry_index:        u32; ///< Entry index for the last time the program was played.
    last_timestamp_user:     u32; ///< See PdmAppletEventV1::timestamp_user. This is for the last time the program was played.
    last_timestamp_network:  u32; ///< See PdmAppletEventV1::timestamp_network. This is for the last time the program was played.

    playtime_minutes:        u32; ///< Total play-time in minutes.
    total_launches:          u32; ///< Total times the program was launched.
}

/// PlayStatistics. PlayStatistics for [16.0.0+], converted from \ref PdmPlayStatisticsV1 on [1.0.0-15.0.1].
PdmPlayStatistics :: struct {
    program_id:              u64; ///< ProgramId.

    first_entry_index:       u32; ///< Entry index for the first time the program was played.
    pad:                     u32; ///< Padding
    first_timestamp_user:    u64; ///< See PdmAppletEvent::timestamp_user. This is for the first time the program was played, in PosixTime.
    first_timestamp_network: u64; ///< See PdmAppletEvent::timestamp_network. This is for the first time the program was played, in PosixTime.

    last_entry_index:        u32; ///< Entry index for the last time the program was played.
    pad2:                    u32; ///< Padding
    last_timestamp_user:     u64; ///< See PdmAppletEvent::timestamp_user. This is for the last time the program was played, in PosixTime.
    last_timestamp_network:  u64; ///< See PdmAppletEvent::timestamp_network. This is for the last time the program was played, in PosixTime.

    playtime:                u64; ///< Total play-time in nanoseconds.
    total_launches:          u32; ///< Total times the program was launched.
    pad3:                    u32; ///< Padding
}

/// LastPlayTime.
/// This contains data from the last time the application was played.
PdmLastPlayTime :: struct {
    application_id:      u64; ///< ApplicationId.
    timestamp_user:      u32; ///< See PdmAppletEventV1::timestamp_user.
    timestamp_network:   u32; ///< See PdmAppletEventV1::timestamp_network.
    last_played_minutes: u32; ///< Total minutes since the application was last played.
    flag:                u8; ///< Flag indicating whether the above field is set.
    pad:                 [3] u8; ///< Padding.
}

/// PlayEvent.
/// This is the raw entry struct directly read from FS, without any entry filtering.
PdmPlayEvent :: struct {
    event_data:        union {
        applet:                struct {
            program_id: [2] u32; ///< ProgramId.

            unk_x8:     union {
                application: struct {
                    version: u32; ///< Application version.
                }; ///< For AppletId == ::AppletId_application.

                applet:      struct {
                    flag: u8; ///< Set to 0x1 by pdm:ntfy cmd8, indicating that the below field is set to an input param.
                    mode: u8; ///< Input value from pdm:ntfy cmd8, see \ref LibAppletMode.
                    pad:  [2] u8; ///< Padding.
                }; ///< For AppletId != ::AppletId_application.

                data:        u32;
            };

            applet_id:  u8; ///< \ref AppletId
            storage_id: u8; ///< \ref NcmStorageId
            log_policy: u8; ///< \ref PdmPlayLogPolicy
            event_type: u8; ///< \ref PdmAppletEventType
            unused:     [12] u8; ///< Unused.
        };

        account:               struct {
            uid:            [4] u32; ///< userId.
            application_id: [2] u32; ///< ApplicationId, see below.
            type:           u8; ///< 0-1 to be listed by \ref pdmqryQueryAccountEvent, or 2 to include the above ApplicationId.
        };

        power_state_change:    struct {
            value:  u8; ///< Input value from the pdm:ntfy command.
            unused: [27] u8; ///< Unused.
        };

        operation_mode_change: struct {
            value:  u8; ///< Input value from the pdm:ntfy command.
            unused: [27] u8; ///< Unused.
        };

        data:                  [28] u8;
    }; ///< ProgramId/ApplicationId/userId stored within here have the u32 low/high swapped in each u64.

    play_event_type:   u8; ///< \ref PdmPlayEventType. Controls which struct in the above event_data is used. ::PdmPlayEventType_Initialize doesn't use event_data.
    pad:               [3] u8; ///< Padding.

    timestamp_user:    u64; ///< PosixTime timestamp from StandardUserSystemClock.
    timestamp_network: u64; ///< PosixTime timestamp from StandardNetworkSystemClock.
    timestamp_steady:  u64; ///< Timestamp in seconds derived from StandardSteadyClock.
}

/// AccountEventV3. AccountEvent for [3.0.0-9.2.0], converted to \ref PdmAccountEvent when needed.
PdmAccountEventV3 :: struct {
    uid:               AccountUid; ///< \ref AccountUid
    entry_index:       u32; ///< Entry index.
    pad:               [4] u8; ///< Padding.
    timestamp_user:    u64; ///< See PdmPlayEvent::timestamp_user.
    timestamp_network: u64; ///< See PdmPlayEvent::timestamp_network.
    timestamp_steady:  u64; ///< See PdmPlayEvent::timestamp_steady.
    type:              u8; ///< See PdmPlayEvent::event_data::account::type.
    pad2:              [7] u8; ///< Padding.
}

/// AccountEventV10. AccountEvent for [10.0.0-15.0.1], converted to \ref PdmAccountEvent when needed.
PdmAccountEventV10 :: struct {
    uid:               AccountUid; ///< \ref AccountUid
    program_id:        u64; ///< ProgramId
    entry_index:       u32; ///< Entry index.
    pad:               [4] u8; ///< Padding.
    timestamp_user:    u64; ///< See PdmPlayEvent::timestamp_user.
    timestamp_network: u64; ///< See PdmPlayEvent::timestamp_network.
    timestamp_steady:  u64; ///< See PdmPlayEvent::timestamp_steady.
    type:              u8; ///< See PdmPlayEvent::event_data::account::type.
    pad2:              [7] u8; ///< Padding.
}

/// AccountEvent. AccountEvent for [16.0.0+], converted from the older structs when needed.
PdmAccountEvent :: struct {
    uid:               AccountUid; ///< \ref AccountUid
    program_id:        u64; ///< [10.0.0+] ProgramId
    entry_index:       u32; ///< Entry index.
    pad:               [4] u8; ///< Padding.
    timestamp_user:    u64; ///< See PdmPlayEvent::timestamp_user.
    timestamp_network: u64; ///< See PdmPlayEvent::timestamp_network.
    type:              u8; ///< See PdmPlayEvent::event_data::account::type.
    pad2:              [7] u8; ///< Padding.
}

/// AccountPlayEvent.
/// This is the raw entry struct directly read from FS, without any entry filtering. This is separate from \ref PdmPlayEvent.
PdmAccountPlayEvent :: struct {
    unk_x0:         [4] u8; ///< Unknown.
    application_id: [2] u32; ///< ApplicationId, with the u32 low/high words swapped.
    unk_xc:         [12] u8; ///< Unknown.
    timestamp0:     u64; ///< POSIX timestamp.
    timestamp1:     u64; ///< POSIX timestamp.
}

/// ApplicationPlayStatistics
PdmApplicationPlayStatistics :: struct {
    application_id: u64; ///< ApplicationId.
    playtime:       u64; ///< Total play-time in nanoseconds.
    total_launches: u64; ///< Total times the application was launched.
}

/// Initialize pdm:qry.
pdmqryInitialize :: () -> Result #foreign libnx;

/// Exit pdm:qry.
pdmqryExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pdm:qry service session.
pdmqryGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets a list of \ref PdmAppletEvent.
* @param[in] entry_index Start entry index.
* @param[in] flag [10.0.0+] Whether to additionally allow using entries with ::PdmPlayLogPolicy_Unknown3.
* @param[out] events Output \ref PdmAppletEvent array.
* @param[in] count Max entries in the output array.
* @param[out] total_out Total output entries.
*/
pdmqryQueryAppletEvent :: (entry_index: s32, flag: bool, events: *PdmAppletEvent, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets \ref PdmPlayStatistics for the specified ApplicationId.
* @param[in] application_id ApplicationId
* @param[in] flag [10.0.0+] Whether to additionally allow using entries with ::PdmPlayLogPolicy_Unknown3.
* @param[out] stats \ref PdmPlayStatistics
*/
pdmqryQueryPlayStatisticsByApplicationId :: (application_id: u64, flag: bool, stats: *PdmPlayStatistics) -> Result #foreign libnx;

/**
* @brief Gets \ref PdmPlayStatistics for the specified ApplicationId and account userId.
* @param[in] application_id ApplicationId
* @param[in] uid \ref AccountUid
* @param[in] flag [10.0.0+] Whether to additionally allow using entries with ::PdmPlayLogPolicy_Unknown3.
* @param[out] stats \ref PdmPlayStatistics
*/
pdmqryQueryPlayStatisticsByApplicationIdAndUserAccountId :: (application_id: u64, uid: AccountUid, flag: bool, stats: *PdmPlayStatistics) -> Result #foreign libnx;

/**
* @brief Gets \ref PdmLastPlayTime for the specified applications.
* @param[in] flag [10.0.0+] Whether to additionally allow using entries with ::PdmPlayLogPolicy_Unknown3.
* @param[out] playtimes Output \ref PdmLastPlayTime array.
* @param[in] application_ids Input ApplicationIds array.
* @param[in] count Total entries in the input/output arrays.
* @param[out] total_out Total output entries.
*/
pdmqryQueryLastPlayTime :: (flag: bool, playtimes: *PdmLastPlayTime, application_ids: *u64, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets a list of \ref PdmPlayEvent.
* @param[in] entry_index Start entry index.
* @param[out] events Output \ref PdmPlayEvent array.
* @param[in] count Max entries in the output array.
* @param[out] total_out Total output entries.
*/
pdmqryQueryPlayEvent :: (entry_index: s32, events: *PdmPlayEvent, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets range fields which can then be used with the other pdmqry funcs, except for \ref pdmqryQueryAccountPlayEvent.
* @param[out] total_entries Total entries.
* @param[out] start_entry_index Start entry index.
* @param[out] end_entry_index End entry index.
*/
pdmqryGetAvailablePlayEventRange :: (total_entries: *s32, start_entry_index: *s32, end_entry_index: *s32) -> Result #foreign libnx;

/**
* @brief Gets a list of \ref PdmAccountEvent.
* @note Only available with [3.0.0+].
* @param[in] entry_index Start entry index.
* @param[out] events Output \ref PdmAccountEvent array.
* @param[in] count Max entries in the output array.
* @param[out] total_out Total output entries.
*/
pdmqryQueryAccountEvent :: (entry_index: s32, events: *PdmAccountEvent, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets a list of \ref PdmAccountPlayEvent.
* @note Only available with [4.0.0+].
* @param[in] entry_index Start entry index.
* @param[in] uid \ref AccountUid
* @param[out] events Output \ref PdmAccountPlayEvent array.
* @param[in] count Max entries in the output array.
* @param[out] total_out Total output entries.
*/
pdmqryQueryAccountPlayEvent :: (entry_index: s32, uid: AccountUid, events: *PdmAccountPlayEvent, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets range fields which can then be used with \ref pdmqryQueryAccountPlayEvent.
* @param[in] uid \ref AccountUid
* @param[out] total_entries Total entries.
* @param[out] start_entry_index Start entry index.
* @param[out] end_entry_index End entry index.
*/
pdmqryGetAvailableAccountPlayEventRange :: (uid: AccountUid, total_entries: *s32, start_entry_index: *s32, end_entry_index: *s32) -> Result #foreign libnx;

/**
* @brief Gets a list of applications played by the specified user.
* @note Only available with [6.0.0-14.1.2].
* @param[in] uid \ref AccountUid
* @param[in] flag [10.0.0+] Whether to additionally allow using entries with ::PdmPlayLogPolicy_Unknown3.
* @param[out] application_ids Output ApplicationIds array.
* @param[in] count Max entries in the output array.
* @param[out] total_out Total output entries.
*/
pdmqryQueryRecentlyPlayedApplication :: (uid: AccountUid, flag: bool, application_ids: *u64, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when logging a new \ref PdmPlayEvent which would be available via \ref pdmqryQueryAccountEvent, where PdmPlayEvent::event_data::account::type is 0.
* @note Only available with [6.0.0-14.1.2].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
pdmqryGetRecentlyPlayedApplicationUpdateEvent :: (out_event: *Event) -> Result #foreign libnx;

/// ImageOrientation
AlbumImageOrientation :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
    Unknown2 :: 2;
    Unknown3 :: 3;
}

/// AlbumReportOption
AlbumReportOption :: enum u32 {
    Disable :: 0;
    Enable  :: 1;
}

CapsAlbumStorage :: enum u32 {
    Nand :: 0;
    Sd   :: 1;
}

/// ContentType
CapsContentType :: enum u32 {
    Screenshot :: 0;
    Movie      :: 1;
    ExtraMovie :: 3;
}

/// ScreenShotAttribute
CapsScreenShotAttribute :: struct {
    unk_x0:      u32; ///< Always set to 0 by official sw.
    orientation: u32; ///< \ref AlbumImageOrientation
    unk_x8:      u32; ///< Always set to 0 by official sw.
    unk_xc:      u32; ///< Always set to 1 by official sw.
    unk_x10:     [48] u8; ///< Always set to 0 by official sw.
}

/// ScreenShotAttributeForApplication. Only unk_x0 is used by official sw.
CapsScreenShotAttributeForApplication :: struct {
    unk_x0:   u32; ///< Unknown.
    unk_x4:   u8; ///< Unknown.
    unk_x5:   u8; ///< Unknown.
    unk_x6:   u8; ///< Unknown.
    pad:      u8; ///< Padding.
    unk_x8:   u32; ///< Unknown.
    unk_xc:   u32; ///< Unknown.
    unk_x10:  u32; ///< Unknown.
    unk_x14:  u32; ///< Unknown.
    unk_x18:  u32; ///< Unknown.
    unk_x1c:  u32; ///< Unknown.
    unk_x20:  u16; ///< Unknown.
    unk_x22:  u16; ///< Unknown.
    unk_x24:  u16; ///< Unknown.
    unk_x26:  u16; ///< Unknown.
    reserved: [24] u8; ///< Always zero.
}

/// ScreenShotDecoderFlag
CapsScreenShotDecoderFlag :: enum u32 {
    None                  :: 0;
    EnableFancyUpsampling :: 1;
    EnableBlockSmoothing  :: 2;
}

/// ScreenShotDecodeOption
CapsScreenShotDecodeOption :: struct {
    flags:    u64; ///< Bitflags, see \ref CapsScreenShotDecoderFlag.
    reserved: [3] u64; ///< Reserved. Unused by official sw.
}

/// AlbumFileDateTime. This corresponds to each field in the Album entry filename, prior to the "-": "YYYYMMDDHHMMSSII".
CapsAlbumFileDateTime :: struct {
    year:   u16; ///< Year.
    month:  u8; ///< Month.
    day:    u8; ///< Day of the month.
    hour:   u8; ///< Hour.
    minute: u8; ///< Minute.
    second: u8; ///< Second.
    id:     u8; ///< Unique ID for when there's multiple Album files with the same timestamp.
}

/// AlbumEntryId
CapsAlbumFileId :: struct {
    application_id: u64; ///< ApplicationId
    datetime:       CapsAlbumFileDateTime; ///< \ref CapsAlbumFileDateTime
    storage:        u8; ///< \ref CapsAlbumStorage
    content:        u8; ///< \ref CapsAlbumFileContents
    pad_x12:        [6] u8; ///< padding
}

/// AlbumEntry
CapsAlbumEntry :: struct {
    size:    u64; ///< Size.
    file_id: CapsAlbumFileId; ///< \ref CapsAlbumFileId
}

/// ApplicationAlbumEntry
CapsApplicationAlbumEntry :: struct {
    union {
        data: [32] u8; ///< Data.

        v0:   struct {
            unk_x0: [32] u8; ///< aes256 with random key over \ref AlbumEntry.
        }; ///< Pre-7.0.0

        v1:   struct {
            size:     u64; ///< size of the entry
            hash:     u64; ///< aes256 with hardcoded key over \ref AlbumEntry.
            datetime: CapsAlbumFileDateTime; ///< \ref CapsAlbumFileDateTime
            storage:  u8; ///< \ref CapsAlbumStorage
            content:  u8; ///< \ref CapsAlbumFileContents
            pad_x1a:  [5] u8; ///< padding
            unk_x1f:  u8; ///< Set to 1 by official software
        }; ///< [7.0.0+]
    }
}

/// ApplicationAlbumFileEntry
CapsApplicationAlbumFileEntry :: struct {
    entry:    CapsApplicationAlbumEntry; ///< \ref CapsApplicationAlbumEntry
    datetime: CapsAlbumFileDateTime; ///< \ref CapsAlbumFileDateTime
    unk_x28:  u64; ///< Unknown.
}

/// ApplicationData
CapsApplicationData :: struct {
    userdata: [1024] u8; ///< UserData.
    size:     u32; ///< UserData size.
}

/// AlbumFileContents
CapsAlbumFileContents :: enum u32 {
    ScreenShot      :: 0;
    Movie           :: 1;
    ExtraScreenShot :: 2;
    ExtraMovie      :: 3;
}

CapsAlbumContentsUsageFlag :: enum u32 {
    HasGreaterUsage   :: 1;
    IsUnknownContents :: 2;
}

CapsAlbumContentsUsage :: struct {
    count:         s64; ///< Count.
    size:          s64; ///< Size. Used storage space.
    flags:         u32; ///< \ref CapsAlbumContentsUsageFlag
    file_contents: u8; ///< \ref CapsAlbumFileContents
    pad_x15:       [3] u8; ///< Unused
}

CapsAlbumUsage2 :: struct {
    usages: [2] CapsAlbumContentsUsage; ///< \ref CapsAlbumContentsUsage
}

CapsAlbumUsage3 :: struct {
    usages: [3] CapsAlbumContentsUsage; ///< \ref CapsAlbumContentsUsage
}

CapsAlbumUsage16 :: struct {
    usages: [16] CapsAlbumContentsUsage; ///< \ref CapsAlbumContentsUsage
}

/// UserIdList
CapsUserIdList :: struct {
    uids:  [8] AccountUid; ///< \ref AccountUid
    count: u8; ///< Total userIDs.
    pad:   [7] u8; ///< Padding.
}

/// LoadAlbumScreenShotImageOutputForApplication
CapsLoadAlbumScreenShotImageOutputForApplication :: struct {
    width:    s64; ///< Width. Official sw copies this to a s32 output field.
    height:   s64; ///< Height. Official sw copies this to a s32 output field.
    attr:     CapsScreenShotAttributeForApplication; ///< \ref CapsScreenShotAttributeForApplication
    appdata:  CapsApplicationData; ///< \ref CapsApplicationData
    reserved: [172] u8; ///< Unused.
}

/// LoadAlbumScreenShotImageOutput
CapsLoadAlbumScreenShotImageOutput :: struct {
    width:   s64; ///< Width. Official sw copies this to a s32 output field.
    height:  s64; ///< Height. Official sw copies this to a s32 output field.
    attr:    CapsScreenShotAttribute; ///< \ref CapsScreenShotAttribute
    unk_x50: [1024] u8; ///< Unused.
}

/// AlbumFileContentsFlag
CapsAlbumFileContentsFlag :: enum u32 {
    ScreenShot :: 1;
    Movie      :: 2;
}

/// AlbumCache
CapsAlbumCache :: struct {
    count:  u64; ///< Count
    unk_x8: u64; ///< Unknown
}

/// Gets the ShimLibraryVersion.
capsGetShimLibraryVersion :: () -> u64 #foreign libnx;

/// LaunchFlag
PmLaunchFlag :: enum u32 {
    None               :: 0;

    SignalOnExit       :: 1;
    SignalOnStart      :: 2;
    SignalOnCrash      :: 4;
    SignalOnDebug      :: 8;
    StartSuspended     :: 16;
    DisableAslr        :: 32;

    Old_SignalOnExit   :: 1;
    Old_StartSuspended :: 2;
    Old_SignalOnCrash  :: 4;
    Old_DisableAslr    :: 8;
    Old_SignalOnDebug  :: 16;

    Old_SignalOnStart  :: 32;
}

/// ProcessEvent
PmProcessEvent :: enum u32 {
    None       :: 0;
    Exit       :: 1;
    Start      :: 2;
    Crash      :: 3;
    DebugStart :: 4;
    DebugBreak :: 5;
}

/// ProcessEventInfo
PmProcessEventInfo :: struct {
    event:      PmProcessEvent;
    process_id: u64;
}

/// BootMode
PmBootMode :: enum u32 {
    Normal      :: 0;
    Maintenance :: 1;
    SafeMode    :: 2;
}

/// ResourceLimitValues
PmResourceLimitValues :: struct {
    physical_memory:       u64;
    thread_count:          u32;
    event_count:           u32;
    transfer_memory_count: u32;
    session_count:         u32;
}

/// Initialize pm:dmnt.
pmdmntInitialize :: () -> Result #foreign libnx;

/// Exit pm:dmnt.
pmdmntExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pm:dmnt service session.
pmdmntGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize pm:info.
pminfoInitialize :: () -> Result #foreign libnx;

/// Exit pm:info.
pminfoExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pm:info service session.
pminfoGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize pm:shell.
pmshellInitialize :: () -> Result #foreign libnx;

/// Exit pm:shell.
pmshellExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pm:shell service session.
pmshellGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize pm:bm.
pmbmInitialize :: () -> Result #foreign libnx;

/// Exit pm:bm.
pmbmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pm:bm service session.
pmbmGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets the \ref PmBootMode.
* @param[out] out \ref PmBootMode
*/
pmbmGetBootMode :: (out: *PmBootMode) -> Result #foreign libnx;

/**
* @brief Sets the \ref PmBootMode to ::PmBootMode_Maintenance.
*/
pmbmSetMaintenanceBoot :: () -> Result #foreign libnx;

pmdmntGetJitDebugProcessIdList :: (out_count: *u32, out_pids: *u64, max_pids: u64) -> Result #foreign libnx;
pmdmntStartProcess :: (pid: u64) -> Result #foreign libnx;
pmdmntGetProcessId :: (pid_out: *u64, program_id: u64) -> Result #foreign libnx;
pmdmntHookToCreateProcess :: (out: *Event, program_id: u64) -> Result #foreign libnx;
pmdmntGetApplicationProcessId :: (pid_out: *u64) -> Result #foreign libnx;
pmdmntHookToCreateApplicationProcess :: (out: *Event) -> Result #foreign libnx;
pmdmntClearHook :: (which: u32) -> Result #foreign libnx;
pmdmntGetProgramId :: (program_id_out: *u64, pid: u64) -> Result #foreign libnx;

pminfoGetProgramId :: (program_id_out: *u64, pid: u64) -> Result #foreign libnx;
pminfoGetAppletCurrentResourceLimitValues :: (out: *PmResourceLimitValues) -> Result #foreign libnx;
pminfoGetAppletPeakResourceLimitValues :: (out: *PmResourceLimitValues) -> Result #foreign libnx;

pmshellLaunchProgram :: (launch_flags: u32, location: *NcmProgramLocation, pid: *u64) -> Result #foreign libnx;
pmshellTerminateProcess :: (processID: u64) -> Result #foreign libnx;
pmshellTerminateProgram :: (program_id: u64) -> Result #foreign libnx;
pmshellGetProcessEventHandle :: (out: *Event) -> Result #foreign libnx;
pmshellGetProcessEventInfo :: (out: *PmProcessEventInfo) -> Result #foreign libnx;
pmshellCleanupProcess :: (pid: u64) -> Result #foreign libnx;
pmshellClearJitDebugOccured :: (pid: u64) -> Result #foreign libnx;
pmshellNotifyBootFinished :: () -> Result #foreign libnx;
pmshellGetApplicationProcessIdForShell :: (pid_out: *u64) -> Result #foreign libnx;
pmshellBoostSystemMemoryResourceLimit :: (boost_size: u64) -> Result #foreign libnx;
pmshellBoostApplicationThreadResourceLimit :: () -> Result #foreign libnx;
pmshellBoostSystemThreadResourceLimit :: () -> Result #foreign libnx;

/// Values for __nx_time_service_type.
TimeServiceType :: enum u32 {
    User       :: 0;
    Menu       :: 1;
    System     :: 2;
    Repair     :: 3;
    SystemUser :: 4;
}

/// Time clock type.
TimeType :: enum u32 {
    UserSystemClock    :: 0;
    NetworkSystemClock :: 1;
    LocalSystemClock   :: 2;
    Default            :: 0;
}

TimeCalendarTime :: struct {
    year:   u16;
    month:  u8;
    day:    u8;
    hour:   u8;
    minute: u8;
    second: u8;
    pad:    u8;
}

TimeCalendarAdditionalInfo :: struct {
    wday:         u32; ///< 0-based day-of-week.
    yday:         u32; ///< 0-based day-of-year.
    timezoneName: [8] u8; ///< Timezone name string.
    DST:          u32; ///< 0 = no DST, 1 = DST.
    offset:       s32; ///< Seconds relative to UTC for this timezone.
}

TimeZoneRule :: struct {
    data: [16384] u8;
}

TimeLocationName :: struct {
    name: [36] u8;
}

TimeSteadyClockTimePoint :: struct {
    time_point: s64; ///< Monotonic count in seconds.
    source_id:  Uuid; ///< An ID representing the clock source.
}

TimeStandardSteadyClockTimePointType :: struct {
    base_time: s64;
    source_id: Uuid;
}

TimeSystemClockContext :: struct {
    offset:    s64;
    timestamp: TimeSteadyClockTimePoint;
}

/// Initialize time. Used automatically during app startup.
timeInitialize :: () -> Result #foreign libnx;

/// Exit time. Used automatically during app startup.
timeExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual time service session.
timeGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for ISystemClock with the specified \ref TimeType. This will return NULL when the type is invalid.
timeGetServiceSession_SystemClock :: (type: TimeType) -> *Service #foreign libnx;

/// Gets the Service object for ISteadyClock.
timeGetServiceSession_SteadyClock :: () -> *Service #foreign libnx;

/// Gets the Service object for ITimeZoneService.
timeGetServiceSession_TimeZoneService :: () -> *Service #foreign libnx;

/// [6.0.0+] Gets the address of the SharedMemory.
timeGetSharedmemAddr :: () -> *void #foreign libnx;

/**
* @brief Gets the timepoint for the standard steady clock.
* @param[out] out Output timepoint (see \ref TimeSteadyClockTimePoint)
* @remark The standard steady clock counts time since the RTC was configured (usually this happens during manufacturing).
* @return Result code.
*/
timeGetStandardSteadyClockTimePoint :: (out: *TimeSteadyClockTimePoint) -> Result #foreign libnx;

/**
* @brief [3.0.0+] Gets the internal offset for the standard steady clock.
* @param[out] out Output internal offset.
* @return Result code.
*/
timeGetStandardSteadyClockInternalOffset :: (out: *s64) -> Result #foreign libnx;

/**
* @brief Gets the time for the specified clock.
* @param[in] type Clock to use.
* @param[out] timestamp POSIX UTC timestamp.
* @return Result code.
*/
timeGetCurrentTime :: (type: TimeType, timestamp: *u64) -> Result #foreign libnx;

/**
* @brief Sets the time for the specified clock.
* @param[in] type Clock to use.
* @param[in] timestamp POSIX UTC timestamp.
* @return Result code.
*/
timeSetCurrentTime :: (type: TimeType, timestamp: u64) -> Result #foreign libnx;

timeGetDeviceLocationName :: (name: *TimeLocationName) -> Result #foreign libnx;
timeSetDeviceLocationName :: (name: *TimeLocationName) -> Result #foreign libnx;
timeGetTotalLocationNameCount :: (total_location_name_count: *s32) -> Result #foreign libnx;
timeLoadLocationNameList :: (index: s32, location_name_array: *TimeLocationName, location_name_max: s32, location_name_count: *s32) -> Result #foreign libnx;

timeLoadTimeZoneRule :: (name: *TimeLocationName, rule: *TimeZoneRule) -> Result #foreign libnx;

timeToCalendarTime :: (rule: *TimeZoneRule, timestamp: u64, caltime: *TimeCalendarTime, info: *TimeCalendarAdditionalInfo) -> Result #foreign libnx;
timeToCalendarTimeWithMyRule :: (timestamp: u64, caltime: *TimeCalendarTime, info: *TimeCalendarAdditionalInfo) -> Result #foreign libnx;
timeToPosixTime :: (rule: *TimeZoneRule, caltime: *TimeCalendarTime, timestamp_list: *u64, timestamp_list_count: s32, timestamp_count: *s32) -> Result #foreign libnx;
timeToPosixTimeWithMyRule :: (caltime: *TimeCalendarTime, timestamp_list: *u64, timestamp_list_count: s32, timestamp_count: *s32) -> Result #foreign libnx;

/// AdType
BtdrvAdType :: enum u32 {
    Flags                                        :: 1;
    ServiceClassUuid16ListIncomplete             :: 2;
    ServiceClassUuid16ListComplete               :: 3;
    ServiceClassUuid32ListIncomplete             :: 4;
    ServiceClassUuid32ListComplete               :: 5;
    ServiceClassUuid128ListIncomplete            :: 6;
    ServiceClassUuid128ListComplete              :: 7;
    ShortenedLocalName                           :: 8;
    CompleteLocalName                            :: 9;
    TxPowerLevel                                 :: 10;
    ClassOfDevice                                :: 13;
    SimplePairingHashC192                        :: 14;
    SimplePairingRandomizerR192                  :: 15;
    DeviceId                                     :: 16;
    SecurityManagerTkValue                       :: 16;
    SecurityManagerOutOfBandFlags                :: 17;
    PeripheralConnectionIntervalRange            :: 18;
    ServiceSolicitationUuid16List                :: 20;
    ServiceSolicitationUuid128List               :: 21;
    ServiceDataUuid16                            :: 22;
    PublicTargetAddress                          :: 23;
    RandomTargetAddress                          :: 24;
    Appearance                                   :: 25;
    AdvertisingInterval                          :: 26;
    LeBluetoothDeviceAddress                     :: 27;
    LeRole                                       :: 28;
    SimplePairingHashC256                        :: 29;
    SimplePairingRandomizerR256                  :: 30;
    ServiceSolicitationUuid32List                :: 31;
    ServiceDataUuid32                            :: 32;
    ServiceDataUuid128                           :: 33;
    LeSecureConnectionsConfirmationValue         :: 34;
    LeSecureConnectionsRandomValue               :: 35;
    Uri                                          :: 36;
    IndoorPositioning                            :: 37;
    TransportDiscoveryData                       :: 38;
    LeSupportedFeatures                          :: 39;
    ChannelMapUpdateIndication                   :: 40;
    PbAdv                                        :: 41;
    MeshMessage                                  :: 42;
    MeshBeacon                                   :: 43;
    Biginfo                                      :: 44;
    BroadcastCode                                :: 45;
    ResolvableSetIdentifier                      :: 46;
    AdvertisingIntervalLong                      :: 47;
    BroadcastName                                :: 48;
    EncryptedAdvertisingData                     :: 49;
    PeriodicAdvertisingResponseTimingInformation :: 50;
    ElectronicShelfLabel                         :: 52;
    _3DInformationData                           :: 61;
    ManufacturerSpecificData                     :: 255;
}

/// AppearanceCategoryType
BtdrvAppearanceCategoryType :: enum u32 {
    Unknown                  :: 0;
    Phone                    :: 1;
    Computer                 :: 2;
    Watch                    :: 3;
    Clock                    :: 4;
    Display                  :: 5;
    RemoteControl            :: 6;
    EyeGlasses               :: 7;
    Tag                      :: 8;
    Keyring                  :: 9;
    MediaPlayer              :: 10;
    BarcodeScanner           :: 11;
    Thermometer              :: 12;
    HeartRateSensor          :: 13;
    BloodPressure            :: 14;
    HumanInterfaceDevice     :: 15;
    GlucoseMeter             :: 16;
    RunningWalkingSensor     :: 17;
    Cycling                  :: 18;
    ControlDevice            :: 19;
    NetworkDevice            :: 20;
    Sensor                   :: 21;
    LightFixtures            :: 22;
    Fan                      :: 23;
    Hvac                     :: 24;
    AirConditioning          :: 25;
    Humidifier               :: 26;
    Heating                  :: 27;
    AccessControl            :: 28;
    MotorizedDevice          :: 29;
    PowerDevice              :: 30;
    LightSource              :: 31;
    WindowCovering           :: 32;
    AudioSink                :: 33;
    AudioSource              :: 34;
    MotorizedVehicle         :: 35;
    DomesticAppliance        :: 36;
    WearableAudioDevice      :: 37;
    Aircraft                 :: 38;
    AvEquipment              :: 39;
    DisplayEquipment         :: 40;
    HearingAid               :: 41;
    Gaming                   :: 42;
    PulseOximeter            :: 49;
    WeightScale              :: 50;
    PersonalMobilityDevice   :: 51;
    ContinuousGlucoseMonitor :: 52;
    InsulinPump              :: 53;
    MedicationDelivery       :: 54;
    Spirometer               :: 55;
    OutdoorSportsActivity    :: 81;
}

/// AppearanceType
BtdrvAppearanceType :: enum u32 {
    DesktopWorkstation            :: 129;
    ServerClassComputer           :: 130;
    Laptop                        :: 131;
    HandheldPcPdaClamshell        :: 132;
    PalmSizePcPda                 :: 133;
    WearableComputerWatchSize     :: 134;
    Tablet                        :: 135;
    DockingStation                :: 136;
    AllInOne                      :: 137;
    BladeServer                   :: 138;
    Convertible                   :: 139;
    Detachable                    :: 140;
    IotGateway                    :: 141;
    MiniPc                        :: 142;
    StickPc                       :: 143;
    SportsWatch                   :: 193;
    Smartwatch                    :: 194;
    EarThermometer                :: 769;
    HeartRateBelt                 :: 833;
    ArmBloodPressure              :: 897;
    WristBloodPressure            :: 898;
    Keyboard                      :: 961;
    Mouse                         :: 962;
    Joystick                      :: 963;
    Gamepad                       :: 964;
    DigitizerTablet               :: 965;
    CardReader                    :: 966;
    DigitalPen                    :: 967;
    BarcodeScanner                :: 968;
    Touchpad                      :: 969;
    PresentationRemote            :: 970;
    InShoeRunningWalkingSensor    :: 1089;
    OnShoeRunningWalkingSensor    :: 1090;
    OnHipRunningWalkingSensor     :: 1091;
    CyclingComputer               :: 1153;
    SpeedSensor                   :: 1154;
    CadenceSensor                 :: 1155;
    PowerSensor                   :: 1156;
    SpeedAndCadenceSensor         :: 1157;
    Switch                        :: 1217;
    MultiSwitch                   :: 1218;
    Button                        :: 1219;
    Slider                        :: 1220;
    RotarySwitch                  :: 1221;
    TouchPanel                    :: 1222;
    SingleSwitch                  :: 1223;
    DoubleSwitch                  :: 1224;
    TripleSwitch                  :: 1225;
    BatterySwitch                 :: 1226;
    EnergyHarvestingSwitch        :: 1227;
    PushButton                    :: 1228;
    AccessPoint                   :: 1281;
    MeshDevice                    :: 1282;
    MeshNetworkProxy              :: 1283;
    MotionSensor                  :: 1345;
    AirQualitySensor              :: 1346;
    TemperatureSensor             :: 1347;
    HumiditySensor                :: 1348;
    LeakSensor                    :: 1349;
    SmokeSensor                   :: 1350;
    OccupancySensor               :: 1351;
    ContactSensor                 :: 1352;
    CarbonMonoxideSensor          :: 1353;
    CarbonDioxideSensor           :: 1354;
    AmbientLightSensor            :: 1355;
    EnergySensor                  :: 1356;
    ColorLightSensor              :: 1357;
    RainSensor                    :: 1358;
    FireSensor                    :: 1359;
    WindSensor                    :: 1360;
    ProximitySensor               :: 1361;
    MultiSensor                   :: 1362;
    FlushMountedSensor            :: 1363;
    CeilingMountedSensor          :: 1364;
    WallMountedSensor             :: 1365;
    Multisensor                   :: 1366;
    EnergyMeter                   :: 1367;
    FlameDetector                 :: 1368;
    VehicleTirePressureSensor     :: 1369;
    WallLight                     :: 1409;
    CeilingLight                  :: 1410;
    FloorLight                    :: 1411;
    CabinetLight                  :: 1412;
    DeskLight                     :: 1413;
    TrofferLight                  :: 1414;
    PendantLight                  :: 1415;
    InGroundLight                 :: 1416;
    FloodLight                    :: 1417;
    UnderwaterLight               :: 1418;
    BollardWithLight              :: 1419;
    PathwayLight                  :: 1420;
    GardenLight                   :: 1421;
    PoleTopLight                  :: 1422;
    Spotlight                     :: 1423;
    LinearLight                   :: 1424;
    StreetLight                   :: 1425;
    ShelvesLight                  :: 1426;
    BayLight                      :: 1427;
    EmergencyExitLight            :: 1428;
    LightController               :: 1429;
    LightDriver                   :: 1430;
    Bulb                          :: 1431;
    LowBayLight                   :: 1432;
    HighBayLight                  :: 1433;
    CeilingFan                    :: 1473;
    AxialFan                      :: 1474;
    ExhaustFan                    :: 1475;
    PedestalFan                   :: 1476;
    DeskFan                       :: 1477;
    WallFan                       :: 1478;
    Thermostat                    :: 1537;
    Humidifier                    :: 1538;
    DeHumidifier                  :: 1539;
    Heater                        :: 1540;
    HvacRadiator                  :: 1541;
    HvacBoiler                    :: 1542;
    HvacHeatPump                  :: 1543;
    HvacInfraredHeater            :: 1544;
    HvacRadiantPanelHeater        :: 1545;
    HvacFanHeater                 :: 1546;
    HvacAirCurtain                :: 1547;
    HeatingRadiator               :: 1729;
    HeatingBoiler                 :: 1730;
    HeatingHeatPump               :: 1731;
    HeatingInfraredHeater         :: 1732;
    HeatingRadiantPanelHeater     :: 1733;
    HeatingFanHeater              :: 1734;
    HeatingAirCurtain             :: 1735;
    AccessDoor                    :: 1793;
    GarageDoor                    :: 1794;
    EmergencyExitDoor             :: 1795;
    AccessLock                    :: 1796;
    Elevator                      :: 1797;
    Window                        :: 1798;
    EntranceGate                  :: 1799;
    DoorLock                      :: 1800;
    Locker                        :: 1801;
    MotorizedGate                 :: 1857;
    Awning                        :: 1858;
    BlindsOrShades                :: 1859;
    Curtains                      :: 1860;
    Screen                        :: 1861;
    PowerOutlet                   :: 1921;
    PowerStrip                    :: 1922;
    Plug                          :: 1923;
    PowerSupply                   :: 1924;
    LedDriver                     :: 1925;
    FluorescentLampGear           :: 1926;
    HidLampGear                   :: 1927;
    ChargeCase                    :: 1928;
    PowerBank                     :: 1929;
    IncandescentLightBulb         :: 1985;
    LedLamp                       :: 1986;
    HidLamp                       :: 1987;
    FluorescentLamp               :: 1988;
    LedArray                      :: 1989;
    MultiColorLedArray            :: 1990;
    LowVoltageHalogen             :: 1991;
    OrganicLightEmittingDiodeOled :: 1992;
    WindowShades                  :: 2049;
    WindowBlinds                  :: 2050;
    WindowAwning                  :: 2051;
    WindowCurtain                 :: 2052;
    ExteriorShutter               :: 2053;
    ExteriorScreen                :: 2054;
    StandaloneSpeaker             :: 2113;
    Soundbar                      :: 2114;
    BookshelfSpeaker              :: 2115;
    StandmountedSpeaker           :: 2116;
    Speakerphone                  :: 2117;
    Microphone                    :: 2177;
    Alarm                         :: 2178;
    Bell                          :: 2179;
    Horn                          :: 2180;
    BroadcastingDevice            :: 2181;
    ServiceDesk                   :: 2182;
    Kiosk                         :: 2183;
    BroadcastingRoom              :: 2184;
    Auditorium                    :: 2185;
    Car                           :: 2241;
    LargeGoodsVehicle             :: 2242;
    _2WheeledVehicle              :: 2243;
    Motorbike                     :: 2244;
    Scooter                       :: 2245;
    Moped                         :: 2246;
    _3WheeledVehicle              :: 2247;
    LightVehicle                  :: 2248;
    QuadBike                      :: 2249;
    Minibus                       :: 2250;
    Bus                           :: 2251;
    Trolley                       :: 2252;
    AgriculturalVehicle           :: 2253;
    CamperCaravan                 :: 2254;
    RecreationalVehicleMotorHome  :: 2255;
    Refrigerator                  :: 2305;
    Freezer                       :: 2306;
    Oven                          :: 2307;
    Microwave                     :: 2308;
    Toaster                       :: 2309;
    WashingMachine                :: 2310;
    Dryer                         :: 2311;
    CoffeeMaker                   :: 2312;
    ClothesIron                   :: 2313;
    CurlingIron                   :: 2314;
    HairDryer                     :: 2315;
    VacuumCleaner                 :: 2316;
    RoboticVacuumCleaner          :: 2317;
    RiceCooker                    :: 2318;
    ClothesSteamer                :: 2319;
    Earbud                        :: 2369;
    Headset                       :: 2370;
    Headphones                    :: 2371;
    NeckBand                      :: 2372;
    LightAircraft                 :: 2433;
    Microlight                    :: 2434;
    Paraglider                    :: 2435;
    LargePassengerAircraft        :: 2436;
    Amplifier                     :: 2497;
    Receiver                      :: 2498;
    Radio                         :: 2499;
    Tuner                         :: 2500;
    Turntable                     :: 2501;
    CdPlayer                      :: 2502;
    DvdPlayer                     :: 2503;
    BlurayPlayer                  :: 2504;
    OpticalDiscPlayer             :: 2505;
    SetTopBox                     :: 2506;
    Television                    :: 2561;
    Monitor                       :: 2562;
    Projector                     :: 2563;
    InEarHearingAid               :: 2625;
    BehindEarHearingAid           :: 2626;
    CochlearImplant               :: 2627;
    HomeVideoGameConsole          :: 2689;
    PortableHandheldConsole       :: 2690;
    FingertipPulseOximeter        :: 3137;
    WristWornPulseOximeter        :: 3138;
    PoweredWheelchair             :: 3265;
    MobilityScooter               :: 3266;
    InsulinPumpDurablePump        :: 3393;
    InsulinPumpPatchPump          :: 3396;
    InsulinPen                    :: 3400;
    HandheldSpirometer            :: 3521;
    LocationDisplay               :: 5185;
    LocationAndNavigationDisplay  :: 5186;
    LocationPod                   :: 5187;
    LocationAndNavigationPod      :: 5188;
}

/// GattServiceUuidType
BtdrvGattServiceUuidType :: enum u32 {
    GenericAccess                :: 6144;
    GenericAttribute             :: 6145;
    ImmediateAlert               :: 6146;
    LinkLoss                     :: 6147;
    TxPower                      :: 6148;
    CurrentTime                  :: 6149;
    ReferenceTimeUpdate          :: 6150;
    NextDstChange                :: 6151;
    Glucose                      :: 6152;
    HealthThermometer            :: 6153;
    DeviceInformation            :: 6154;
    HeartRate                    :: 6157;
    PhoneAlertStatus             :: 6158;
    Battery                      :: 6159;
    BloodPressure                :: 6160;
    AlertNotification            :: 6161;
    HumanInterfaceDevice         :: 6162;
    ScanParameters               :: 6163;
    RunningSpeedAndCadence       :: 6164;
    AutomationIo                 :: 6165;
    CyclingSpeedAndCadence       :: 6166;
    CyclingPower                 :: 6168;
    LocationAndNavigation        :: 6169;
    EnvironmentalSensing         :: 6170;
    BodyComposition              :: 6171;
    UserData                     :: 6172;
    WeightScale                  :: 6173;
    BondManagement               :: 6174;
    ContinuousGlucoseMonitoring  :: 6175;
    InternetProtocolSupport      :: 6176;
    IndoorPositioning            :: 6177;
    PulseOximeter                :: 6178;
    HttpProxy                    :: 6179;
    TransportDiscovery           :: 6180;
    ObjectTransfer               :: 6181;
    FitnessMachine               :: 6182;
    MeshProvisioning             :: 6183;
    MeshProxy                    :: 6184;
    ReconnectionConfiguration    :: 6185;
    InsulinDelivery              :: 6202;
    BinarySensor                 :: 6203;
    EmergencyConfiguration       :: 6204;
    AuthorizationControl         :: 6205;
    PhysicalActivityMonitor      :: 6206;
    ElapsedTime                  :: 6207;
    GenericHealthSensor          :: 6208;
    AudioInputControl            :: 6211;
    VolumeControl                :: 6212;
    VolumeOffsetControl          :: 6213;
    CoordinatedSetIdentification :: 6214;
    DeviceTime                   :: 6215;
    MediaControl                 :: 6216;
    GenericMediaControl          :: 6217;
    ConstantToneExtension        :: 6218;
    TelephoneBearer              :: 6219;
    GenericTelephoneBearer       :: 6220;
    MicrophoneControl            :: 6221;
    AudioStreamControl           :: 6222;
    BroadcastAudioScan           :: 6223;
    PublishedAudioCapabilities   :: 6224;
    BasicAudioAnnouncement       :: 6225;
    BroadcastAudioAnnouncement   :: 6226;
    CommonAudio                  :: 6227;
    HearingAccess                :: 6228;
    TelephonyAndMediaAudio       :: 6229;
    PublicBroadcastAnnouncement  :: 6230;
    ElectronicShelfLabel         :: 6231;
}

/// GattCharacteristicUuidType
BtdrvGattCharacteristicUuidType :: enum u32 {
    DeviceName                                           :: 10752;
    Appearance                                           :: 10753;
    PeripheralPrivacyFlag                                :: 10754;
    ReconnectionAddress                                  :: 10755;
    PeripheralPreferredConnectionParameters              :: 10756;
    ServiceChanged                                       :: 10757;
    AlertLevel                                           :: 10758;
    TxPowerLevel                                         :: 10759;
    DateTime                                             :: 10760;
    DayOfWeek                                            :: 10761;
    DayDateTime                                          :: 10762;
    ExactTime256                                         :: 10764;
    DstOffset                                            :: 10765;
    TimeZone                                             :: 10766;
    LocalTimeInformation                                 :: 10767;
    TimeWithDst                                          :: 10769;
    TimeAccuracy                                         :: 10770;
    TimeSource                                           :: 10771;
    ReferenceTimeInformation                             :: 10772;
    TimeUpdateControlPoint                               :: 10774;
    TimeUpdateState                                      :: 10775;
    GlucoseMeasurement                                   :: 10776;
    BatteryLevel                                         :: 10777;
    TemperatureMeasurement                               :: 10780;
    TemperatureType                                      :: 10781;
    IntermediateTemperature                              :: 10782;
    MeasurementInterval                                  :: 10785;
    BootKeyboardInputReport                              :: 10786;
    SystemId                                             :: 10787;
    ModelNumberString                                    :: 10788;
    SerialNumberString                                   :: 10789;
    FirmwareRevisionString                               :: 10790;
    HardwareRevisionString                               :: 10791;
    SoftwareRevisionString                               :: 10792;
    ManufacturerNameString                               :: 10793;
    IeeeRegulatoryCertificationDataList                  :: 10794;
    CurrentTime                                          :: 10795;
    MagneticDeclination                                  :: 10796;
    ScanRefresh                                          :: 10801;
    BootKeyboardOutputReport                             :: 10802;
    BootMouseInputReport                                 :: 10803;
    GlucoseMeasurementContext                            :: 10804;
    BloodPressureMeasurement                             :: 10805;
    IntermediateCuffPressure                             :: 10806;
    HeartRateMeasurement                                 :: 10807;
    BodySensorLocation                                   :: 10808;
    HeartRateControlPoint                                :: 10809;
    AlertStatus                                          :: 10815;
    RingerControlPoint                                   :: 10816;
    RingerSetting                                        :: 10817;
    AlertCategoryIdBitMask                               :: 10818;
    AlertCategoryId                                      :: 10819;
    AlertNotificationControlPoint                        :: 10820;
    UnreadAlertStatus                                    :: 10821;
    NewAlert                                             :: 10822;
    SupportedNewAlertCategory                            :: 10823;
    SupportedUnreadAlertCategory                         :: 10824;
    BloodPressureFeature                                 :: 10825;
    HidInformation                                       :: 10826;
    ReportMap                                            :: 10827;
    HidControlPoint                                      :: 10828;
    Report                                               :: 10829;
    ProtocolMode                                         :: 10830;
    ScanIntervalWindow                                   :: 10831;
    PnpId                                                :: 10832;
    GlucoseFeature                                       :: 10833;
    RecordAccessControlPoint                             :: 10834;
    RscMeasurement                                       :: 10835;
    RscFeature                                           :: 10836;
    ScControlPoint                                       :: 10837;
    Aggregate                                            :: 10842;
    CscMeasurement                                       :: 10843;
    CscFeature                                           :: 10844;
    SensorLocation                                       :: 10845;
    PlxSpotCheckMeasurement                              :: 10846;
    PlxContinuousMeasurement                             :: 10847;
    PlxFeatures                                          :: 10848;
    CyclingPowerMeasurement                              :: 10851;
    CyclingPowerVector                                   :: 10852;
    CyclingPowerFeature                                  :: 10853;
    CyclingPowerControlPoint                             :: 10854;
    LocationAndSpeed                                     :: 10855;
    Navigation                                           :: 10856;
    PositionQuality                                      :: 10857;
    LnFeature                                            :: 10858;
    LnControlPoint                                       :: 10859;
    Elevation                                            :: 10860;
    Pressure                                             :: 10861;
    Temperature                                          :: 10862;
    Humidity                                             :: 10863;
    TrueWindSpeed                                        :: 10864;
    TrueWindDirection                                    :: 10865;
    ApparentWindSpeed                                    :: 10866;
    ApparentWindDirection                                :: 10867;
    GustFactor                                           :: 10868;
    PollenConcentration                                  :: 10869;
    UvIndex                                              :: 10870;
    Irradiance                                           :: 10871;
    Rainfall                                             :: 10872;
    WindChill                                            :: 10873;
    HeatIndex                                            :: 10874;
    DewPoint                                             :: 10875;
    DescriptorValueChanged                               :: 10877;
    AerobicHeartRateLowerLimit                           :: 10878;
    AerobicThreshold                                     :: 10879;
    Age                                                  :: 10880;
    AnaerobicHeartRateLowerLimit                         :: 10881;
    AnaerobicHeartRateUpperLimit                         :: 10882;
    AnaerobicThreshold                                   :: 10883;
    AerobicHeartRateUpperLimit                           :: 10884;
    DateOfBirth                                          :: 10885;
    DateOfThresholdAssessment                            :: 10886;
    EmailAddress                                         :: 10887;
    FatBurnHeartRateLowerLimit                           :: 10888;
    FatBurnHeartRateUpperLimit                           :: 10889;
    FirstName                                            :: 10890;
    FiveZoneHeartRateLimits                              :: 10891;
    Gender                                               :: 10892;
    HeartRateMax                                         :: 10893;
    Height                                               :: 10894;
    HipCircumference                                     :: 10895;
    LastName                                             :: 10896;
    MaximumRecommendedHeartRate                          :: 10897;
    RestingHeartRate                                     :: 10898;
    SportTypeForAerobicAndAnaerobicThresholds            :: 10899;
    ThreeZoneHeartRateLimits                             :: 10900;
    TwoZoneHeartRateLimits                               :: 10901;
    Vo2Max                                               :: 10902;
    WaistCircumference                                   :: 10903;
    Weight                                               :: 10904;
    DatabaseChangeIncrement                              :: 10905;
    UserIndex                                            :: 10906;
    BodyCompositionFeature                               :: 10907;
    BodyCompositionMeasurement                           :: 10908;
    WeightMeasurement                                    :: 10909;
    WeightScaleFeature                                   :: 10910;
    UserControlPoint                                     :: 10911;
    MagneticFluxDensity2D                                :: 10912;
    MagneticFluxDensity3D                                :: 10913;
    Language                                             :: 10914;
    BarometricPressureTrend                              :: 10915;
    BondManagementControlPoint                           :: 10916;
    BondManagementFeature                                :: 10917;
    CentralAddressResolution                             :: 10918;
    CgmMeasurement                                       :: 10919;
    CgmFeature                                           :: 10920;
    CgmStatus                                            :: 10921;
    CgmSessionStartTime                                  :: 10922;
    CgmSessionRunTime                                    :: 10923;
    CgmSpecificOpsControlPoint                           :: 10924;
    IndoorPositioningConfiguration                       :: 10925;
    Latitude                                             :: 10926;
    Longitude                                            :: 10927;
    LocalNorthCoordinate                                 :: 10928;
    LocalEastCoordinate                                  :: 10929;
    FloorNumber                                          :: 10930;
    Altitude                                             :: 10931;
    Uncertainty                                          :: 10932;
    LocationName                                         :: 10933;
    Uri                                                  :: 10934;
    HttpHeaders                                          :: 10935;
    HttpStatusCode                                       :: 10936;
    HttpEntityBody                                       :: 10937;
    HttpControlPoint                                     :: 10938;
    HttpsSecurity                                        :: 10939;
    TdsControlPoint                                      :: 10940;
    OtsFeature                                           :: 10941;
    ObjectName                                           :: 10942;
    ObjectType                                           :: 10943;
    ObjectSize                                           :: 10944;
    ObjectFirstCreated                                   :: 10945;
    ObjectLastModified                                   :: 10946;
    ObjectId                                             :: 10947;
    ObjectProperties                                     :: 10948;
    ObjectActionControlPoint                             :: 10949;
    ObjectListControlPoint                               :: 10950;
    ObjectListFilter                                     :: 10951;
    ObjectChanged                                        :: 10952;
    ResolvablePrivateAddressOnly                         :: 10953;
    FitnessMachineFeature                                :: 10956;
    TreadmillData                                        :: 10957;
    CrossTrainerData                                     :: 10958;
    StepClimberData                                      :: 10959;
    StairClimberData                                     :: 10960;
    RowerData                                            :: 10961;
    IndoorBikeData                                       :: 10962;
    TrainingStatus                                       :: 10963;
    SupportedSpeedRange                                  :: 10964;
    SupportedInclinationRange                            :: 10965;
    SupportedResistanceLevelRange                        :: 10966;
    SupportedHeartRateRange                              :: 10967;
    SupportedPowerRange                                  :: 10968;
    FitnessMachineControlPoint                           :: 10969;
    FitnessMachineStatus                                 :: 10970;
    MeshProvisioningDataIn                               :: 10971;
    MeshProvisioningDataOut                              :: 10972;
    MeshProxyDataIn                                      :: 10973;
    MeshProxyDataOut                                     :: 10974;
    AverageCurrent                                       :: 10976;
    AverageVoltage                                       :: 10977;
    Boolean                                              :: 10978;
    ChromaticDistanceFromPlanckian                       :: 10979;
    ChromaticityCoordinates                              :: 10980;
    ChromaticityInCctAndDuvValues                        :: 10981;
    ChromaticityTolerance                                :: 10982;
    CieColorRenderingIndex                               :: 10983;
    Coefficient                                          :: 10984;
    CorrelatedColorTemperature                           :: 10985;
    Count16                                              :: 10986;
    Count24                                              :: 10987;
    CountryCode                                          :: 10988;
    DateUtc                                              :: 10989;
    ElectricCurrent                                      :: 10990;
    ElectricCurrentRange                                 :: 10991;
    ElectricCurrentSpecification                         :: 10992;
    ElectricCurrentStatistics                            :: 10993;
    Energy                                               :: 10994;
    EnergyInAPeriodOfDay                                 :: 10995;
    EventStatistics                                      :: 10996;
    FixedString16                                        :: 10997;
    FixedString24                                        :: 10998;
    FixedString36                                        :: 10999;
    FixedString8                                         :: 11000;
    GenericLevel                                         :: 11001;
    GlobalTradeItemNumber                                :: 11002;
    Illuminance                                          :: 11003;
    LuminousEfficacy                                     :: 11004;
    LuminousEnergy                                       :: 11005;
    LuminousExposure                                     :: 11006;
    LuminousFlux                                         :: 11007;
    LuminousFluxRange                                    :: 11008;
    LuminousIntensity                                    :: 11009;
    MassFlow                                             :: 11010;
    PerceivedLightness                                   :: 11011;
    Percentage8                                          :: 11012;
    Power                                                :: 11013;
    PowerSpecification                                   :: 11014;
    RelativeRuntimeInACurrentRange                       :: 11015;
    RelativeRuntimeInAGenericLevelRange                  :: 11016;
    RelativeValueInAVoltageRange                         :: 11017;
    RelativeValueInAnIlluminanceRange                    :: 11018;
    RelativeValueInAPeriodOfDay                          :: 11019;
    RelativeValueInATemperatureRange                     :: 11020;
    Temperature8                                         :: 11021;
    Temperature8InAPeriodOfDay                           :: 11022;
    Temperature8Statistics                               :: 11023;
    TemperatureRange                                     :: 11024;
    TemperatureStatistics                                :: 11025;
    TimeDecihour8                                        :: 11026;
    TimeExponential8                                     :: 11027;
    TimeHour24                                           :: 11028;
    TimeMillisecond24                                    :: 11029;
    TimeSecond16                                         :: 11030;
    TimeSecond8                                          :: 11031;
    Voltage                                              :: 11032;
    VoltageSpecification                                 :: 11033;
    VoltageStatistics                                    :: 11034;
    VolumeFlow                                           :: 11035;
    ChromaticityCoordinate                               :: 11036;
    RcFeature                                            :: 11037;
    RcSettings                                           :: 11038;
    ReconnectionConfigurationControlPoint                :: 11039;
    IddStatusChanged                                     :: 11040;
    IddStatus                                            :: 11041;
    IddAnnunciationStatus                                :: 11042;
    IddFeatures                                          :: 11043;
    IddStatusReaderControlPoint                          :: 11044;
    IddCommandControlPoint                               :: 11045;
    IddCommandData                                       :: 11046;
    IddRecordAccessControlPoint                          :: 11047;
    IddHistoryData                                       :: 11048;
    ClientSupportedFeatures                              :: 11049;
    DatabaseHash                                         :: 11050;
    BssControlPoint                                      :: 11051;
    BssResponse                                          :: 11052;
    EmergencyId                                          :: 11053;
    EmergencyText                                        :: 11054;
    AcsStatus                                            :: 11055;
    AcsDataIn                                            :: 11056;
    AcsDataOutNotify                                     :: 11057;
    AcsDataOutIndicate                                   :: 11058;
    AcsControlPoint                                      :: 11059;
    EnhancedBloodPressureMeasurement                     :: 11060;
    EnhancedIntermediateCuffPressure                     :: 11061;
    BloodPressureRecord                                  :: 11062;
    RegisteredUser                                       :: 11063;
    BrEdrHandoverData                                    :: 11064;
    BluetoothSigData                                     :: 11065;
    ServerSupportedFeatures                              :: 11066;
    PhysicalActivityMonitorFeatures                      :: 11067;
    GeneralActivityInstantaneousData                     :: 11068;
    GeneralActivitySummaryData                           :: 11069;
    CardiorespiratoryActivityInstantaneousData           :: 11070;
    CardiorespiratoryActivitySummaryData                 :: 11071;
    StepCounterActivitySummaryData                       :: 11072;
    SleepActivityInstantaneousData                       :: 11073;
    SleepActivitySummaryData                             :: 11074;
    PhysicalActivityMonitorControlPoint                  :: 11075;
    ActivityCurrentSession                               :: 11076;
    PhysicalActivitySessionDescriptor                    :: 11077;
    PreferredUnits                                       :: 11078;
    HighResolutionHeight                                 :: 11079;
    MiddleName                                           :: 11080;
    StrideLength                                         :: 11081;
    Handedness                                           :: 11082;
    DeviceWearingPosition                                :: 11083;
    FourZoneHeartRateLimits                              :: 11084;
    HighIntensityExerciseThreshold                       :: 11085;
    ActivityGoal                                         :: 11086;
    SedentaryIntervalNotification                        :: 11087;
    CaloricIntake                                        :: 11088;
    TmapRole                                             :: 11089;
    AudioInputState                                      :: 11127;
    GainSettingsAttribute                                :: 11128;
    AudioInputType                                       :: 11129;
    AudioInputStatus                                     :: 11130;
    AudioInputControlPoint                               :: 11131;
    AudioInputDescription                                :: 11132;
    VolumeState                                          :: 11133;
    VolumeControlPoint                                   :: 11134;
    VolumeFlags                                          :: 11135;
    VolumeOffsetState                                    :: 11136;
    AudioLocation                                        :: 11137;
    VolumeOffsetControlPoint                             :: 11138;
    AudioOutputDescription                               :: 11139;
    SetIdentityResolvingKey                              :: 11140;
    CoordinatedSetSize                                   :: 11141;
    SetMemberLock                                        :: 11142;
    SetMemberRank                                        :: 11143;
    EncryptedDataKeyMaterial                             :: 11144;
    ApparentEnergy32                                     :: 11145;
    ApparentPower                                        :: 11146;
    LiveHealthObservations                               :: 11147;
    CoTextsubscript2Concentration                        :: 11148;
    CosineOfTheAngle                                     :: 11149;
    DeviceTimeFeature                                    :: 11150;
    DeviceTimeParameters                                 :: 11151;
    DeviceTime                                           :: 11152;
    DeviceTimeControlPoint                               :: 11153;
    TimeChangeLogData                                    :: 11154;
    MediaPlayerName                                      :: 11155;
    MediaPlayerIconObjectId                              :: 11156;
    MediaPlayerIconUrl                                   :: 11157;
    TrackChanged                                         :: 11158;
    TrackTitle                                           :: 11159;
    TrackDuration                                        :: 11160;
    TrackPosition                                        :: 11161;
    PlaybackSpeed                                        :: 11162;
    SeekingSpeed                                         :: 11163;
    CurrentTrackSegmentsObjectId                         :: 11164;
    CurrentTrackObjectId                                 :: 11165;
    NextTrackObjectId                                    :: 11166;
    ParentGroupObjectId                                  :: 11167;
    CurrentGroupObjectId                                 :: 11168;
    PlayingOrder                                         :: 11169;
    PlayingOrdersSupported                               :: 11170;
    MediaState                                           :: 11171;
    MediaControlPoint                                    :: 11172;
    MediaControlPointOpcodesSupported                    :: 11173;
    SearchResultsObjectId                                :: 11174;
    SearchControlPoint                                   :: 11175;
    Energy32                                             :: 11176;
    MediaPlayerIconObjectType                            :: 11177;
    TrackSegmentsObjectType                              :: 11178;
    TrackObjectType                                      :: 11179;
    GroupObjectType                                      :: 11180;
    ConstantToneExtensionEnable                          :: 11181;
    AdvertisingConstantToneExtensionMinimumLength        :: 11182;
    AdvertisingConstantToneExtensionMinimumTransmitCount :: 11183;
    AdvertisingConstantToneExtensionTransmitDuration     :: 11184;
    AdvertisingConstantToneExtensionInterval             :: 11185;
    AdvertisingConstantToneExtensionPhy                  :: 11186;
    BearerProviderName                                   :: 11187;
    BearerUci                                            :: 11188;
    BearerTechnology                                     :: 11189;
    BearerUriSchemesSupportedList                        :: 11190;
    BearerSignalStrength                                 :: 11191;
    BearerSignalStrengthReportingInterval                :: 11192;
    BearerListCurrentCalls                               :: 11193;
    ContentControlId                                     :: 11194;
    StatusFlags                                          :: 11195;
    IncomingCallTargetBearerUri                          :: 11196;
    CallState                                            :: 11197;
    CallControlPoint                                     :: 11198;
    CallControlPointOptionalOpcodes                      :: 11199;
    TerminationReason                                    :: 11200;
    IncomingCall                                         :: 11201;
    CallFriendlyName                                     :: 11202;
    Mute                                                 :: 11203;
    SinkAse                                              :: 11204;
    SourceAse                                            :: 11205;
    AseControlPoint                                      :: 11206;
    BroadcastAudioScanControlPoint                       :: 11207;
    BroadcastReceiveState                                :: 11208;
    SinkPac                                              :: 11209;
    SinkAudioLocations                                   :: 11210;
    SourcePac                                            :: 11211;
    SourceAudioLocations                                 :: 11212;
    AvailableAudioContexts                               :: 11213;
    SupportedAudioContexts                               :: 11214;
    AmmoniaConcentration                                 :: 11215;
    CarbonMonoxideConcentration                          :: 11216;
    MethaneConcentration                                 :: 11217;
    NitrogenDioxideConcentration                         :: 11218;
    NonMethaneVolatileOrganicCompoundsConcentration      :: 11219;
    OzoneConcentration                                   :: 11220;
    ParticulateMatterPm1Concentration                    :: 11221;
    ParticulateMatterPm25Concentration                   :: 11222;
    ParticulateMatterPm10Concentration                   :: 11223;
    SulfurDioxideConcentration                           :: 11224;
    SulfurHexafluorideConcentration                      :: 11225;
    HearingAidFeatures                                   :: 11226;
    HearingAidPresetControlPoint                         :: 11227;
    ActivePresetIndex                                    :: 11228;
    StoredHealthObservations                             :: 11229;
    FixedString64                                        :: 11230;
    HighTemperature                                      :: 11231;
    HighVoltage                                          :: 11232;
    LightDistribution                                    :: 11233;
    LightOutput                                          :: 11234;
    LightSourceType                                      :: 11235;
    Noise                                                :: 11236;
    RelativeRuntimeInACorrelatedColorTemperatureRange    :: 11237;
    TimeSecond32                                         :: 11238;
    VocConcentration                                     :: 11239;
    VoltageFrequency                                     :: 11240;
    BatteryCriticalStatus                                :: 11241;
    BatteryHealthStatus                                  :: 11242;
    BatteryHealthInformation                             :: 11243;
    BatteryInformation                                   :: 11244;
    BatteryLevelStatus                                   :: 11245;
    BatteryTimeStatus                                    :: 11246;
    EstimatedServiceDate                                 :: 11247;
    BatteryEnergyStatus                                  :: 11248;
    ObservationScheduleChanged                           :: 11249;
    CurrentElapsedTime                                   :: 11250;
    HealthSensorFeatures                                 :: 11251;
    GhsControlPoint                                      :: 11252;
    LeGattSecurityLevels                                 :: 11253;
    EslAddress                                           :: 11254;
    ApSyncKeyMaterial                                    :: 11255;
    EslResponseKeyMaterial                               :: 11256;
    EslCurrentAbsoluteTime                               :: 11257;
    EslDisplayInformation                                :: 11258;
    EslImageInformation                                  :: 11259;
    EslSensorInformation                                 :: 11260;
    EslLedInformation                                    :: 11261;
    EslControlPoint                                      :: 11262;
    UdiForMedicalDevices                                 :: 11263;
}

/// GattDescriptorUuidType
BtdrvGattDescriptorUuidType :: enum u32 {
    CharacteristicExtendedProperties   :: 10496;
    CharacteristicUserDescription      :: 10497;
    ClientCharacteristicConfiguration  :: 10498;
    ServerCharacteristicConfiguration  :: 10499;
    CharacteristicPresentationFormat   :: 10500;
    CharacteristicAggregateFormat      :: 10501;
    ValidRange                         :: 10502;
    ExternalReportReference            :: 10503;
    ReportReference                    :: 10504;
    NumberOfDigitals                   :: 10505;
    ValueTriggerSetting                :: 10506;
    EnvironmentalSensingConfiguration  :: 10507;
    EnvironmentalSensingMeasurement    :: 10508;
    EnvironmentalSensingTriggerSetting :: 10509;
    TimeTriggerSetting                 :: 10510;
    CompleteBrEdrTransportBlockData    :: 10511;
    ObservationSchedule                :: 10512;
    ValidRangeAndAccuracy              :: 10513;
}

/// BluetoothPropertyType [1.0.0-11.0.1]
BtdrvBluetoothPropertyType :: enum u32 {
    Name          :: 1;
    Address       :: 2;
    Unknown3      :: 3;
    ClassOfDevice :: 5;
    FeatureSet    :: 6;
}

/// AdapterPropertyType [12.0.0+]
BtdrvAdapterPropertyType :: enum u32 {
    Address       :: 0;
    Name          :: 1;
    ClassOfDevice :: 2;
    Unknown3      :: 3;
}

/// EventType
BtdrvEventType :: enum u32 {
    InquiryDevice             :: 0;
    InquiryStatus             :: 1;
    PairingPinCodeRequest     :: 2;
    SspRequest                :: 3;
    Connection                :: 4;
    Tsi                       :: 5;
    BurstMode                 :: 6;
    SetZeroRetransmission     :: 7;
    PendingConnections        :: 8;
    MoveToSecondaryPiconet    :: 9;
    BluetoothCrash            :: 10;

    Old_Unknown0              :: 0;
    Old_InquiryDevice         :: 3;
    Old_InquiryStatus         :: 4;
    Old_PairingPinCodeRequest :: 5;
    Old_SspRequest            :: 6;
    Old_Connection            :: 7;
    Old_BluetoothCrash        :: 13;
}

/// BtdrvInquiryStatus
BtdrvInquiryStatus :: enum u32 {
    Stopped :: 0;
    Started :: 1;
}

/// ConnectionEventType
BtdrvConnectionEventType :: enum u32 {
    Status            :: 0;
    SspConfirmRequest :: 1;
    Suspended         :: 2;
}

/// ExtEventType [1.0.0-11.0.1]
BtdrvExtEventType :: enum u32 {
    SetTsi                 :: 0;
    ExitTsi                :: 1;
    SetBurstMode           :: 2;
    ExitBurstMode          :: 3;
    SetZeroRetransmission  :: 4;
    PendingConnections     :: 5;
    MoveToSecondaryPiconet :: 6;
}

/// BluetoothHhReportType
/// Bit0-1 directly control the HID bluetooth transaction report-type value.
/// Bit2-3: these directly control the Parameter Reserved field for SetReport, for GetReport these control the Parameter Reserved and Size bits.
BtdrvBluetoothHhReportType :: enum u32 {
    Other   :: 0;
    Input   :: 1;
    Output  :: 2;
    Feature :: 3;
}

/// HidEventType
BtdrvHidEventType :: enum u32 {
    Connection     :: 0;
    Data           :: 1;
    SetReport      :: 2;
    GetReport      :: 3;

    Old_Connection :: 0;
    Old_Data       :: 4;
    Old_Ext        :: 7;
    Old_SetReport  :: 8;
    Old_GetReport  :: 9;
}

/// HidConnectionStatus [12.0.0+]
BtdrvHidConnectionStatus :: enum u32 {
    Closed     :: 0;
    Opened     :: 1;
    Failed     :: 2;

    Old_Opened :: 0;
    Old_Closed :: 2;
    Old_Failed :: 8;
}

/// This determines the u16 data to write into a CircularBuffer.
BtdrvFatalReason :: enum u32 {
    Invalid        :: 0;
    Unknown1       :: 1;
    CommandTimeout :: 2;
    HardwareError  :: 3;
    Enable         :: 7;
    Audio          :: 9;
}

/// BleEventType
BtdrvBleEventType :: enum u32 {
    ClientRegistration            :: 0;
    ServerRegistration            :: 1;
    ConnectionUpdate              :: 2;
    PreferredConnectionParameters :: 3;
    ClientConnection              :: 4;
    ServerConnection              :: 5;
    ScanResult                    :: 6;
    ScanFilter                    :: 7;
    ClientNotify                  :: 8;
    ClientCacheSave               :: 9;
    ClientCacheLoad               :: 10;
    ClientConfigureMtu            :: 11;
    ServerAddCharacteristic       :: 12;
    ServerWrite                   :: 13;
}

/// GattAttributeType
BtdrvGattAttributeType :: enum u32 {
    IncludedService :: 0;
    Characteristic  :: 1;
    Descriptor      :: 2;
    Service         :: 3;
}

/// GattAttributePermission
BtdrvGattAttributePermission :: enum u32 {
    Read                   :: 1;
    ReadEncrypted          :: 2;
    ReadEncryptedMitm      :: 4;
    Write                  :: 16;
    WriteEncrypted         :: 32;
    WriteEncryptedMitm     :: 64;
    WriteSigned            :: 128;
    WriteSignedMitm        :: 256;

    ReadAllowed            :: 7;
    ReadAuthRequired       :: 2;
    ReadMitmRequired       :: 4;
    ReadEncryptedRequired  :: 6;

    WriteAllowed           :: 496;
    WriteAuthRequired      :: 160;
    WriteMitmRequired      :: 320;
    WriteEncryptedRequired :: 96;
    WriteSignedRequired    :: 384;
}

/// GattCharacteristicProperty
BtdrvGattCharacteristicProperty :: enum u32 {
    Broadcast          :: 1;
    Read               :: 2;
    WriteNoResponse    :: 4;
    Write              :: 8;
    Notify             :: 16;
    Indicate           :: 32;
    Authentication     :: 64;
    ExtendedProperties :: 128;
}

/// GattAuthReqType
BtdrvGattAuthReqType :: enum u32 {
    None         :: 0;
    NoMitm       :: 1;
    Mitm         :: 2;
    SignedNoMitm :: 3;
    SignedMitm   :: 4;
}

/// AudioEventType
BtdrvAudioEventType :: enum u32 {
    None       :: 0;
    Connection :: 1;
}

/// AudioOutState
BtdrvAudioOutState :: enum u32 {
    Stopped :: 0;
    Started :: 1;
}

/// AudioCodec
BtdrvAudioCodec :: enum u32 {
    Pcm :: 0;
}

/// Address
BtdrvAddress :: struct {
    address: [6] u8; ///< Address
}

/// ClassOfDevice
BtdrvClassOfDevice :: struct {
    class_of_device: [3] u8; ///< ClassOfDevice
}

/// AdapterProperty [1.0.0-11.0.1]
BtdrvAdapterPropertyOld :: struct {
    addr:            BtdrvAddress; ///< Same as the data for ::BtdrvBluetoothPropertyType_Address.
    class_of_device: BtdrvClassOfDevice; ///< Same as the data for ::BtdrvBluetoothPropertyType_ClassOfDevice.
    name:            [249] u8; ///< Same as the data for ::BtdrvBluetoothPropertyType_Name (last byte is not initialized).
    feature_set:     u8; ///< Set to hard-coded value 0x68 (same as the data for ::BtdrvBluetoothPropertyType_FeatureSet).
}

/// AdapterProperty [12.0.0+]
BtdrvAdapterProperty :: struct {
    type: u8; ///< \ref BtdrvAdapterPropertyType
    size: u8; ///< Data size.
    data: [256] u8; ///< Data (above size), as specified by the type.
}

/// AdapterPropertySet [12.0.0+]
BtdrvAdapterPropertySet :: struct {
    addr:            BtdrvAddress; ///< Same as the data for ::BtdrvBluetoothPropertyType_Address.
    class_of_device: BtdrvClassOfDevice; ///< Same as the data for ::BtdrvBluetoothPropertyType_ClassOfDevice.
    name:            [249] u8; ///< Same as the data for ::BtdrvBluetoothPropertyType_Name.
}

/// BluetoothPinCode [1.0.0-11.0.1]
BtdrvBluetoothPinCode :: struct {
    code: [16] u8; ///< PinCode
}

/// BtdrvPinCode [12.0.0+]
BtdrvPinCode :: struct {
    code:   [16] u8; ///< PinCode
    length: u8; ///< Length 
}

/// HidData [1.0.0-8.1.1]
BtdrvHidData :: struct {
    size: u16; ///< Size of data.
    data: [640] u8; ///< Data
}

/// HidReport [9.0.0+].
BtdrvHidReport :: struct {
    size: u16; ///< Size of data.
    data: [700] u8; ///< Data
}

/// PlrStatistics
BtdrvPlrStatistics :: struct {
    unk_x0: [132] u8; ///< Unknown
}

/// PlrList
BtdrvPlrList :: struct {
    unk_x0: [164] u8; ///< Unknown
}

/// ChannelMapList
BtdrvChannelMapList :: struct {
    unk_x0: [136] u8; ///< Unknown
}

/// LeConnectionParams [5.0.0-8.1.1]
BtdrvLeConnectionParams :: struct {
    addr:              BtdrvAddress; ///< \ref BtdrvAddress
    min_conn_interval: u16; ///< Minimum connection interval
    max_conn_interval: u16; ///< Maximum connection interval
    scan_interval:     u16; ///< Scan interval
    scan_window:       u16; ///< Scan window
    slave_latency:     u16; ///< Slave latency
    supervision_tout:  u16; ///< Connection supervision timeout multiplier
    preference:        u8; ///< Unused
    pad:               u8; ///< Padding
}

/// BleConnectionParameter [9.0.0+]
BtdrvBleConnectionParameter :: struct {
    min_conn_interval: u16; ///< Minimum connection interval
    max_conn_interval: u16; ///< Maximum connection interval
    scan_interval:     u16; ///< Scan interval
    scan_window:       u16; ///< Scan window
    slave_latency:     u16; ///< Slave latency
    supervision_tout:  u16; ///< Connection supervision timeout multiplier
}

/// BtdrvBleAdvertisePacketDataEntry
BtdrvBleAdvertisePacketDataEntry :: struct {
    unk_x0: u16; ///< Unknown
    unused: [18] u8; ///< Unused
}

/// BleAdvertisePacketData
BtdrvBleAdvertisePacketData :: struct {
    unk_x0:  u32; ///< Unknown
    unk_x4:  u8; ///< Unknown
    size0:   u8; ///< Size of the data at unk_x6.
    unk_x6:  [31] u8; ///< Unknown, see size0.
    pad:     [3] u8; ///< Padding
    count:   u8; ///< Total array entries, see entries.
    pad2:    [7] u8; ///< Padding
    entries: [5] BtdrvBleAdvertisePacketDataEntry; ///< \ref BtdrvBleAdvertisePacketDataEntry
    pad3:    [16] u8; ///< Padding
    size2:   u8; ///< Size of the data at unk_xA8.
    unk_xA5: u8; ///< Unknown
    pad4:    [2] u8; ///< Padding
    unk_xA8: [31] u8; ///< Unknown, see size2.
    unk_xC7: u8; ///< Unknown
    unk_xC8: u8; ///< Unknown
    pad5:    [3] u8; ///< Padding
}

/// BleAdvertisement
BtdrvBleAdvertisement :: struct {
    size: u8; ///< Size of data below.
    type: u8; ///< \ref BtdrvAdType
    data: [29] u8; ///< Advertisement data
}

/// BleAdvertiseFilter
BtdrvBleAdvertiseFilter :: struct {
    index:     u8; ///< Filter index
    adv:       BtdrvBleAdvertisement; ///< \ref BtdrvBleAdvertisement
    mask:      [29] u8; ///< Mask for advertisement data above
    mask_size: u8; ///< Size of mask above.
}

/// BleAdvertisePacketParameter
BtdrvBleAdvertisePacketParameter :: struct {
    company_id:   u16;
    pattern_data: [6] u8;
}

/// BleScanResult
BtdrvBleScanResult :: struct {
    unk_x0:   u8; ///< Unknown
    addr:     BtdrvAddress; ///< \ref BtdrvAddress
    unk_x7:   [313] u8; ///< Unknown
    count:    s32; ///< Unknown
    unk_x144: s32; ///< Unknown
}

/// BleConnectionInfo
BtdrvBleConnectionInfo :: struct {
    connection_handle: u32; ///< ConnectionHandle, 0xFFFFFFFF ([5.0.0-5.0.2] 0xFFFF) is invalid.
    addr:              BtdrvAddress; ///< \ref BtdrvAddress
    pad:               [2] u8; ///< Padding
}

/// GattAttributeUuid
BtdrvGattAttributeUuid :: struct {
    size: u32; ///< UUID size, must be 0x2, 0x4, or 0x10.
    uuid: [16] u8; ///< UUID with the above size.
}

/// GattId
BtdrvGattId :: struct {
    instance_id: u8; ///< InstanceId
    pad:         [3] u8; ///< Padding
    uuid:        BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
}

/// GattAttribute
BtdrvGattAttribute :: struct {
    id:               BtdrvGattId; ///< \ref BtdrvGattId
    type:             u16; ///< \ref BtdrvGattAttributeType
    handle:           u16;
    group_end_handle: u16;
    property:         u8; ///< Only used when type is characteristic. \ref BtdrvGattCharacteristicProperty
    is_primary:       bool; ///< Only used when type is service
}

/// LeEventInfo
BtdrvLeEventInfo :: struct {
    unk_x0: u32; ///< Unknown
    unk_x4: u32; ///< Unknown
    unk_x8: u8; ///< Unknown
    pad:    [3] u8; ///< Padding
    uuid0:  BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    uuid1:  BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    uuid2:  BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    size:   u16; ///< Size of the below data.
    data:   [950] u8; ///< Data.
}

/// BleClientGattOperationInfo
BtdrvBleClientGattOperationInfo :: struct {
    unk_x0: u8; ///< Converted from BtdrvLeEventInfo::unk_x0.
    pad:    [3] u8; ///< Padding
    unk_x4: u32; ///< BtdrvLeEventInfo::unk_x4
    unk_x8: u8; ///< BtdrvLeEventInfo::unk_x8
    pad2:   [3] u8; ///< Padding
    uuid0:  BtdrvGattAttributeUuid; ///< BtdrvLeEventInfo::uuid0
    uuid1:  BtdrvGattAttributeUuid; ///< BtdrvLeEventInfo::uuid1
    uuid2:  BtdrvGattAttributeUuid; ///< BtdrvLeEventInfo::uuid2
    size:   u64; ///< BtdrvLeEventInfo::size
    data:   [512] u8; ///< BtdrvLeEventInfo::data
}

/// PcmParameter
BtdrvPcmParameter :: struct {
    unk_x0:          u32; ///< Must be 0-3. Controls number of channels: 0 = mono, non-zero = stereo.
    sample_rate:     s32; ///< Sample rate. Must be one of the following: 16000, 32000, 44100, 48000.
    bits_per_sample: u32; ///< Bits per sample. Must be 8 or 16.
}

/// AudioControlButtonState
BtdrvAudioControlButtonState :: struct {
    unk_x0: [16] u8; ///< Unknown
}

/// BtmState
BtmState :: enum u32 {
    NotInitialized     :: 0;
    RadioOff           :: 1;
    MinorSlept         :: 2;
    RadioOffMinorSlept :: 3;
    Slept              :: 4;
    RadioOffSlept      :: 5;
    Initialized        :: 6;
    Working            :: 7;
}

/// BluetoothMode
BtmBluetoothMode :: enum u32 {
    Dynamic2Slot :: 0;
    StaticJoy    :: 1;
}

/// WlanMode
BtmWlanMode :: enum u32 {
    Local4 :: 0;
    Local8 :: 1;
    None   :: 2;
}

/// TsiMode
BtmTsiMode :: enum u32 {
    _0Fd3Td3Si10  :: 0;
    _1Fd1Td1Si5   :: 1;
    _2Fd1Td3Si10  :: 2;
    _3Fd1Td5Si15  :: 3;
    _4Fd3Td1Si10  :: 4;
    _5Fd3Td3Si15  :: 5;
    _6Fd5Td1Si15  :: 6;
    _7Fd1Td3Si15  :: 7;
    _8Fd3Td1Si15  :: 8;
    _9Fd1Td1Si10  :: 9;
    _10Fd1Td1Si15 :: 10;
    Active        :: 255;
}

/// SlotMode
BtmSlotMode :: enum u32 {
    _2     :: 0;
    _4     :: 1;
    _6     :: 2;
    Active :: 3;
}

/// Profile
BtmProfile :: enum u32 {
    None :: 0;
    Hid  :: 1;
}

/// BdName
BtmBdName :: struct {
    name: [32] u8; ///< Name string.
}

/// ClassOfDevice
BtmClassOfDevice :: struct {
    class_of_device: [3] u8; ///< ClassOfDevice
}

/// LinkKey
BtmLinkKey :: struct {
    link_key: [16] u8; ///< LinkKey
}

/// HidDeviceInfo
BtmHidDeviceInfo :: struct {
    vid: u16; ///< Vid
    pid: u16; ///< Pid
}

/// HostDeviceProperty
BtmHostDeviceProperty :: struct {
    union {
        v1:  struct {
            addr:            BtdrvAddress; ///< Same as BtdrvAdapterProperty::addr.
            class_of_device: BtmClassOfDevice; ///< Same as BtdrvAdapterProperty::class_of_device.
            name:            BtmBdName; ///< Same as BtdrvAdapterProperty::name (except the last byte which is always zero).
            feature_set:     u8; ///< Same as BtdrvAdapterProperty::feature_set.
        }; ///< [1.0.0-12.1.0]

        v13: struct {
            addr:            BtdrvAddress; ///< Same as BtdrvAdapterProperty::addr.
            class_of_device: BtmClassOfDevice; ///< Same as BtdrvAdapterProperty::class_of_device.
            name:            [249] u8; ///< Same as BtdrvAdapterProperty::name (except the last byte which is always zero).
            feature_set:     u8; ///< Same as BtdrvAdapterProperty::feature_set.
        }; ///< [13.0.0+]
    }
}

/// BtmConnectedDevice [1.0.0-12.1.0]
BtmConnectedDeviceV1 :: struct {
    address: BtdrvAddress;
    pad:     [2] u8;
    unk_x8:  u32;
    name:    [32] u8;
    unk_x2C: [28] u8;
    vid:     u16;
    pid:     u16;
    unk_x4C: [32] u8;
}

/// BtmConnectedDevice [13.0.0+]
BtmConnectedDeviceV13 :: struct {
    address: BtdrvAddress;
    pad:     [2] u8;
    profile: u32; ///< \ref BtmProfile
    unk_xC:  [64] u8;
    name:    [32] u8;
    unk_x6C: [217] u8;
    pad2:    [3] u8;
}

/// DeviceCondition [1.0.0-5.0.2]
BtmDeviceConditionV100 :: struct {
    unk_x0:          u32;
    unk_x4:          u32;
    unk_x8:          u8;
    unk_x9:          u8;
    max_count:       u8;
    connected_count: u8;
    devices:         [8] BtmConnectedDeviceV1;
}

/// DeviceCondition [5.1.0-7.0.1]
BtmDeviceConditionV510 :: struct {
    unk_x0:          u32;
    unk_x4:          u32;
    unk_x8:          u8;
    unk_x9:          [2] u8;
    max_count:       u8;
    connected_count: u8;
    pad:             [3] u8;
    devices:         [8] BtmConnectedDeviceV1;
}

/// DeviceCondition [8.0.0-8.1.1]
BtmDeviceConditionV800 :: struct {
    unk_x0:          u32;
    unk_x4:          u32;
    unk_x8:          u8;
    unk_x9:          u8;
    max_count:       u8;
    connected_count: u8;
    devices:         [8] BtmConnectedDeviceV1;
}

/// DeviceCondition [9.0.0-12.1.0]
BtmDeviceConditionV900 :: struct {
    unk_x0:          u32;
    unk_x4:          u8;
    unk_x5:          u8;
    max_count:       u8;
    connected_count: u8;
    devices:         [8] BtmConnectedDeviceV1;
}

/// DeviceCondition [1.0.0-12.1.0]
BtmDeviceCondition :: union {
    v100: BtmDeviceConditionV100;
    v510: BtmDeviceConditionV510;
    v800: BtmDeviceConditionV800;
    v900: BtmDeviceConditionV900;
}

/// DeviceSlotMode
BtmDeviceSlotMode :: struct {
    addr:      BtdrvAddress; ///< \ref BtdrvAddress
    reserved:  [2] u8; ///< Reserved
    slot_mode: u32; ///< \ref BtmSlotMode
}

/// DeviceSlotModeList
BtmDeviceSlotModeList :: struct {
    device_count: u8; ///< DeviceCount
    reserved:     [3] u8; ///< Reserved
    devices:      [8] BtmDeviceSlotMode; ///< Array of \ref BtmDeviceSlotMode with the above count.
}

/// DeviceInfo [1.0.0-12.1.0]
BtmDeviceInfoV1 :: struct {
    addr:            BtdrvAddress; ///< \ref BtdrvAddress
    class_of_device: BtmClassOfDevice; ///< ClassOfDevice
    name:            BtmBdName; ///< BdName
    link_key:        BtmLinkKey; ///< LinkKey
    reserved:        [3] u8; ///< Reserved
    profile:         u32; ///< \ref BtmProfile
    profile_info:    union {
        data:            [4] u8; ///< Empty (Profile = None)
        hid_device_info: BtmHidDeviceInfo; ///< \ref BtmHidDeviceInfo (Profile = Hid)
    };

    reserved2:       [28] u8; ///< Reserved
}

/// DeviceInfo [13.0.0+]
BtmDeviceInfoV13 :: struct {
    addr:            BtdrvAddress; ///< \ref BtdrvAddress
    class_of_device: BtmClassOfDevice; ///< ClassOfDevice
    link_key:        BtmLinkKey; ///< LinkKey
    reserved:        [3] u8; ///< Reserved
    profile:         u32; ///< \ref BtmProfile
    profile_info:    union {
        data:            [4] u8; ///< Empty (Profile = None)
        hid_device_info: BtmHidDeviceInfo; ///< \ref BtmHidDeviceInfo (Profile = Hid)
    };

    reserved2:       [28] u8; ///< Reserved
    name:            [249] u8; ///< Name
    pad:             [3] u8; ///< Padding
}

/// DeviceInfo [1.0.0-13.0.0]
BtmDeviceInfo :: union {
    v1:  BtmDeviceInfoV1;
    v13: BtmDeviceInfoV13;
}

/// DeviceInfoList
BtmDeviceInfoList :: struct {
    device_count: u8; ///< DeviceCount
    reserved:     [3] u8; ///< Reserved
    devices:      [10] BtmDeviceInfoV1; ///< Array of \ref BtmDeviceInfoV1 with the above count.
}

/// DeviceProperty
BtmDeviceProperty :: struct {
    addr:            BtdrvAddress; ///< \ref BtdrvAddress
    class_of_device: BtmClassOfDevice; ///< ClassOfDevice
    name:            BtmBdName; ///< BdName
}

/// DevicePropertyList
BtmDevicePropertyList :: struct {
    device_count: u8; ///< DeviceCount
    devices:      [15] BtmDeviceProperty; ///< Array of \ref BtmDeviceProperty.
}

/// ZeroRetransmissionList
BtmZeroRetransmissionList :: struct {
    enabled_report_id_count: u8; ///< EnabledReportIdCount
    enabled_report_id:       [16] u8; ///< Array of EnabledReportId.
}

/// GattClientConditionList
BtmGattClientConditionList :: struct {
    unk_x0: [116] u8; ///< Unknown
}

/// GattService
BtmGattService :: struct {
    unk_x0:           [4] u8; ///< Unknown
    uuid:             BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    handle:           u16; ///< Handle
    unk_x1A:          [2] u8; ///< Unknown
    instance_id:      u16; ///< InstanceId
    end_group_handle: u16; ///< EndGroupHandle
    primary_service:  u8; ///< PrimaryService
    pad:              [3] u8; ///< Padding
}

/// GattCharacteristic
BtmGattCharacteristic :: struct {
    unk_x0:      [4] u8; ///< Unknown
    uuid:        BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    handle:      u16; ///< Handle
    unk_x1A:     [2] u8; ///< Unknown
    instance_id: u16; ///< InstanceId
    properties:  u8; ///< Properties
    unk_x1F:     [5] u8; ///< Unknown
}

/// GattDescriptor
BtmGattDescriptor :: struct {
    unk_x0:  [4] u8; ///< Unknown
    uuid:    BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    handle:  u16; ///< Handle
    unk_x1A: [6] u8; ///< Unknown
}

/// BleDataPath
BtmBleDataPath :: struct {
    unk_x0: u8; ///< Unknown
    pad:    [3] u8; ///< Padding
    uuid:   BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
}

ColorSetId :: enum u32 {
    Light :: 0;
    Dark  :: 1;
}

/// Console Product Models
SetSysProductModel :: enum u32 {
    Invalid :: 0;
    Nx      :: 1;
    Copper  :: 2;
    Iowa    :: 3;
    Hoag    :: 4;
    Calcio  :: 5;
    Aula    :: 6;
}

/// IDs for Language.
SetLanguage :: enum u32 {
    JA     :: 0;
    ENUS   :: 1;
    FR     :: 2;
    DE     :: 3;
    IT     :: 4;
    ES     :: 5;
    ZHCN   :: 6;
    KO     :: 7;
    NL     :: 8;
    PT     :: 9;
    RU     :: 10;
    ZHTW   :: 11;
    ENGB   :: 12;
    FRCA   :: 13;
    ES419  :: 14;
    ZHHANS :: 15;
    ZHHANT :: 16;
    PTBR   :: 17;
    Total  :: 18;
}

/// Region codes.
SetRegion :: enum u32 {
    JPN :: 0;
    USA :: 1;
    EUR :: 2;
    AUS :: 3;
    HTK :: 4;
    CHN :: 5;
}

/// ConnectionFlag
SetSysConnectionFlag :: enum u32 {
    ConnectAutomaticallyFlag :: 1;
    Unknown                  :: 2;
}

/// AccessPointSecurityType
SetSysAccessPointSecurityType :: enum u32 {
    None   :: 0;
    Shared :: 1;
    Wpa    :: 2;
    Wpa2   :: 3;
}

/// AccessPointSecurityStandard
SetSysAccessPointSecurityStandard :: enum u32 {
    None :: 0;
    Wep  :: 1;
    Wpa  :: 2;
}

/// AutoSettings
SetSysAutoSettings :: enum u32 {
    AutoIp  :: 1;
    AutoDns :: 2;
}

/// ProxyFlags
SetSysProxyFlags :: enum u32 {
    UseProxyFlag              :: 1;
    ProxyAutoAuthenticateFlag :: 2;
}

/// UserSelectorFlag
SetSysUserSelectorFlag :: enum u32 {
    SkipsIfSingleUser :: 1;
}

/// EulaVersionClockType
SetSysEulaVersionClockType :: enum u32 {
    NetworkSystemClock :: 0;
    SteadyClock        :: 1;
}

/// NotificationVolume
SetSysNotificationVolume :: enum u32 {
    Mute :: 0;
    Low  :: 1;
    High :: 2;
}

/// FriendPresenceOverlayPermission
SetSysFriendPresenceOverlayPermission :: enum u32 {
    NotConfirmed    :: 0;
    NoDisplay       :: 1;
    FavoriteFriends :: 2;
    Friends         :: 3;
}

/// AudioDevice
SetSysAudioDevice :: enum u32 {
    Console   :: 0;
    Headphone :: 1;
    Tv        :: 2;
}

/// PrimaryAlbumStorage
SetSysPrimaryAlbumStorage :: enum u32 {
    Nand   :: 0;
    SdCard :: 1;
}

/// HandheldSleepPlan
SetSysHandheldSleepPlan :: enum u32 {
    _1Min  :: 0;
    _3Min  :: 1;
    _5Min  :: 2;
    _10Min :: 3;
    _30Min :: 4;
    Never  :: 5;
}

/// ConsoleSleepPlan
SetSysConsoleSleepPlan :: enum u32 {
    _1Hour  :: 0;
    _2Hour  :: 1;
    _3Hour  :: 2;
    _6Hour  :: 3;
    _12Hour :: 4;
    Never   :: 5;
}

/// AudioOutputModeTarget
SetSysAudioOutputModeTarget :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
    Unknown2 :: 2;
    Unknown3 :: 3;
}

/// AudioOutputMode
SetSysAudioOutputMode :: enum u32 {
    Unknown1 :: 1;
}

/// ServiceDiscoveryControlSettings
SetSysServiceDiscoveryControlSettings :: enum u32 {
    IsChangeEnvironmentIdentifierDisabled :: 1;
}

/// ErrorReportSharePermission
SetSysErrorReportSharePermission :: enum u32 {
    NotConfirmed :: 0;
    Granted      :: 1;
    Denied       :: 2;
}

/// KeyboardLayout
SetKeyboardLayout :: enum u32 {
    Japanese               :: 0;
    EnglishUs              :: 1;
    EnglishUsInternational :: 2;
    EnglishUk              :: 3;
    French                 :: 4;
    FrenchCa               :: 5;
    Spanish                :: 6;
    SpanishLatin           :: 7;
    German                 :: 8;
    Italian                :: 9;
    Portuguese             :: 10;
    Russian                :: 11;
    Korean                 :: 12;
    ChineseSimplified      :: 13;
    ChineseTraditional     :: 14;
}

/// ChineseTraditionalInputMethod
SetChineseTraditionalInputMethod :: enum u32 {
    Unknown1 :: 1;
    Unknown2 :: 2;
}

/// PtmCycleCountReliability
SetSysPtmCycleCountReliability :: enum u32 {
    Default :: 0;
    Unk     :: 1;
}

/// PlatformRegion. Other values not listed here should be handled as "Unknown".
SetSysPlatformRegion :: enum u32 {
    Global :: 1;
    China  :: 2;
}

/// TouchScreenMode, for "Touch-Screen Sensitivity".
SetSysTouchScreenMode :: enum u32 {
    Stylus   :: 0;
    Standard :: 1;
}

/// BlockType
SetSysBlockType :: enum u32 {
    Audio          :: 1;
    Video          :: 2;
    VendorSpecific :: 3;
    Speaker        :: 4;
}

/// ControllerType
SetSysControllerType :: enum u32 {
    JoyConR :: 1;
    JoyConL :: 2;
    ProCon  :: 3;
}

/// BatteryLot
SetBatteryLot :: struct {
    lot: [24] u8; ///< BatteryLot string.
}

/// NetworkSettings
SetSysNetworkSettings :: struct {
    name:                           [64] u8;
    uuid:                           Uuid;
    connection_flags:               u32; ///< Bitmask with \ref SetSysConnectionFlag.
    wired_flag:                     u32;
    connect_to_hidden_network:      u32; ///< Bitmask with UseStealthNetworkFlag.
    access_point_ssid:              [32] u8;
    access_point_ssid_len:          u32;
    access_point_security_type:     u32; ///< Bitmask with \ref SetSysAccessPointSecurityType.
    access_point_security_standard: u32; ///< Bitmask with \ref SetSysAccessPointSecurityStandard.
    access_point_passphrase:        [64] u8;
    access_point_passphrase_len:    u32;
    auto_settings:                  u32; ///< Bitmask with \ref SetSysAutoSettings.
    manual_ip_address:              u32;
    manual_subnet_mask:             u32;
    manual_gateway:                 u32;
    primary_dns:                    u32;
    secondary_dns:                  u32;
    proxy_flags:                    u32; ///< Bitmask with \ref SetSysProxyFlags.
    proxy_server:                   [128] u8;
    proxy_port:                     u16;
    padding1:                       u16;
    proxy_autoauth_user:            [32] u8;
    proxy_autoauth_pass:            [32] u8;
    mtu:                            u16;
    padding2:                       u16;
}

/// LcdBacklightBrightnessMapping
SetSysLcdBacklightBrightnessMapping :: struct {
    brightness_applied_to_backlight: float;
    ambient_light_sensor_value:      float;
    unk_x8:                          float;
}

/// BacklightSettings
SetSysBacklightSettings :: struct {
    auto_brightness_flags: u32;
    screen_brightness:     float;
    brightness_mapping:    SetSysLcdBacklightBrightnessMapping;
    unk_x14:               float;
    unk_x18:               float;
    unk_x1C:               float;
    unk_x20:               float;
    unk_x24:               float;
}

/// BacklightSettingsEx
SetSysBacklightSettingsEx :: struct {
    auto_brightness_flags:          u32;
    screen_brightness:              float;
    current_brightness_for_vr_mode: float;
    brightness_mapping:             SetSysLcdBacklightBrightnessMapping;
    unk_x18:                        float;
    unk_x1C:                        float;
    unk_x20:                        float;
    unk_x24:                        float;
    unk_x28:                        float;
}

/// BluetoothDevicesSettings
SetSysBluetoothDevicesSettings :: struct {
    addr:              BtdrvAddress; ///< \ref BtdrvAddress
    name:              BtmBdName; ///< BdName. Unused on 13.0.0+
    class_of_device:   BtmClassOfDevice; ///< ClassOfDevice
    link_key:          [16] u8; ///< LinkKey
    link_key_present:  u8; ///< LinkKeyPresent
    version:           u16; ///< Version
    trusted_services:  u32; ///< TrustedServices
    vid:               u16; ///< Vid
    pid:               u16; ///< Pid
    sub_class:         u8; ///< SubClass
    attribute_mask:    u8; ///< AttributeMask
    descriptor_length: u16; ///< DescriptorLength
    descriptor:        [128] u8; ///< Descriptor
    key_type:          u8; ///< KeyType
    device_type:       u8; ///< DeviceType
    brr_size:          u16; ///< BrrSize
    brr:               [9] u8; ///< Brr
    union {
        reserved: [299] u8; ///< Reserved [1.0.0-12.1.0]

        struct {
            pad:   u8; ///< Padding
            name2: [249] u8; ///< Name
        }
    }
}

/// Structure returned by \ref setsysGetFirmwareVersion.
SetSysFirmwareVersion :: struct {
    major:           u8;
    minor:           u8;
    micro:           u8;
    padding1:        u8;
    revision_major:  u8;
    revision_minor:  u8;
    padding2:        u8;
    padding3:        u8;
    platform:        [32] u8;
    version_hash:    [64] u8;
    display_version: [24] u8;
    display_title:   [128] u8;
}

/// Structure returned by \ref setsysGetFirmwareVersionDigest.
SetSysFirmwareVersionDigest :: struct {
    digest: [64] u8;
}

/// Structure returned by \ref setsysGetSerialNumber.
SetSysSerialNumber :: struct {
    number: [24] u8;
}

/// DeviceNickName
SetSysDeviceNickName :: struct {
    nickname: [128] u8;
}

/// UserSelectorSettings
SetSysUserSelectorSettings :: struct {
    flags: u32; ///< Bitmask with \ref SetSysUserSelectorFlag.
}

/// AccountSettings
SetSysAccountSettings :: struct {
    settings: SetSysUserSelectorSettings;
}

SetSysAudioVolume :: struct {
    unk_x0: u32; ///< 0 for Console and Tv, 2 for Headphones.
    volume: u8; ///< From 0-15.
}

/// EulaVersion
SetSysEulaVersion :: struct {
    version:            u32;
    region_code:        s32;
    clock_type:         s32; ///< \ref SetSysEulaVersionClockType
    pad:                u32;
    network_clock_time: u64; ///< POSIX timestamp.
    steady_clock_time:  TimeSteadyClockTimePoint; ///< \ref TimeSteadyClockTimePoint
}

/// NotificationTime
SetSysNotificationTime :: struct {
    hour:   s32;
    minute: s32;
}

/// NotificationSettings
SetSysNotificationSettings :: struct {
    flags:      u32; ///< Bitmask with NotificationFlag.
    volume:     s32; ///< \ref SetSysNotificationVolume
    start_time: SetSysNotificationTime; ///< \ref SetSysNotificationTime
    end_time:   SetSysNotificationTime; ///< \ref SetSysNotificationTime
}

/// AccountNotificationSettings
SetSysAccountNotificationSettings :: struct {
    uid:                                AccountUid; ///< \ref AccountUid
    flags:                              u32; ///< Bitmask with AccountNotificationFlag.
    friend_presence_overlay_permission: s8; ///< \ref SetSysFriendPresenceOverlayPermission
    pad:                                [3] u8; ///< Padding.
}

/// TvSettings
SetSysTvSettings :: struct {
    flags:             u32; ///< Bitmask with TvFlag.
    tv_resolution:     s32; ///< \ref SetSysTvResolution
    hdmi_content_type: s32; ///< \ref SetSysHdmiContentType
    rgb_range:         s32; ///< \ref SetSysRgbRange
    cmu_mode:          s32; ///< \ref SetSysCmuMode
    underscan:         u32; ///< Underscan.
    gamma:             float; ///< Gamma.
    contrast:          float; ///< Contrast.
}

SetSysDataBlock :: struct {
    video:           struct {
        size:       u8;
        #place size; /*bitfield 5*/ block_type: u8;
        svd:        [12] struct {
            svd_index:   u8;
            #place svd_index; /*bitfield 7*/ native_flag: u8;
        };
    };

    audio:           struct {
        size:                  u8;
        #place size; /*bitfield 5*/ block_type:            u8;
        channel_count:         u8;
        #place channel_count; /*bitfield 3*/ format_code:           u8;
        #place channel_count; /*bitfield 7*/ padding1:              u8;
        sampling_rates_bitmap: u8;
        bitrate:               u8;
    };

    vendor_specific: struct {
        size:                    u8;
        #place size; /*bitfield 5*/ block_type:              u8;
        ieee_registration_id:    [3] u8;
        source_physical_address: u16;
        mode_bitmap:             u8;
        max_tmds_frequency:      u8;
        latency_bitmap:          u8;
    } #align 1;

    padding:         [2] u8;
}

/// DataDeletionSettings
SetSysDataDeletionSettings :: struct {
    flags:     u32; ///< Bitmask with DataDeletionFlag.
    use_count: s32; ///< Use count.
}

/// SleepSettings
SetSysSleepSettings :: struct {
    flags:               u32; ///< Bitmask with SleepFlag.
    handheld_sleep_plan: s32; ///< \ref SetSysHandheldSleepPlan
    console_sleep_plan:  s32; ///< \ref SetSysConsoleSleepPlan
}

/// InitialLaunchSettings
SetSysInitialLaunchSettings :: struct {
    flags:     u32; ///< Bitmask with InitialLaunchFlag.
    pad:       u32; ///< Padding.
    timestamp: TimeSteadyClockTimePoint; ///< \ref TimeSteadyClockTimePoint timestamp.
}

/// PtmFuelGaugeParameter
SetSysPtmFuelGaugeParameter :: struct {
    rcomp0:        u16;
    tempc0:        u16;
    fullcap:       u16;
    fullcapnom:    u16;
    lavgempty:     u16;
    qresidual00:   u16;
    qresidual10:   u16;
    qresidual20:   u16;
    qresidual30:   u16;
    cycles:        u16; ///< Normally keeps the cycles reg. Unused and contains stack garbage.
    cycles_actual: u32; ///< Keeps track of cycles. The fuel gauge cycles reg is reset if > 2.00 cycles and added here.
}

/// Actually nn::util::Color4u8Type.
SetSysColor4u8Type :: struct {
    field: [4] u8;
}

/// NxControllerLegacySettings
SetSysNxControllerLegacySettings :: struct {
    address:        BtdrvAddress;
    type:           u8; ///< \ref SetSysControllerType.
    serial:         [16] u8;
    body_color:     SetSysColor4u8Type;
    button_color:   SetSysColor4u8Type;
    unk_x1F:        [8] u8;
    unk_x27:        u8;
    interface_type: u8; ///< Bitmask with \ref XcdInterfaceType.
}

/// NxControllerSettings
SetSysNxControllerSettings :: struct {
    address:        BtdrvAddress;
    type:           u8; ///< \ref SetSysControllerType.
    serial:         [16] u8;
    body_color:     SetSysColor4u8Type;
    button_color:   SetSysColor4u8Type;
    unk_x1F:        [8] u8;
    unk_x27:        u8;
    interface_type: u8; ///< Bitmask with \ref XcdInterfaceType.
    unk_x29:        [1027] u8; ///< Unknown
}

/// ConsoleSixAxisSensorAccelerationBias
SetSysConsoleSixAxisSensorAccelerationBias :: struct {
    unk_x0: float;
    unk_x4: float;
    unk_x8: float;
}

/// ConsoleSixAxisSensorAngularVelocityBias
SetSysConsoleSixAxisSensorAngularVelocityBias :: struct {
    unk_x0: float;
    unk_x4: float;
    unk_x8: float;
}

/// ConsoleSixAxisSensorAccelerationGain
SetSysConsoleSixAxisSensorAccelerationGain :: struct {
    unk_x0:  float;
    unk_x4:  float;
    unk_x8:  float;
    unk_xC:  float;
    unk_x10: float;
    unk_x14: float;
    unk_x18: float;
    unk_x1C: float;
    unk_x20: float;
}

/// ConsoleSixAxisSensorAngularVelocityGain
SetSysConsoleSixAxisSensorAngularVelocityGain :: struct {
    unk_x0:  float;
    unk_x4:  float;
    unk_x8:  float;
    unk_xC:  float;
    unk_x10: float;
    unk_x14: float;
    unk_x18: float;
    unk_x1C: float;
    unk_x20: float;
}

/// AllowedSslHosts
SetSysAllowedSslHosts :: struct {
    hosts: [256] u8;
}

/// HostFsMountPoint
SetSysHostFsMountPoint :: struct {
    mount: [256] u8;
}

/// BlePairingSettings
SetSysBlePairingSettings :: struct {
    address: BtdrvAddress;
    unk_x6:  u16;
    unk_x8:  u16;
    unk_xA:  u8;
    unk_xB:  u8;
    unk_xC:  u8;
    unk_xD:  u8;
    unk_xE:  u8;
    unk_xF:  u8;
    padding: [112] u8;
}

/// ConsoleSixAxisSensorAngularVelocityTimeBias
SetSysConsoleSixAxisSensorAngularVelocityTimeBias :: struct {
    unk_x0: float;
    unk_x4: float;
    unk_x8: float;
}

/// ConsoleSixAxisSensorAngularAcceleration
SetSysConsoleSixAxisSensorAngularAcceleration :: struct {
    unk_x0:  float;
    unk_x4:  float;
    unk_x8:  float;
    unk_xC:  float;
    unk_x10: float;
    unk_x14: float;
    unk_x18: float;
    unk_x1C: float;
    unk_x20: float;
}

/// RebootlessSystemUpdateVersion. This is the content of the RebootlessSystemUpdateVersion SystemData, in the "/version" file.
SetSysRebootlessSystemUpdateVersion :: struct {
    version:         u32;
    reserved:        [28] u8;
    display_version: [32] u8;
}

/// AccountOnlineStorageSettings
SetSysAccountOnlineStorageSettings :: struct {
    uid:     AccountUid; ///< \ref AccountUid
    unk_x10: u32;
    unk_x14: u32;
}

/// AnalogStickUserCalibration
SetSysAnalogStickUserCalibration :: struct {
    unk_x0: u16;
    unk_x2: u16;
    unk_x4: u16;
    unk_x6: u16;
    unk_x8: u16;
    unk_xA: u16;
    unk_xC: u16;
    unk_xE: u16;
}

/// ThemeId
SetSysThemeId :: struct {
    theme_id: [16] u64;
}

/// ThemeSettings
SetSysThemeSettings :: struct {
    theme_settings: u64;
}

/// Output from \ref setsysGetHomeMenuScheme. This contains RGBA8 colors which correspond with the physical shell of the system.
SetSysHomeMenuScheme :: struct {
    main_color:  u32; ///< Main Color.
    back_color:  u32; ///< Back Color.
    sub_color:   u32; ///< Sub Color.
    bezel_color: u32; ///< Bezel Color.
    extra_color: u32; ///< Extra Color.
}

/// ButtonConfigSettings
SetSysButtonConfigSettings :: struct {
    settings: [1448] u8;
}

/// ButtonConfigRegisteredSettings
SetSysButtonConfigRegisteredSettings :: struct {
    settings: [1480] u8;
}

SetCalAccelerometerOffset :: struct {
    offset: [6] u8;
}

SetCalAccelerometerScale :: struct {
    scale: [6] u8;
}

SetCalAmiiboEcdsaCertificate :: struct {
    size: u32;
    cert: [112] u8;
}

SetCalAmiiboEcqvBlsCertificate :: struct {
    size: u32;
    cert: [32] u8;
}

SetCalAmiiboEcqvBlsKey :: struct {
    size:       u32;
    key:        [64] u8;
    generation: u32;
}

SetCalAmiiboEcqvBlsRootCertificate :: struct {
    size: u32;
    cert: [144] u8;
}

SetCalAmiiboEcqvCertificate :: struct {
    size: u32;
    cert: [20] u8;
}

SetCalAmiiboKey :: struct {
    size:       u32;
    key:        [80] u8;
    generation: u32;
}

SetCalAnalogStickFactoryCalibration :: struct {
    calibration: [9] u8;
}

SetCalAnalogStickModelParameter :: struct {
    parameter: [18] u8;
}

SetCalBdAddress :: struct {
    bd_addr: [6] u8;
}

SetCalConfigurationId1 :: struct {
    cfg: [30] u8;
}

SetCalConsoleSixAxisSensorHorizontalOffset :: struct {
    offset: [6] u8;
}

SetCalCountryCode :: struct {
    code: [3] u8; ///< Country code.
}

SetCalEccB233DeviceCertificate :: struct {
    cert: [384] u8;
}

SetCalEccB233DeviceKey :: struct {
    size:       u32;
    key:        [80] u8;
    generation: u32;
}

SetCalGameCardCertificate :: struct {
    cert: [1024] u8;
}

SetCalGameCardKey :: struct {
    size:       u32; ///< Size of the entire key.
    key:        [304] u8;
    generation: u32;
}

SetCalGyroscopeOffset :: struct {
    offset: [6] u8;
}

SetCalGyroscopeScale :: struct {
    scale: [6] u8;
}

SetCalMacAddress :: struct {
    addr: [6] u8; ///< Mac address.
}

SetCalRsa2048DeviceCertificate :: struct {
    cert: [576] u8;
}

SetCalRsa2048DeviceKey :: struct {
    size:       u32; ///< Size of the entire key.
    key:        [576] u8;
    generation: u32;
}

SetCalSerialNumber :: SetSysSerialNumber;

SetCalSpeakerParameter :: struct {
    parameter: [90] u8;
}

SetCalSslCertificate :: struct {
    size: u32; ///< Size of the certificate data.
    cert: [2048] u8;
}

SetCalSslKey :: struct {
    size:       u32; ///< Size of the entire key.
    key:        [304] u8;
    generation: u32;
}

SetCalRegionCode :: struct {
    code: u32; ///< Region code.
}

/// Initialize set.
setInitialize :: () -> Result #foreign libnx;

/// Exit set.
setExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual set service session.
setGetServiceSession :: () -> *Service #foreign libnx;

/// Converts LanguageCode to \ref SetLanguage.
setMakeLanguage :: (LanguageCode: u64, Language: *SetLanguage) -> Result #foreign libnx;

/// Converts \ref SetLanguage to LanguageCode.
setMakeLanguageCode :: (Language: SetLanguage, LanguageCode: *u64) -> Result #foreign libnx;

/// Gets the current system LanguageCode.
/// Normally this should be used instead of \ref setGetLanguageCode.
/// LanguageCode is a string, see here: https://switchbrew.org/wiki/Settings_services#LanguageCode
setGetSystemLanguage :: (LanguageCode: *u64) -> Result #foreign libnx;

/// Gets the current LanguageCode, \ref setGetSystemLanguage should be used instead normally.
setGetLanguageCode :: (LanguageCode: *u64) -> Result #foreign libnx;

/// Gets available LanguageCodes.
/// On system-version <4.0.0, max_entries is set to the output from \ref setGetAvailableLanguageCodeCount if max_entries is larger than that.
setGetAvailableLanguageCodes :: (total_entries: *s32, LanguageCodes: *u64, max_entries: u64) -> Result #foreign libnx;

/// Gets total available LanguageCodes.
/// Output total is overridden with value 0 if the total is <0.
setGetAvailableLanguageCodeCount :: (total: *s32) -> Result #foreign libnx;

/// Gets the RegionCode.
setGetRegionCode :: (out: *SetRegion) -> Result #foreign libnx;

/**
* @brief GetQuestFlag
* @note Only available on [5.0.0+].
* @param[out] out Output flag.
*/
setGetQuestFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the system's nickname.
* @note Only available on [10.1.0+].
* @param[out] nickname \ref SetSysDeviceNickName
*/
setGetDeviceNickname :: (nickname: *SetSysDeviceNickName) -> Result #foreign libnx;

/// Initialize setsys.
setsysInitialize :: () -> Result #foreign libnx;

/// Exit setsys.
setsysExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual setsys service session.
setsysGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief SetLanguageCode
* @param[in] LanguageCode LanguageCode.
*/
setsysSetLanguageCode :: (LanguageCode: u64) -> Result #foreign libnx;

/**
* @brief SetNetworkSettings
* @param[in] settings Input array of \ref SetSysNetworkSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetNetworkSettings :: (settings: *SetSysNetworkSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetNetworkSettings
* @param[out] total_out Total output entries.
* @param[out] versions Output array of \ref SetSysNetworkSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetNetworkSettings :: (total_out: *s32, settings: *SetSysNetworkSettings, count: s32) -> Result #foreign libnx;

/**
* @brief Gets the system firmware version.
* @param[out] out Firmware version to populate.
*/
setsysGetFirmwareVersion :: (out: *SetSysFirmwareVersion) -> Result #foreign libnx;

/**
* @brief GetFirmwareVersionDigest
* @param[out] out \ref SetSysFirmwareVersionDigest
*/
setsysGetFirmwareVersionDigest :: (out: *SetSysFirmwareVersionDigest) -> Result #foreign libnx;

/**
* @brief GetLockScreenFlag
* @param[out] out Output flag.
*/
setsysGetLockScreenFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetLockScreenFlag
* @param[in] flag Input flag.
*/
setsysSetLockScreenFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetBacklightSettings
* @param[out] out \ref SetSysBacklightSettings
*/
setsysGetBacklightSettings :: (out: *SetSysBacklightSettings) -> Result #foreign libnx;

/**
* @brief SetBacklightSettings
* @param[in] settings \ref SetSysBacklightSettings
*/
setsysSetBacklightSettings :: (settings: *SetSysBacklightSettings) -> Result #foreign libnx;

/**
* @brief SetBluetoothDevicesSettings
* @param[in] settings Input array of \ref SetSysBluetoothDevicesSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetBluetoothDevicesSettings :: (settings: *SetSysBluetoothDevicesSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetBluetoothDevicesSettings
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysBluetoothDevicesSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetBluetoothDevicesSettings :: (total_out: *s32, settings: *SetSysBluetoothDevicesSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetExternalSteadyClockSourceId
* @param[out] out \ref Uuid
*/
setsysGetExternalSteadyClockSourceId :: (out: *Uuid) -> Result #foreign libnx;

/**
* @brief SetExternalSteadyClockSourceId
* @param[in] uuid \ref Uuid
*/
setsysSetExternalSteadyClockSourceId :: (uuid: *Uuid) -> Result #foreign libnx;

/**
* @brief GetUserSystemClockContext
* @param[out] out \ref TimeSystemClockContext
*/
setsysGetUserSystemClockContext :: (out: *TimeSystemClockContext) -> Result #foreign libnx;

/**
* @brief SetUserSystemClockContext
* @param[in] context \ref TimeSystemClockContext
*/
setsysSetUserSystemClockContext :: (_context: *TimeSystemClockContext) -> Result #foreign libnx;

/**
* @brief GetAccountSettings
* @param[out] out \ref SetSysAccountSettings
*/
setsysGetAccountSettings :: (out: *SetSysAccountSettings) -> Result #foreign libnx;

/**
* @brief SetAccountSettings
* @param[in] settings \ref SetSysAccountSettings
*/
setsysSetAccountSettings :: (settings: SetSysAccountSettings) -> Result #foreign libnx;

/**
* @brief GetAudioVolume
* @param[in] device \ref SetSysAudioDevice
* @param[out] out \ref SetSysAudioVolume
*/
setsysGetAudioVolume :: (device: SetSysAudioDevice, out: *SetSysAudioVolume) -> Result #foreign libnx;

/**
* @brief SetAudioVolume
* @param[in] device \ref SetSysAudioDevice
* @param[in] volume \ref SetSysAudioVolume
*/
setsysSetAudioVolume :: (device: SetSysAudioDevice, volume: *SetSysAudioVolume) -> Result #foreign libnx;

/**
* @brief GetEulaVersions
* @param[out] total_out Total output entries.
* @param[out] versions Output array of \ref SetSysEulaVersion.
* @param[in] count Size of the versions array in entries.
*/
setsysGetEulaVersions :: (total_out: *s32, versions: *SetSysEulaVersion, count: s32) -> Result #foreign libnx;

/**
* @brief SetEulaVersions
* @param[in] versions Input array of \ref SetSysEulaVersion.
* @param[in] count Size of the versions array in entries.
*/
setsysSetEulaVersions :: (versions: *SetSysEulaVersion, count: s32) -> Result #foreign libnx;

/// Gets the current system theme.
setsysGetColorSetId :: (out: *ColorSetId) -> Result #foreign libnx;

/// Sets the current system theme.
setsysSetColorSetId :: (id: ColorSetId) -> Result #foreign libnx;

/**
* @brief GetConsoleInformationUploadFlag
* @param[out] out Output flag.
*/
setsysGetConsoleInformationUploadFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetConsoleInformationUploadFlag
* @param[in] flag Input flag.
*/
setsysSetConsoleInformationUploadFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetAutomaticApplicationDownloadFlag
* @param[out] out Output flag.
*/
setsysGetAutomaticApplicationDownloadFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetAutomaticApplicationDownloadFlag
* @param[in] flag Input flag.
*/
setsysSetAutomaticApplicationDownloadFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetNotificationSettings
* @param[out] out \ref SetSysNotificationSettings
*/
setsysGetNotificationSettings :: (out: *SetSysNotificationSettings) -> Result #foreign libnx;

/**
* @brief SetNotificationSettings
* @param[in] settings \ref SetSysNotificationSettings
*/
setsysSetNotificationSettings :: (settings: *SetSysNotificationSettings) -> Result #foreign libnx;

/**
* @brief GetAccountNotificationSettings
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysAccountNotificationSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetAccountNotificationSettings :: (total_out: *s32, settings: *SetSysAccountNotificationSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetAccountNotificationSettings
* @param[in] settings Input array of \ref SetSysAccountNotificationSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetAccountNotificationSettings :: (settings: *SetSysAccountNotificationSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetVibrationMasterVolume
* @param[out] out Output volume.
*/
setsysGetVibrationMasterVolume :: (out: *float) -> Result #foreign libnx;

/**
* @brief SetVibrationMasterVolume
* @param[in] volume Input volume.
*/
setsysSetVibrationMasterVolume :: (volume: float) -> Result #foreign libnx;

/**
* @brief Gets the size of a settings item value.
* @param name Name string.
* @param item_key Item key string.
* @param size_out Pointer to output the size to.
*/
setsysGetSettingsItemValueSize :: (name: *u8, item_key: *u8, size_out: *u64) -> Result #foreign libnx;

/**
* @brief Gets the value of a settings item.
* @param name Name string.
* @param item_key Item key string.
* @param value_out Pointer to output the value to.
* @param value_out_size Size of the value_out buffer.
* @param size_out Total size which was copied to value_out.
*/
setsysGetSettingsItemValue :: (name: *u8, item_key: *u8, value_out: *void, value_out_size: u64, size_out: *u64) -> Result #foreign libnx;

/**
* @brief GetTvSettings
* @param[out] out \ref SetSysTvSettings
*/
setsysGetTvSettings :: (out: *SetSysTvSettings) -> Result #foreign libnx;

/**
* @brief SetTvSettings
* @param[in] settings \ref SetSysTvSettings
*/
setsysSetTvSettings :: (settings: *SetSysTvSettings) -> Result #foreign libnx;

/**
* @brief GetEdid
* @param[out] out \ref SetSysEdid
*/
setsysGetEdid :: (out: *SetSysEdid) -> Result #foreign libnx;

/**
* @brief SetEdid
* @param[in] edid \ref SetSysEdid
*/
setsysSetEdid :: (edid: *SetSysEdid) -> Result #foreign libnx;

/**
* @brief GetAudioOutputMode
* @param[in] target \ref SetSysAudioOutputModeTarget
* @param[out] out \ref SetSysAudioOutputMode
*/
setsysGetAudioOutputMode :: (target: SetSysAudioOutputModeTarget, out: *SetSysAudioOutputMode) -> Result #foreign libnx;

/**
* @brief SetAudioOutputMode
* @param[in] target \ref SetSysAudioOutputModeTarget
* @param[in] mode \ref SetSysAudioOutputMode
*/
setsysSetAudioOutputMode :: (target: SetSysAudioOutputModeTarget, mode: SetSysAudioOutputMode) -> Result #foreign libnx;

/**
* @brief GetSpeakerAutoMuteFlag
* @param[out] out Output flag.
*/
setsysGetSpeakerAutoMuteFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetSpeakerAutoMuteFlag
* @param[in] flag Input flag.
*/
setsysSetSpeakerAutoMuteFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetQuestFlag
* @param[out] out Output flag.
*/
setsysGetQuestFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetQuestFlag
* @param[in] flag Input flag.
*/
setsysSetQuestFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetDataDeletionSettings
* @param[out] out \ref SetSysDataDeletionSettings
*/
setsysGetDataDeletionSettings :: (out: *SetSysDataDeletionSettings) -> Result #foreign libnx;

/**
* @brief SetDataDeletionSettings
* @param[in] settings \ref SetSysDataDeletionSettings
*/
setsysSetDataDeletionSettings :: (settings: *SetSysDataDeletionSettings) -> Result #foreign libnx;

/**
* @brief GetInitialSystemAppletProgramId
* @param[out] out output ProgramId.
*/
setsysGetInitialSystemAppletProgramId :: (out: *u64) -> Result #foreign libnx;

/**
* @brief GetOverlayDispProgramId
* @param[out] out output ProgramId.
*/
setsysGetOverlayDispProgramId :: (out: *u64) -> Result #foreign libnx;

/**
* @brief GetDeviceTimeZoneLocationName
* @param[out] out \ref TimeLocationName
*/
setsysGetDeviceTimeZoneLocationName :: (out: *TimeLocationName) -> Result #foreign libnx;

/**
* @brief SetDeviceTimeZoneLocationName
* @param[in] name \ref TimeLocationName
*/
setsysSetDeviceTimeZoneLocationName :: (name: *TimeLocationName) -> Result #foreign libnx;

/**
* @brief GetWirelessCertificationFileSize
* @param[out] out_size Output size.
*/
setsysGetWirelessCertificationFileSize :: (out_size: *u64) -> Result #foreign libnx;

/**
* @brief GetWirelessCertificationFile
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size.
* @param[out] out_size Output size.
*/
setsysGetWirelessCertificationFile :: (buffer: *void, size: u64, out_size: *u64) -> Result #foreign libnx;

/**
* @brief SetRegionCode
* @param[in] region \ref SetRegion
*/
setsysSetRegionCode :: (region: SetRegion) -> Result #foreign libnx;

/**
* @brief GetNetworkSystemClockContext
* @param[out] out \ref TimeSystemClockContext
*/
setsysGetNetworkSystemClockContext :: (out: *TimeSystemClockContext) -> Result #foreign libnx;

/**
* @brief SetNetworkSystemClockContext
* @param[in] context \ref TimeSystemClockContext
*/
setsysSetNetworkSystemClockContext :: (_context: *TimeSystemClockContext) -> Result #foreign libnx;

/**
* @brief IsUserSystemClockAutomaticCorrectionEnabled
* @param[out] out Output flag.
*/
setsysIsUserSystemClockAutomaticCorrectionEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetUserSystemClockAutomaticCorrectionEnabled
* @param[in] flag Input flag.
*/
setsysSetUserSystemClockAutomaticCorrectionEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetDebugModeFlag
* @param[out] out Output flag.
*/
setsysGetDebugModeFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief GetPrimaryAlbumStorage
* @param[out] out \ref GetPrimaryAlbumStorage
*/
setsysGetPrimaryAlbumStorage :: (out: *SetSysPrimaryAlbumStorage) -> Result #foreign libnx;

/**
* @brief SetPrimaryAlbumStorage
* @param[in] storage \ref SetSysPrimaryAlbumStorage
*/
setsysSetPrimaryAlbumStorage :: (storage: SetSysPrimaryAlbumStorage) -> Result #foreign libnx;

/**
* @brief GetUsb30EnableFlag
* @param[out] out Output flag.
*/
setsysGetUsb30EnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetUsb30EnableFlag
* @param[in] flag Input flag.
*/
setsysSetUsb30EnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetBatteryLot.
* @param[out] out \ref SetBatteryLot
*/
setsysGetBatteryLot :: (out: *SetBatteryLot) -> Result #foreign libnx;

/**
* @brief Gets the system's serial number.
* @param[out] out \ref SetSysSerialNumber
*/
setsysGetSerialNumber :: (out: *SetSysSerialNumber) -> Result #foreign libnx;

/**
* @brief GetNfcEnableFlag
* @param[out] out Output flag.
*/
setsysGetNfcEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetNfcEnableFlag
* @param[in] flag Input flag.
*/
setsysSetNfcEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetSleepSettings
* @param[out] out \ref SetSysSleepSettings
*/
setsysGetSleepSettings :: (out: *SetSysSleepSettings) -> Result #foreign libnx;

/**
* @brief SetSleepSettings
* @param[in] settings \ref SetSysSleepSettings
*/
setsysSetSleepSettings :: (settings: *SetSysSleepSettings) -> Result #foreign libnx;

/**
* @brief GetWirelessLanEnableFlag
* @param[out] out Output flag.
*/
setsysGetWirelessLanEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetWirelessLanEnableFlag
* @param[in] flag Input flag.
*/
setsysSetWirelessLanEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetInitialLaunchSettings
* @param[out] out \ref SetSysInitialLaunchSettings
*/
setsysGetInitialLaunchSettings :: (out: *SetSysInitialLaunchSettings) -> Result #foreign libnx;

/**
* @brief SetInitialLaunchSettings
* @param[in] settings \ref SetSysInitialLaunchSettings
*/
setsysSetInitialLaunchSettings :: (settings: *SetSysInitialLaunchSettings) -> Result #foreign libnx;

/**
* @brief Gets the system's nickname.
* @note Same as \ref setGetDeviceNickname, which official sw uses instead on [10.1.0+].
* @param[out] nickname \ref SetSysDeviceNickName
*/
setsysGetDeviceNickname :: (nickname: *SetSysDeviceNickName) -> Result #foreign libnx;

/**
* @brief Sets the system's nickname.
* @param[in] nickname \ref SetSysDeviceNickName
*/
setsysSetDeviceNickname :: (nickname: *SetSysDeviceNickName) -> Result #foreign libnx;

/**
* @brief GetProductModel
* @param[out] model Output SetSysProductModel.
*/
setsysGetProductModel :: (model: *SetSysProductModel) -> Result #foreign libnx;

/**
* @brief GetLdnChannel
* @param[out] out Output LdnChannel.
*/
setsysGetLdnChannel :: (out: *s32) -> Result #foreign libnx;

/**
* @brief SetLdnChannel
* @param[in] channel Input LdnChannel.
*/
setsysSetLdnChannel :: (channel: s32) -> Result #foreign libnx;

/**
* @brief Gets an event that settings will signal on flag change.
* @param out_event Event to bind. Output event will have autoclear=false.
*/
setsysAcquireTelemetryDirtyFlagEventHandle :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets the settings flags that have changed.
* @param flags_0 Pointer to populate with first 64 flags.
* @param flags_1 Pointer to populate with second 64 flags.
*/
setsysGetTelemetryDirtyFlags :: (flags_0: *u64, flags_1: *u64) -> Result #foreign libnx;

/**
* @brief GetPtmBatteryLot
* @param[out] out \ref SetBatteryLot
*/
setsysGetPtmBatteryLot :: (out: *SetBatteryLot) -> Result #foreign libnx;

/**
* @brief SetPtmBatteryLot
* @param[in] lot \ref SetBatteryLot
*/
setsysSetPtmBatteryLot :: (lot: *SetBatteryLot) -> Result #foreign libnx;

/**
* @brief GetPtmFuelGaugeParameter
* @param[out] out \ref SetSysPtmFuelGaugeParameter
*/
setsysGetPtmFuelGaugeParameter :: (out: *SetSysPtmFuelGaugeParameter) -> Result #foreign libnx;

/**
* @brief SetPtmFuelGaugeParameter
* @param[in] parameter \ref SetSysPtmFuelGaugeParameter
*/
setsysSetPtmFuelGaugeParameter :: (parameter: *SetSysPtmFuelGaugeParameter) -> Result #foreign libnx;

/**
* @brief GetBluetoothEnableFlag
* @param[out] out Output flag.
*/
setsysGetBluetoothEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetBluetoothEnableFlag
* @param[in] flag Input flag.
*/
setsysSetBluetoothEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetMiiAuthorId
* @param[out] out Output MiiAuthorId.
*/
setsysGetMiiAuthorId :: (out: *Uuid) -> Result #foreign libnx;

/**
* @brief SetShutdownRtcValue
* @param[in] value Input value.
*/
setsysSetShutdownRtcValue :: (value: u64) -> Result #foreign libnx;

/**
* @brief GetShutdownRtcValue
* @param[out] out Output value.
*/
setsysGetShutdownRtcValue :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Gets an event that settings will signal on flag change.
* @param out_event Event to bind. Output event will have autoclear=false.
*/
setsysAcquireFatalDirtyFlagEventHandle :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets the settings flags that have changed.
* @param flags_0 Pointer to populate with first 64 flags.
* @param flags_1 Pointer to populate with second 64 flags.
*/
setsysGetFatalDirtyFlags :: (flags_0: *u64, flags_1: *u64) -> Result #foreign libnx;

/**
* @brief GetAutoUpdateEnableFlag
* @note Only available on [2.0.0+].
* @param[out] out Output flag.
*/
setsysGetAutoUpdateEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetAutoUpdateEnableFlag
* @note Only available on [2.0.0+].
* @param[in] flag Input flag.
*/
setsysSetAutoUpdateEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetNxControllerSettings
* @note On [13.0.0+] \ref setsysGetNxControllerSettingsEx should be used instead.
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysNxControllerLegacySettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetNxControllerSettings :: (total_out: *s32, settings: *SetSysNxControllerLegacySettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetNxControllerSettings
* @note On [13.0.0+] \ref setsysSetNxControllerSettingsEx should be used instead.
* @param[in] settings Input array of \ref SetSysNxControllerLegacySettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetNxControllerSettings :: (settings: *SetSysNxControllerLegacySettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetBatteryPercentageFlag
* @note Only available on [2.0.0+].
* @param[out] out Output flag.
*/
setsysGetBatteryPercentageFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetBatteryPercentageFlag
* @note Only available on [2.0.0+].
* @param[in] flag Input flag.
*/
setsysSetBatteryPercentageFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetExternalRtcResetFlag
* @note Only available on [2.0.0+].
* @param[out] out Output flag.
*/
setsysGetExternalRtcResetFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetExternalRtcResetFlag
* @note Only available on [2.0.0+].
* @param[in] flag Input flag.
*/
setsysSetExternalRtcResetFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetUsbFullKeyEnableFlag
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
setsysGetUsbFullKeyEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetUsbFullKeyEnableFlag
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
setsysSetUsbFullKeyEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief SetExternalSteadyClockInternalOffset
* @note Only available on [3.0.0+].
* @param[in] offset Input offset.
*/
setsysSetExternalSteadyClockInternalOffset :: (offset: u64) -> Result #foreign libnx;

/**
* @brief GetExternalSteadyClockInternalOffset
* @note Only available on [3.0.0+].
* @param[out] out Output offset.
*/
setsysGetExternalSteadyClockInternalOffset :: (out: *u64) -> Result #foreign libnx;

/**
* @brief GetBacklightSettingsEx
* @note Only available on [3.0.0+].
* @param[out] out \ref SetSysBacklightSettingsEx
*/
setsysGetBacklightSettingsEx :: (out: *SetSysBacklightSettingsEx) -> Result #foreign libnx;

/**
* @brief SetBacklightSettingsEx
* @note Only available on [3.0.0+].
* @param[in] settings \ref SetSysBacklightSettingsEx
*/
setsysSetBacklightSettingsEx :: (settings: *SetSysBacklightSettingsEx) -> Result #foreign libnx;

/**
* @brief GetHeadphoneVolumeWarningCount
* @note Only available on [3.0.0+].
* @param[out] out Output count.
*/
setsysGetHeadphoneVolumeWarningCount :: (out: *u32) -> Result #foreign libnx;

/**
* @brief SetHeadphoneVolumeWarningCount
* @note Only available on [3.0.0+].
* @param[in] count Input count.
*/
setsysSetHeadphoneVolumeWarningCount :: (count: u32) -> Result #foreign libnx;

/**
* @brief GetBluetoothAfhEnableFlag
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
setsysGetBluetoothAfhEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetBluetoothAfhEnableFlag
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
setsysSetBluetoothAfhEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetBluetoothBoostEnableFlag
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
setsysGetBluetoothBoostEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetBluetoothBoostEnableFlag
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
setsysSetBluetoothBoostEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetInRepairProcessEnableFlag
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
setsysGetInRepairProcessEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetInRepairProcessEnableFlag
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
setsysSetInRepairProcessEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetHeadphoneVolumeUpdateFlag
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
setsysGetHeadphoneVolumeUpdateFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetHeadphoneVolumeUpdateFlag
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
setsysSetHeadphoneVolumeUpdateFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief NeedsToUpdateHeadphoneVolume
* @note Only available on [3.0.0-14.1.2].
* @param[out] a0 Output arg.
* @param[out] a1 Output arg.
* @param[out] a2 Output arg.
* @param[in] flag Input flag.
*/
setsysNeedsToUpdateHeadphoneVolume :: (a0: *u8, a1: *u8, a2: *u8, flag: bool) -> Result #foreign libnx;

/**
* @brief GetPushNotificationActivityModeOnSleep
* @note Only available on [3.0.0+].
* @param[out] out Output mode.
*/
setsysGetPushNotificationActivityModeOnSleep :: (out: *u32) -> Result #foreign libnx;

/**
* @brief SetPushNotificationActivityModeOnSleep
* @note Only available on [3.0.0+].
* @param[in] mode Input mode.
*/
setsysSetPushNotificationActivityModeOnSleep :: (mode: u32) -> Result #foreign libnx;

/**
* @brief GetServiceDiscoveryControlSettings
* @note Only available on [4.0.0+].
* @param[out] out \ref ServiceDiscoveryControlSettings
*/
setsysGetServiceDiscoveryControlSettings :: (out: *SetSysServiceDiscoveryControlSettings) -> Result #foreign libnx;

/**
* @brief SetServiceDiscoveryControlSettings
* @note Only available on [4.0.0+].
* @param[in] settings \ref ServiceDiscoveryControlSettings
*/
setsysSetServiceDiscoveryControlSettings :: (settings: SetSysServiceDiscoveryControlSettings) -> Result #foreign libnx;

/**
* @brief GetErrorReportSharePermission
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysErrorReportSharePermission
*/
setsysGetErrorReportSharePermission :: (out: *SetSysErrorReportSharePermission) -> Result #foreign libnx;

/**
* @brief SetErrorReportSharePermission
* @note Only available on [4.0.0+].
* @param[in] permission \ref SetSysErrorReportSharePermission
*/
setsysSetErrorReportSharePermission :: (permission: SetSysErrorReportSharePermission) -> Result #foreign libnx;

/**
* @brief GetAppletLaunchFlags
* @note Only available on [4.0.0+].
* @param[out] out Output AppletLaunchFlags bitmask.
*/
setsysGetAppletLaunchFlags :: (out: *u32) -> Result #foreign libnx;

/**
* @brief SetAppletLaunchFlags
* @note Only available on [4.0.0+].
* @param[in] flags Input AppletLaunchFlags bitmask.
*/
setsysSetAppletLaunchFlags :: (flags: u32) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAccelerationBias
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAccelerationBias
*/
setsysGetConsoleSixAxisSensorAccelerationBias :: (out: *SetSysConsoleSixAxisSensorAccelerationBias) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAccelerationBias
* @note Only available on [4.0.0+].
* @param[in] bias \ref SetSysConsoleSixAxisSensorAccelerationBias
*/
setsysSetConsoleSixAxisSensorAccelerationBias :: (bias: *SetSysConsoleSixAxisSensorAccelerationBias) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAngularVelocityBias
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAngularVelocityBias
*/
setsysGetConsoleSixAxisSensorAngularVelocityBias :: (out: *SetSysConsoleSixAxisSensorAngularVelocityBias) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAngularVelocityBias
* @note Only available on [4.0.0+].
* @param[in] bias \ref SetSysConsoleSixAxisSensorAngularVelocityBias
*/
setsysSetConsoleSixAxisSensorAngularVelocityBias :: (bias: *SetSysConsoleSixAxisSensorAngularVelocityBias) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAccelerationGain
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAccelerationGain
*/
setsysGetConsoleSixAxisSensorAccelerationGain :: (out: *SetSysConsoleSixAxisSensorAccelerationGain) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAccelerationGain
* @note Only available on [4.0.0+].
* @param[in] gain \ref SetSysConsoleSixAxisSensorAccelerationGain
*/
setsysSetConsoleSixAxisSensorAccelerationGain :: (gain: *SetSysConsoleSixAxisSensorAccelerationGain) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAngularVelocityGain
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAngularVelocityGain
*/
setsysGetConsoleSixAxisSensorAngularVelocityGain :: (out: *SetSysConsoleSixAxisSensorAngularVelocityGain) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAngularVelocityGain
* @note Only available on [4.0.0+].
* @param[in] gain \ref SetSysConsoleSixAxisSensorAngularVelocityGain
*/
setsysSetConsoleSixAxisSensorAngularVelocityGain :: (gain: *SetSysConsoleSixAxisSensorAngularVelocityGain) -> Result #foreign libnx;

/**
* @brief GetKeyboardLayout
* @note Only available on [4.0.0+].
* @param[out] out \ref SetKeyboardLayout
*/
setsysGetKeyboardLayout :: (out: *SetKeyboardLayout) -> Result #foreign libnx;

/**
* @brief SetKeyboardLayout
* @note Only available on [4.0.0+].
* @param[in] layout \ref SetKeyboardLayout
*/
setsysSetKeyboardLayout :: (layout: SetKeyboardLayout) -> Result #foreign libnx;

/**
* @brief GetWebInspectorFlag
* @note Only available on [4.0.0+].
* @param[out] out Output flag.
*/
setsysGetWebInspectorFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief GetAllowedSslHosts
* @note Only available on [4.0.0+].
* @param[out] total_out Total output entries.
* @param[out] out Output array of \ref SetSysAllowedSslHosts.
* @param[in] count Size of the hosts array in entries.
*/
setsysGetAllowedSslHosts :: (total_out: *s32, out: *SetSysAllowedSslHosts, count: s32) -> Result #foreign libnx;

/**
* @brief GetHostFsMountPoint
* @note Only available on [4.0.0+].
* @param[out] out \ref SetSysHostFsMountPoint
*/
setsysGetHostFsMountPoint :: (out: *SetSysHostFsMountPoint) -> Result #foreign libnx;

/**
* @brief GetRequiresRunRepairTimeReviser
* @note Only available on [5.0.0+].
* @param[out] out Output flag.
*/
setsysGetRequiresRunRepairTimeReviser :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetRequiresRunRepairTimeReviser
* @note Only available on [5.0.0+].
* @param[in] flag Input flag.
*/
setsysSetRequiresRunRepairTimeReviser :: (flag: bool) -> Result #foreign libnx;

/**
* @brief SetBlePairingSettings
* @note Only available on [5.0.0+].
* @param[in] settings Input array of \ref SetSysBlePairingSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetBlePairingSettings :: (settings: *SetSysBlePairingSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetBlePairingSettings
* @note Only available on [5.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysBlePairingSettings.
* @param[in] count Size of the hosts array in entries.
*/
setsysGetBlePairingSettings :: (total_out: *s32, settings: *SetSysBlePairingSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAngularVelocityTimeBias
* @note Only available on [5.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAngularVelocityTimeBias
*/
setsysGetConsoleSixAxisSensorAngularVelocityTimeBias :: (out: *SetSysConsoleSixAxisSensorAngularVelocityTimeBias) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAngularVelocityTimeBias
* @note Only available on [5.0.0+].
* @param[in] bias \ref SetSysConsoleSixAxisSensorAngularVelocityTimeBias
*/
setsysSetConsoleSixAxisSensorAngularVelocityTimeBias :: (bias: *SetSysConsoleSixAxisSensorAngularVelocityTimeBias) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorAngularAcceleration
* @note Only available on [5.0.0+].
* @param[out] out \ref SetSysConsoleSixAxisSensorAngularAcceleration
*/
setsysGetConsoleSixAxisSensorAngularAcceleration :: (out: *SetSysConsoleSixAxisSensorAngularAcceleration) -> Result #foreign libnx;

/**
* @brief SetConsoleSixAxisSensorAngularAcceleration
* @note Only available on [5.0.0+].
* @param[in] acceleration \ref SetSysConsoleSixAxisSensorAngularAcceleration
*/
setsysSetConsoleSixAxisSensorAngularAcceleration :: (acceleration: *SetSysConsoleSixAxisSensorAngularAcceleration) -> Result #foreign libnx;

/**
* @brief GetRebootlessSystemUpdateVersion
* @note Only available on [5.0.0+].
* @param[out] out \ref SetSysRebootlessSystemUpdateVersion
*/
setsysGetRebootlessSystemUpdateVersion :: (out: *SetSysRebootlessSystemUpdateVersion) -> Result #foreign libnx;

/**
* @brief GetDeviceTimeZoneLocationUpdatedTime
* @note Only available on [5.0.0+].
* @param[out] out \ref TimeSteadyClockTimePoint
*/
setsysGetDeviceTimeZoneLocationUpdatedTime :: (out: *TimeSteadyClockTimePoint) -> Result #foreign libnx;

/**
* @brief SetDeviceTimeZoneLocationUpdatedTime
* @note Only available on [5.0.0+].
* @param[in] time_point \ref TimeSteadyClockTimePoint
*/
setsysSetDeviceTimeZoneLocationUpdatedTime :: (time_point: *TimeSteadyClockTimePoint) -> Result #foreign libnx;

/**
* @brief GetUserSystemClockAutomaticCorrectionUpdatedTime
* @note Only available on [6.0.0+].
* @param[out] out \ref TimeSteadyClockTimePoint
*/
setsysGetUserSystemClockAutomaticCorrectionUpdatedTime :: (out: *TimeSteadyClockTimePoint) -> Result #foreign libnx;

/**
* @brief SetUserSystemClockAutomaticCorrectionUpdatedTime
* @note Only available on [6.0.0+].
* @param[in] time_point \ref TimeSteadyClockTimePoint
*/
setsysSetUserSystemClockAutomaticCorrectionUpdatedTime :: (time_point: *TimeSteadyClockTimePoint) -> Result #foreign libnx;

/**
* @brief GetAccountOnlineStorageSettings
* @note Only available on [6.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysAccountOnlineStorageSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetAccountOnlineStorageSettings :: (total_out: *s32, settings: *SetSysAccountOnlineStorageSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetAccountOnlineStorageSettings
* @note Only available on [6.0.0+].
* @param[in] settings Input array of \ref SetSysAccountOnlineStorageSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetAccountOnlineStorageSettings :: (settings: *SetSysAccountOnlineStorageSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetPctlReadyFlag
* @note Only available on [6.0.0+].
* @param[out] out Output flag.
*/
setsysGetPctlReadyFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetPctlReadyFlag
* @note Only available on [6.0.0+].
* @param[in] flag Input flag.
*/
setsysSetPctlReadyFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetAnalogStickUserCalibrationL
* @note Only available on [8.1.1+].
* @param[out] out \ref SetSysAnalogStickUserCalibration
*/
setsysGetAnalogStickUserCalibrationL :: (out: *SetSysAnalogStickUserCalibration) -> Result #foreign libnx;

/**
* @brief SetAnalogStickUserCalibrationL
* @note Only available on [8.1.1+].
* @param[in] calibration \ref SetSysAnalogStickUserCalibration
*/
setsysSetAnalogStickUserCalibrationL :: (calibration: *SetSysAnalogStickUserCalibration) -> Result #foreign libnx;

/**
* @brief GetAnalogStickUserCalibrationR
* @note Only available on [8.1.1+].
* @param[out] out \ref SetSysAnalogStickUserCalibration
*/
setsysGetAnalogStickUserCalibrationR :: (out: *SetSysAnalogStickUserCalibration) -> Result #foreign libnx;

/**
* @brief SetAnalogStickUserCalibrationR
* @note Only available on [8.1.1+].
* @param[in] calibration \ref SetSysAnalogStickUserCalibration
*/
setsysSetAnalogStickUserCalibrationR :: (calibration: *SetSysAnalogStickUserCalibration) -> Result #foreign libnx;

/**
* @brief GetPtmBatteryVersion
* @note Only available on [6.0.0+].
* @param[out] out Output version.
*/
setsysGetPtmBatteryVersion :: (out: *u8) -> Result #foreign libnx;

/**
* @brief SetPtmBatteryVersion
* @note Only available on [6.0.0+].
* @param[in] version Input version.
*/
setsysSetPtmBatteryVersion :: (version: u8) -> Result #foreign libnx;

/**
* @brief GetUsb30HostEnableFlag
* @note Only available on [6.0.0+].
* @param[out] out Output flag.
*/
setsysGetUsb30HostEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetUsb30HostEnableFlag
* @note Only available on [6.0.0+].
* @param[in] flag Input flag.
*/
setsysSetUsb30HostEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetUsb30DeviceEnableFlag
* @note Only available on [6.0.0+].
* @param[out] out Output flag.
*/
setsysGetUsb30DeviceEnableFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetUsb30DeviceEnableFlag
* @note Only available on [6.0.0+].
* @param[in] flag Input flag.
*/
setsysSetUsb30DeviceEnableFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetThemeId
* @note Only available on [7.0.0+].
* @param[in] type Input theme id type.
* @param[out] out \ref SetSysThemeId
*/
setsysGetThemeId :: (type: s32, out: *SetSysThemeId) -> Result #foreign libnx;

/**
* @brief SetThemeId
* @note Only available on [7.0.0+].
* @param[in] type Input theme id type.
* @param[in] theme_id \ref SetSysThemeId
*/
setsysSetThemeId :: (type: s32, theme_id: *SetSysThemeId) -> Result #foreign libnx;

/**
* @brief GetChineseTraditionalInputMethod
* @note Only available on [7.0.0+].
* @param[out] out \ref SetChineseTraditionalInputMethod
*/
setsysGetChineseTraditionalInputMethod :: (out: *SetChineseTraditionalInputMethod) -> Result #foreign libnx;

/**
* @brief SetChineseTraditionalInputMethod
* @note Only available on [7.0.0+].
* @param[in] method \ref SetChineseTraditionalInputMethod
*/
setsysSetChineseTraditionalInputMethod :: (method: SetChineseTraditionalInputMethod) -> Result #foreign libnx;

/**
* @brief GetPtmCycleCountReliability
* @note Only available on [7.0.0+].
* @param[out] out \ref SetSysPtmCycleCountReliability
*/
setsysGetPtmCycleCountReliability :: (out: *SetSysPtmCycleCountReliability) -> Result #foreign libnx;

/**
* @brief SetPtmCycleCountReliability
* @note Only available on [7.0.0+].
* @param[in] reliability \ref SetSysPtmCycleCountReliability
*/
setsysSetPtmCycleCountReliability :: (reliability: SetSysPtmCycleCountReliability) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetSysHomeMenuScheme.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetSysHomeMenuScheme
*/
setsysGetHomeMenuScheme :: (out: *SetSysHomeMenuScheme) -> Result #foreign libnx;

/**
* @brief GetThemeSettings
* @note Only available on [7.0.0+].
* @param[out] out \ref SetSysThemeSettings
*/
setsysGetThemeSettings :: (out: *SetSysThemeSettings) -> Result #foreign libnx;

/**
* @brief SetThemeSettings
* @note Only available on [7.0.0+].
* @param[in] settings \ref SetSysThemeSettings
*/
setsysSetThemeSettings :: (settings: *SetSysThemeSettings) -> Result #foreign libnx;

/**
* @brief GetThemeKey
* @note Only available on [7.0.0+].
* @param[out] out \ref FsArchiveMacKey
*/
setsysGetThemeKey :: (out: *FsArchiveMacKey) -> Result #foreign libnx;

/**
* @brief SetThemeKey
* @note Only available on [7.0.0+].
* @param[in] key \ref FsArchiveMacKey
*/
setsysSetThemeKey :: (key: *FsArchiveMacKey) -> Result #foreign libnx;

/**
* @brief GetZoomFlag
* @note Only available on [8.0.0+].
* @param[out] out Output flag.
*/
setsysGetZoomFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetZoomFlag
* @note Only available on [8.0.0+].
* @param[in] flag Input flag.
*/
setsysSetZoomFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Returns Terra platform type flag.
* @note On [9.0.0+], this is a wrapper for \ref setsysGetPlatFormRegion() == 2.
* @note Only available on [8.0.0+].
* @param[out] out Output flag.
*/
setsysGetT :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Sets Terra platform type flag.
* @note On [9.0.0+], this is a wrapper for \ref setsysSetPlatFormRegion(1 + (IsT & 1)).
* @note Only available on [8.0.0+].
* @param[in] flag Input flag.
*/
setsysSetT :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetSysPlatformRegion.
* @note This is used internally by \ref appletGetSettingsPlatformRegion.
* @note Only available on [9.0.0+].
* @param[out] out \ref SetSysPlatformRegion
*/
setsysGetPlatformRegion :: (out: *SetSysPlatformRegion) -> Result #foreign libnx;

/**
* @brief Sets the \ref SetSysPlatformRegion.
* @note Only available on [9.0.0+].
* @param[in] region \ref SetSysPlatformRegion
*/
setsysSetPlatformRegion :: (region: SetSysPlatformRegion) -> Result #foreign libnx;

/**
* @brief GetHomeMenuSchemeModel
* @note This will throw an error when loading the "settings_debug!{...}" system-setting which is used with this fails.
* @note Only available on [9.0.0+].
* @param[out] out HomeMenuSchemeModel.
*/
setsysGetHomeMenuSchemeModel :: (out: *u32) -> Result #foreign libnx;

/**
* @brief GetMemoryUsageRateFlag
* @note Only available on [9.0.0+].
* @param[out] out Output flag.
*/
setsysGetMemoryUsageRateFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetSysTouchScreenMode.
* @note Only available on [9.0.0+].
* @param[out] out \ref SetSysTouchScreenMode
*/
setsysGetTouchScreenMode :: (out: *SetSysTouchScreenMode) -> Result #foreign libnx;

/**
* @brief Sets the \ref SetSysTouchScreenMode.
* @note Only available on [9.0.0+].
* @param[in] mode \ref SetSysTouchScreenMode
*/
setsysSetTouchScreenMode :: (mode: SetSysTouchScreenMode) -> Result #foreign libnx;

/**
* @brief GetButtonConfigSettingsFull
* @note Only available on [10.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetButtonConfigSettingsFull :: (total_out: *s32, settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetButtonConfigSettingsFull
* @note Only available on [10.0.0+].
* @param[in] settings Input array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetButtonConfigSettingsFull :: (settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetButtonConfigSettingsEmbedded
* @note Only available on [10.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetButtonConfigSettingsEmbedded :: (total_out: *s32, settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetButtonConfigSettingsEmbedded
* @note Only available on [10.0.0+].
* @param[in] settings Input array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetButtonConfigSettingsEmbedded :: (settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetButtonConfigSettingsLeft
* @note Only available on [10.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetButtonConfigSettingsLeft :: (total_out: *s32, settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetButtonConfigSettingsLeft
* @note Only available on [10.0.0+].
* @param[in] settings Input array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetButtonConfigSettingsLeft :: (settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetButtonConfigSettingsRight
* @note Only available on [10.0.0+].
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetButtonConfigSettingsRight :: (total_out: *s32, settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetButtonConfigSettingsRight
* @note Only available on [10.0.0+].
* @param[in] settings Input array of \ref SetSysButtonConfigSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetButtonConfigSettingsRight :: (settings: *SetSysButtonConfigSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetButtonConfigRegisteredSettingsEmbedded
* @note Only available on [10.0.0+].
* @param[out] settings \ref SetSysButtonConfigRegisteredSettings
*/
setsysGetButtonConfigRegisteredSettingsEmbedded :: (settings: *SetSysButtonConfigRegisteredSettings) -> Result #foreign libnx;

/**
* @brief SetButtonConfigRegisteredSettingsEmbedded
* @note Only available on [10.0.0+].
* @param[in] settings \ref SetSysButtonConfigRegisteredSettings
*/
setsysSetButtonConfigRegisteredSettingsEmbedded :: (settings: *SetSysButtonConfigRegisteredSettings) -> Result #foreign libnx;

/**
* @brief GetButtonConfigRegisteredSettings
* @note Only available on [10.0.0+].
* @param[out] settings \ref SetSysButtonConfigRegisteredSettings
*/
setsysGetButtonConfigRegisteredSettings :: (total_out: *s32, settings: *SetSysButtonConfigRegisteredSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetButtonConfigRegisteredSettings
* @note Only available on [10.0.0+].
* @param[in] settings \ref SetSysButtonConfigRegisteredSettings
*/
setsysSetButtonConfigRegisteredSettings :: (settings: *SetSysButtonConfigRegisteredSettings, count: s32) -> Result #foreign libnx;

/**
* @brief GetFieldTestingFlag
* @note Only available on [10.1.0+].
* @param[out] out Output flag.
*/
setsysGetFieldTestingFlag :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetFieldTestingFlag
* @note Only available on [10.1.0+].
* @param[in] flag Input flag.
*/
setsysSetFieldTestingFlag :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetNxControllerSettingsEx
* @param[out] total_out Total output entries.
* @param[out] settings Output array of \ref SetSysNxControllerSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysGetNxControllerSettingsEx :: (total_out: *s32, settings: *SetSysNxControllerSettings, count: s32) -> Result #foreign libnx;

/**
* @brief SetNxControllerSettingsEx
* @param[in] settings Input array of \ref SetSysNxControllerSettings.
* @param[in] count Size of the settings array in entries.
*/
setsysSetNxControllerSettingsEx :: (settings: *SetSysNxControllerSettings, count: s32) -> Result #foreign libnx;

/// Initialize setcal.
setcalInitialize :: () -> Result #foreign libnx;

/// Exit setcal.
setcalExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual setcal service session.
setcalGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets the \ref SetCalBdAddress.
* @param[out] out \ref SetCalBdAddress
*/
setcalGetBdAddress :: (out: *SetCalBdAddress) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalConfigurationId1.
* @param[out] out \ref SetCalConfigurationId1
*/
setcalGetConfigurationId1 :: (out: *SetCalConfigurationId1) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAccelerometerOffset.
* @param[out] out \ref SetCalAccelerometerOffset
*/
setcalGetAccelerometerOffset :: (out: *SetCalAccelerometerOffset) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAccelerometerScale.
* @param[out] out \ref SetCalAccelerometerScale
*/
setcalGetAccelerometerScale :: (out: *SetCalAccelerometerScale) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalGyroscopeOffset.
* @param[out] out \ref SetCalGyroscopeOffset
*/
setcalGetGyroscopeOffset :: (out: *SetCalGyroscopeOffset) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalGyroscopeScale.
* @param[out] out \ref SetCalGyroscopeScale
*/
setcalGetGyroscopeScale :: (out: *SetCalGyroscopeScale) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalMacAddress.
* @param[out] out \ref SetCalMacAddress
*/
setcalGetWirelessLanMacAddress :: (out: *SetCalMacAddress) -> Result #foreign libnx;

/**
* @brief GetWirelessLanCountryCodeCount
* @param[out] out_count Output count
*/
setcalGetWirelessLanCountryCodeCount :: (out_count: *s32) -> Result #foreign libnx;

/**
* @brief GetWirelessLanCountryCodes
* @param[out] total_out Total output entries.
* @param[out] codes Output array of \ref SetCalCountryCode.
* @param[in] count Size of the versions array in entries.
*/
setcalGetWirelessLanCountryCodes :: (total_out: *s32, codes: *SetCalCountryCode, count: s32) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalSerialNumber.
* @param[out] out \ref SetCalSerialNumber
*/
setcalGetSerialNumber :: (out: *SetCalSerialNumber) -> Result #foreign libnx;

/**
* @brief SetInitialSystemAppletProgramId
* @param[in] program_id input ProgramId.
*/
setcalSetInitialSystemAppletProgramId :: (program_id: u64) -> Result #foreign libnx;

/**
* @brief SetOverlayDispProgramId
* @param[in] program_id input ProgramId.
*/
setcalSetOverlayDispProgramId :: (program_id: u64) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetBatteryLot.
* @param[out] out \ref SetBatteryLot
*/
setcalGetBatteryLot :: (out: *SetBatteryLot) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalEccB233DeviceCertificate.
* @param[out] out \ref SetCalEccB233DeviceCertificate
*/
setcalGetEciDeviceCertificate :: (out: *SetCalEccB233DeviceCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalRsa2048DeviceCertificate.
* @param[out] out \ref SetCalRsa2048DeviceCertificate
*/
setcalGetEticketDeviceCertificate :: (out: *SetCalRsa2048DeviceCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalSslKey.
* @param[out] out \ref SetCalSslKey
*/
setcalGetSslKey :: (out: *SetCalSslKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalSslCertificate.
* @param[out] out \ref SetCalSslCertificate
*/
setcalGetSslCertificate :: (out: *SetCalSslCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalGameCardKey.
* @param[out] out \ref SetCalGameCardKey
*/
setcalGetGameCardKey :: (out: *SetCalGameCardKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalGameCardCertificate.
* @param[out] out \ref SetCalGameCardCertificate
*/
setcalGetGameCardCertificate :: (out: *SetCalGameCardCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalEccB233DeviceKey.
* @param[out] out \ref SetCalEccB233DeviceKey
*/
setcalGetEciDeviceKey :: (out: *SetCalEccB233DeviceKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalRsa2048DeviceKey.
* @param[out] out \ref SetCalRsa2048DeviceKey
*/
setcalGetEticketDeviceKey :: (out: *SetCalRsa2048DeviceKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalSpeakerParameter.
* @param[out] out \ref SetCalSpeakerParameter
*/
setcalGetSpeakerParameter :: (out: *SetCalSpeakerParameter) -> Result #foreign libnx;

/**
* @brief GetLcdVendorId
* @note Only available on [4.0.0+].
* @param[out] out_vendor_id Output LcdVendorId.
*/
setcalGetLcdVendorId :: (out_vendor_id: *u32) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalRsa2048DeviceCertificate.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalRsa2048DeviceCertificate
*/
setcalGetEciDeviceCertificate2 :: (out: *SetCalRsa2048DeviceCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalRsa2048DeviceKey.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalRsa2048DeviceKey
*/
setcalGetEciDeviceKey2 :: (out: *SetCalRsa2048DeviceKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboKey.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboKey
*/
setcalGetAmiiboKey :: (out: *SetCalAmiiboKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboEcqvCertificate.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboEcqvCertificate
*/
setcalGetAmiiboEcqvCertificate :: (out: *SetCalAmiiboEcqvCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboEcdsaCertificate.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboEcdsaCertificate
*/
setcalGetAmiiboEcdsaCertificate :: (out: *SetCalAmiiboEcdsaCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboEcqvBlsKey.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboEcqvBlsKey
*/
setcalGetAmiiboEcqvBlsKey :: (out: *SetCalAmiiboEcqvBlsKey) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboEcqvBlsCertificate.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboEcqvBlsCertificate
*/
setcalGetAmiiboEcqvBlsCertificate :: (out: *SetCalAmiiboEcqvBlsCertificate) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAmiiboEcqvBlsRootCertificate.
* @note Only available on [5.0.0+].
* @param[out] out \ref SetCalAmiiboEcqvBlsRootCertificate
*/
setcalGetAmiiboEcqvBlsRootCertificate :: (out: *SetCalAmiiboEcqvBlsRootCertificate) -> Result #foreign libnx;

/**
* @brief GetUsbTypeCPowerSourceCircuitVersion
* @note Only available on [5.0.0+].
* @param[out] out_version Output UsbTypeCPowerSourceCircuitVersion.
*/
setcalGetUsbTypeCPowerSourceCircuitVersion :: (out_version: *u8) -> Result #foreign libnx;

/**
* @brief GetAnalogStickModuleTypeL
* @note Only available on [8.1.1+].
* @param[out] out_version Output AnalogStickModuleType.
*/
setcalGetAnalogStickModuleTypeL :: (out_type: *u8) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAnalogStickModelParameter.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetCalAnalogStickModelParameter
*/
setcalGetAnalogStickModelParameterL :: (out: *SetCalAnalogStickModelParameter) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAnalogStickFactoryCalibration.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetCalAnalogStickFactoryCalibration
*/
setcalGetAnalogStickFactoryCalibrationL :: (out: *SetCalAnalogStickFactoryCalibration) -> Result #foreign libnx;

/**
* @brief GetAnalogStickModuleTypeR
* @note Only available on [8.1.1+].
* @param[out] out_version Output AnalogStickModuleType.
*/
setcalGetAnalogStickModuleTypeR :: (out_type: *u8) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAnalogStickModelParameter.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetCalAnalogStickModelParameter
*/
setcalGetAnalogStickModelParameterR :: (out: *SetCalAnalogStickModelParameter) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalAnalogStickFactoryCalibration.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetCalAnalogStickFactoryCalibration
*/
setcalGetAnalogStickFactoryCalibrationR :: (out: *SetCalAnalogStickFactoryCalibration) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorModuleType
* @note Only available on [8.1.1+].
* @param[out] out_version Output ConsoleSixAxisSensorModuleType.
*/
setcalGetConsoleSixAxisSensorModuleType :: (out_type: *u8) -> Result #foreign libnx;

/**
* @brief Gets the \ref SetCalConsoleSixAxisSensorHorizontalOffset.
* @note Only available on [8.1.1+].
* @param[out] out \ref SetCalConsoleSixAxisSensorHorizontalOffset
*/
setcalGetConsoleSixAxisSensorHorizontalOffset :: (out: *SetCalConsoleSixAxisSensorHorizontalOffset) -> Result #foreign libnx;

/**
* @brief GetBatteryVersion
* @note Only available on [6.0.0+].
* @param[out] out_version Output BatteryVersion.
*/
setcalGetBatteryVersion :: (out_version: *u8) -> Result #foreign libnx;

/**
* @brief GetDeviceId
* @note Only available on [10.0.0+].
* @param[out] out_type Output DeviceId.
*/
setcalGetDeviceId :: (out_device_id: *u64) -> Result #foreign libnx;

/**
* @brief GetConsoleSixAxisSensorMountType
* @note Only available on [10.0.0+].
* @param[out] out_type Output ConsoleSixAxisSensorMountType.
*/
setcalGetConsoleSixAxisSensorMountType :: (out_type: *u8) -> Result #foreign libnx;

/// AppletType
AppletType :: enum s32 {
    None              :: -2;
    Default           :: -1;
    Application       :: 0;
    SystemApplet      :: 1;
    LibraryApplet     :: 2;
    OverlayApplet     :: 3;
    SystemApplication :: 4;
}

/// OperationMode
AppletOperationMode :: enum u32 {
    Handheld :: 0;
    Console  :: 1;
}

/// applet hook types.
AppletHookType :: enum u32 {
    OnFocusState                :: 0;
    OnOperationMode             :: 1;
    OnPerformanceMode           :: 2;
    OnExitRequest               :: 3;
    OnResume                    :: 4;
    OnCaptureButtonShortPressed :: 5;
    OnAlbumScreenShotTaken      :: 6;
    RequestToDisplay            :: 7;

    Max                         :: 8;
}

/// AppletMessage, for \ref appletGetMessage. See also \ref AppletHookType.
AppletMessage :: enum u32 {
    ExitRequest               :: 4;
    FocusStateChanged         :: 15;
    Resume                    :: 16;
    OperationModeChanged      :: 30;
    PerformanceModeChanged    :: 31;
    RequestToDisplay          :: 51;
    CaptureButtonShortPressed :: 90;
    AlbumScreenShotTaken      :: 92;
    AlbumRecordingSaved       :: 93;
}

/// FocusState
AppletFocusState :: enum u32 {
    InFocus    :: 1;
    OutOfFocus :: 2;
    Background :: 3;
}

/// FocusHandlingMode
AppletFocusHandlingMode :: enum u32 {
    SuspendHomeSleep       :: 0;
    NoSuspend              :: 1;
    SuspendHomeSleepNotify :: 2;
    AlwaysSuspend          :: 3;

    Max                    :: 4;
}

/// LaunchParameterKind
AppletLaunchParameterKind :: enum u32 {
    UserChannel     :: 1;
    PreselectedUser :: 2;
    Unknown         :: 3;
}

/// AppletId
AppletId :: enum u32 {
    None                      :: 0;
    application               :: 1;
    OverlayApplet             :: 2;
    SystemAppletMenu          :: 3;
    SystemApplication         :: 4;
    LibraryAppletAuth         :: 10;
    LibraryAppletCabinet      :: 11;
    LibraryAppletController   :: 12;
    LibraryAppletDataErase    :: 13;
    LibraryAppletError        :: 14;
    LibraryAppletNetConnect   :: 15;
    LibraryAppletPlayerSelect :: 16;
    LibraryAppletSwkbd        :: 17;
    LibraryAppletMiiEdit      :: 18;
    LibraryAppletWeb          :: 19;
    LibraryAppletShop         :: 20;
    LibraryAppletPhotoViewer  :: 21;
    LibraryAppletSet          :: 22;
    LibraryAppletOfflineWeb   :: 23;
    LibraryAppletLoginShare   :: 24;
    LibraryAppletWifiWebAuth  :: 25;
    LibraryAppletMyPage       :: 26;
}

/// LibraryAppletMode
LibAppletMode :: enum u32 {
    AllForeground                :: 0;
    Background                   :: 1;
    NoUi                         :: 2;
    BackgroundIndirect           :: 3;
    AllForegroundInitiallyHidden :: 4;
}

/// LibraryAppletExitReason
LibAppletExitReason :: enum u32 {
    Normal     :: 0;
    Canceled   :: 1;
    Abnormal   :: 2;
    Unexpected :: 10;
}

/// AppletApplicationExitReason
AppletApplicationExitReason :: enum u32 {
    Normal     :: 0;
    Unknown1   :: 1;
    Unknown2   :: 2;
    Unknown3   :: 3;
    Unknown4   :: 4;
    Unknown5   :: 5;
    Unexpected :: 100;
}

/// ThemeColorType
AppletThemeColorType :: enum u32 {
    Default  :: 0;
    Unknown1 :: 1;
    Unknown2 :: 2;
    Unknown3 :: 3;
}

/// Mode values for \ref appletSetTvPowerStateMatchingMode.
AppletTvPowerStateMatchingMode :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
}

/// Type values for \ref appletPerformSystemButtonPressingIfInFocus.
AppletSystemButtonType :: enum u32 {
    HomeButtonShortPressing    :: 1;
    HomeButtonLongPressing     :: 2;
    PowerButtonShortPressing   :: 3;
    PowerButtonLongPressing    :: 4;
    Shutdown                   :: 5;
    CaptureButtonShortPressing :: 6;
    CaptureButtonLongPressing  :: 7;
}

/// Permission values for \ref appletSetScreenShotPermission.
AppletScreenShotPermission :: enum u32 {
    Inherit :: 0;
    Enable  :: 1;
    Disable :: 2;
}

/// Extension values for \ref appletSetIdleTimeDetectionExtension / \ref appletGetIdleTimeDetectionExtension, for extending user inactivity detection.
AppletIdleTimeDetectionExtension :: enum u32 {
    None           :: 0;
    Extended       :: 1;
    ExtendedUnsafe :: 2;
}

/// Input policy values for \ref appletSetInputDetectionPolicy.
AppletInputDetectionPolicy :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
}

/// Input mode values for \ref appletSetWirelessPriorityMode.
AppletWirelessPriorityMode :: enum u32 {
    Default          :: 1;
    OptimizedForWlan :: 2;
}

/// CaptureSharedBuffer for the IDisplayController commands.
AppletCaptureSharedBuffer :: enum u32 {
    LastApplication :: 0;
    LastForeground  :: 1;
    CallerApplet    :: 2;
}

/// WindowOriginMode
AppletWindowOriginMode :: enum u32 {
    LowerLeft :: 0;
    UpperLeft :: 1;
}

/// ProgramSpecifyKind for the ExecuteProgram cmd. Controls the type of the u64 passed to the ExecuteProgram cmd.
AppletProgramSpecifyKind :: enum u32 {
    ExecuteProgram                            :: 0;
    JumpToSubApplicationProgramForDevelopment :: 1;
    RestartProgram                            :: 2;
}

/// applet hook function.
AppletHookFn :: #type (hook: AppletHookType, param: *void) -> void #c_call;

AppletHookCookie :: struct {
    next:     *AppletHookCookie; ///< Next cookie.
    callback: AppletHookFn; ///< Hook callback.
    param:    *void; ///< Callback parameter.
}

/// LockAccessor
AppletLockAccessor :: struct {
    s:     Service; ///< ILockAccessor
    event: Event; ///< Event from the GetEvent cmd, with autoclear=false.
}

/// applet IStorage
AppletStorage :: struct {
    s:    Service; ///< IStorage
    tmem: TransferMemory; ///< TransferMemory
}

/// LibraryApplet state.
AppletHolder :: struct {
    s:                          Service; ///< ILibraryAppletAccessor
    StateChangedEvent:          Event; ///< Output from GetAppletStateChangedEvent, autoclear=false.
    PopInteractiveOutDataEvent: Event; ///< Output from GetPopInteractiveOutDataEvent, autoclear=false.
    mode:                       LibAppletMode; ///< See ref \ref LibAppletMode.
    layer_handle:               u64; ///< Output from GetIndirectLayerConsumerHandle on [2.0.0+].
    creating_self:              bool; ///< When set, indicates that the LibraryApplet is creating itself.
    exitreason:                 LibAppletExitReason; ///< Set by \ref appletHolderJoin using the output from cmd GetResult, see \ref LibAppletExitReason.
}

/// IApplicationAccessor container.
AppletApplication :: struct {
    s:                 Service; ///< IApplicationAccessor
    StateChangedEvent: Event; ///< Output from GetAppletStateChangedEvent, autoclear=false.
    exitreason:        AppletApplicationExitReason; ///< Set by \ref appletApplicationJoin using the output from cmd GetResult, see \ref AppletApplicationExitReason.
}

/// GpuErrorHandler
AppletGpuErrorHandler :: struct {
    s: Service; ///< IGpuErrorHandler
}

/// Used by \ref appletInitialize with __nx_applet_AppletAttribute for cmd OpenLibraryAppletProxy (AppletType_LibraryApplet), on [3.0.0+]. The default for this struct is all-zero.
AppletAttribute :: struct {
    flag:     u8; ///< Flag. When non-zero, two state fields are set to 1.
    reserved: [127] u8; ///< Unused.
}

/// LibraryAppletInfo
LibAppletInfo :: struct {
    appletId: AppletId; ///< \ref AppletId
    mode:     LibAppletMode; ///< \ref LibAppletMode
}

/// AppletProcessLaunchReason, from GetLaunchReason.
AppletProcessLaunchReason :: struct {
    flag:   u8; ///< When non-zero, indicates that OpenCallingLibraryApplet should be used.
    unk_x1: [3] u8; ///< Always zero.
}

/// Cached info for the current LibraryApplet, from \ref appletGetAppletInfo.
AppletInfo :: struct {
    info:        LibAppletInfo; ///< Output from \ref appletGetLibraryAppletInfo.
    caller_flag: bool; ///< Loaded from AppletProcessLaunchReason::flag, indicates that the below AppletHolder is initialized.
    caller:      AppletHolder; ///< \ref AppletHolder for the CallingLibraryApplet, automatically closed by \ref appletExit when needed.
}

/// IdentityInfo
AppletIdentityInfo :: struct {
    appletId:       AppletId; ///< \ref AppletId
    pad:            u32; ///< Padding.
    application_id: u64; ///< ApplicationId, only set with appletId == ::AppletId_application.
}

/// Attributes for launching applications for Quest.
AppletApplicationAttributeForQuest :: struct {
    unk_x0: u32; ///< See AppletApplicationAttribute::unk_x0.
    unk_x4: u32; ///< See AppletApplicationAttribute::unk_x4.
    volume: float; ///< [7.0.0+] See AppletApplicationAttribute::volume.
}

/// ApplicationAttribute
AppletApplicationAttribute :: struct {
    unk_x0: u32; ///< Default is 0 for non-Quest. Only used when non-zero: unknown value in seconds.
    unk_x4: u32; ///< Default is 0 for non-Quest. Only used when non-zero: unknown value in seconds.
    volume: float; ///< Audio volume. Must be in the range of 0.0f-1.0f. The default is 1.0f.
    unused: [20] u8; ///< Unused. Default is 0.
}

/// ApplicationLaunchProperty
AppletApplicationLaunchProperty :: struct {
    application_id:   u64; ///< ApplicationId.
    version:          u32; ///< Application version.
    app_storageId:    u8; ///< \ref NcmStorageId for the Application.
    update_storageId: u8; ///< \ref NcmStorageId for the Application update.
    unk_xa:           u8; ///< Unknown.
    pad:              u8; ///< Padding.
}

/// ApplicationLaunchRequestInfo
AppletApplicationLaunchRequestInfo :: struct {
    unk_x0: u32; ///< Unknown. The default is 0x0 with \ref appletCreateSystemApplication, 0x3 with \ref appletCreateApplication.
    unk_x4: u32; ///< Unknown. The default is 0x0 with \ref appletCreateSystemApplication, 0x3 with \ref appletCreateApplication.
    unk_x8: [8] u8; ///< Unknown. The default is 0x0.
}

/// AppletResourceUsageInfo, from \ref appletGetAppletResourceUsageInfo.
AppletResourceUsageInfo :: struct {
    counter0: u32; ///< Unknown counter.
    counter1: u32; ///< Unknown counter.
    counter2: u32; ///< Output from ns cmd GetRightsEnvironmentCountForDebug.
    unused:   [20] u8; ///< Always zero.
}

/// Initialize applet, called automatically during app startup.
appletInitialize :: () -> Result #foreign libnx;

/// Exit applet, called automatically during app exit.
appletExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual "appletOE"/"appletAE" service session.
appletGetServiceSession_Proxy :: () -> *Service #foreign libnx;

/// Gets the Service object for IAppletCommonFunctions. Only initialized with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [7.0.0+].
appletGetServiceSession_AppletCommonFunctions :: () -> *Service #foreign libnx;

/// Gets the Service object for I*Functions, specific to each AppletType (IApplicationFunctions for AppletType_*Application). Not initialized with AppletType_LibraryApplet pre-15.0.0. On [15.0.0+] with AppletType_LibraryApplet this returns the object for IHomeMenuFunctions.
appletGetServiceSession_Functions :: () -> *Service #foreign libnx;

/// Gets the Service object for IGlobalStateController. Only initialized with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
appletGetServiceSession_GlobalStateController :: () -> *Service #foreign libnx;

/// Gets the Service object for IApplicationCreator. Only initialized with AppletType_SystemApplet.
appletGetServiceSession_ApplicationCreator :: () -> *Service #foreign libnx;

/// Gets the Service object for ILibraryAppletSelfAccessor. Only initialized with AppletType_LibraryApplet.
appletGetServiceSession_LibraryAppletSelfAccessor :: () -> *Service #foreign libnx;

/// Gets the Service object for IProcessWindingController. Only initialized with AppletType_LibraryApplet.
appletGetServiceSession_ProcessWindingController :: () -> *Service #foreign libnx;

/// Gets the Service object for ILibraryAppletCreator.
appletGetServiceSession_LibraryAppletCreator :: () -> *Service #foreign libnx;

/// Gets the Service object for ICommonStateGetter.
appletGetServiceSession_CommonStateGetter :: () -> *Service #foreign libnx;

/// Gets the Service object for ISelfController.
appletGetServiceSession_SelfController :: () -> *Service #foreign libnx;

/// Gets the Service object for IWindowController.
appletGetServiceSession_WindowController :: () -> *Service #foreign libnx;

/// Gets the Service object for IAudioController.
appletGetServiceSession_AudioController :: () -> *Service #foreign libnx;

/// Gets the Service object for IDisplayController.
appletGetServiceSession_DisplayController :: () -> *Service #foreign libnx;

/// Gets the Service object for IDebugFunctions.
appletGetServiceSession_DebugFunctions :: () -> *Service #foreign libnx;

/// Get the cached AppletResourceUserId.
appletGetAppletResourceUserId :: () -> u64 #foreign libnx;

/// Get the \ref AppletType.
appletGetAppletType :: () -> AppletType #foreign libnx;

/// Sets the state field for \ref AppletThemeColorType.
appletSetThemeColorType :: (theme: AppletThemeColorType) -> void #foreign libnx;

/// Gets the state field for \ref AppletThemeColorType. Used internally by \ref libappletArgsCreate.
appletGetThemeColorType :: () -> AppletThemeColorType #foreign libnx;

/**
* @brief Gets the CradleStatus.
* @param[out] status Output Dock status.
*/
appletGetCradleStatus :: (status: *u8) -> Result #foreign libnx;

/**
* @brief Gets the BootMode which originated from \ref pmbmGetBootMode.
* @param[out] mode \ref PmBootMode
*/
appletGetBootMode :: (mode: *PmBootMode) -> Result #foreign libnx;

/**
* @brief Request to AcquireSleepLock.
* @note On success, this then uses cmd GetAcquiredSleepLockEvent and waits on that event.
*/
appletRequestToAcquireSleepLock :: () -> Result #foreign libnx;

/**
* @brief Release the SleepLock.
*/
appletReleaseSleepLock :: () -> Result #foreign libnx;

/**
* @brief Release the SleepLock transiently.
* @note On success, this then uses cmd GetAcquiredSleepLockEvent and waits on that event.
*/
appletReleaseSleepLockTransiently :: () -> Result #foreign libnx;

/**
* @brief GetWakeupCount
* @note Only available with [11.0.0+].
* @param[out] out Output value.
*/
appletGetWakeupCount :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Pushes a storage to the general channel. Used for sending requests to SystemApplet.
* @note  This is not usable under an Application, however it is usable under a LibraryApplet.
* @note  This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletPushToGeneralChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets a \ref AppletLockAccessor for HomeButtonReader.
* @note Similar to using \ref appletGetReaderLockAccessorEx with inval=0.
* @param a LockAccessor object.
*/
appletGetHomeButtonReaderLockAccessor :: (a: *AppletLockAccessor) -> Result #foreign libnx;

/**
* @brief Gets a Reader \ref AppletLockAccessor.
* @note Only available with [2.0.0+].
* @param a LockAccessor object.
* @param[in] inval Input value, must be 0-3. 0 = HomeButton.
*/
appletGetReaderLockAccessorEx :: (a: *AppletLockAccessor, inval: u32) -> Result #foreign libnx;

/**
* @brief Gets a Writer \ref AppletLockAccessor.
* @note Only available with [7.0.0+]. On older sysvers, this is only available with AppletType_SystemApplet on [2.0.0+].
* @param a LockAccessor object.
* @param[in] inval Input value, must be 0-3. 0 = HomeButton.
*/
appletGetWriterLockAccessorEx :: (a: *AppletLockAccessor, inval: u32) -> Result #foreign libnx;

/**
* @brief Gets the Dock firmware version.
* @note Only available with [2.0.0+].
* @param[out] out0 First output value.
* @param[out] out1 Second output value.
* @param[out] out2 Third output value.
* @param[out] out3 Fourth output value.
*/
appletGetCradleFwVersion :: (out0: *u32, out1: *u32, out2: *u32, out3: *u32) -> Result #foreign libnx;

/**
* @brief Gets whether VrMode is enabled.
* @note Only available with [3.0.0+].
* @param out Output flag
*/
appletIsVrModeEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Sets whether VrMode is enabled.
* @note This is only fully usable system-side with [6.0.0+].
* @note For checking Parental Controls, see \ref pctlIsStereoVisionPermitted.
* @note On pre-7.0.0 this uses cmd SetVrModeEnabled internally, while on [7.0.0+] this uses cmds BeginVrModeEx/EndVrModeEx.
* @param flag Flag
*/
appletSetVrModeEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether the LCD screen backlight is turned off.
* @note Only available with [4.0.0+].
* @param[in] flag Flag
*/
appletSetLcdBacklightOffEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets the ControllerFirmwareUpdateSection flag.
* @note Only available with [3.0.0+].
* @param[out] out Output flag.
*/
appletIsInControllerFirmwareUpdateSection :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetVrPositionForDebug
* @note The cached value loaded from \ref setsysGetDebugModeFlag must be 1, otherwise an error is returned.
* @note Only available with [11.0.0+].
* @param[in] x X, must not be negative. x+width must be <=1280.
* @param[in] y Y, must not be negative. y+height must be <=720.
* @param[in] width Width, must be 1-1280.
* @param[in] height Height, must be 1-720.
*/
appletSetVrPositionForDebug :: (x: s32, y: s32, width: s32, height: s32) -> Result #foreign libnx;

/**
* @brief Gets the DefaultDisplayResolution.
* @note Only available with [3.0.0+].
* @param[out] width Output width.
* @param[out] height Output height.
*/
appletGetDefaultDisplayResolution :: (width: *s32, height: *s32) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when the output from \ref appletGetDefaultDisplayResolution changes.
* @note Only available with [3.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
appletGetDefaultDisplayResolutionChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets the HdcpAuthenticationState.
* @note Only available with [4.0.0+].
* @param[out] state Output state.
*/
appletGetHdcpAuthenticationState :: (state: *s32) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when the output from \ref appletGetHdcpAuthenticationState changes.
* @note Only available with [4.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
appletGetHdcpAuthenticationStateChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Sets the \ref AppletTvPowerStateMatchingMode.
* @note Only available with [5.0.0+].
* @param[in] mode \ref AppletTvPowerStateMatchingMode
*/
appletSetTvPowerStateMatchingMode :: (mode: AppletTvPowerStateMatchingMode) -> Result #foreign libnx;

/**
* @brief Gets the ApplicationId for the specified ContentActionName string.
* @note Only available when the current applet is an AppletType_SystemApplication on [5.1.0+].
* @param[out] application_id ApplicationId.
* @param[in] name ContentActionName string.
*/
appletGetApplicationIdByContentActionName :: (application_id: *u64, name: *u8) -> Result #foreign libnx;

/**
* @brief Sets the \ref ApmCpuBoostMode.
* @note Only available with [7.0.0+] (not fully usable system-side with 6.x).
* @param mode \ref ApmCpuBoostMode.
*/
appletSetCpuBoostMode :: (mode: ApmCpuBoostMode) -> Result #foreign libnx;

/**
* @brief CancelCpuBoostMode
* @note Only available with [10.0.0+].
*/
appletCancelCpuBoostMode :: () -> Result #foreign libnx;

/**
* @brief GetBuiltInDisplayType
* @note Only available with [11.0.0+].
* @param[out] out Output value.
*/
appletGetBuiltInDisplayType :: (out: *s32) -> Result #foreign libnx;

/**
* @brief Perform SystemButtonPressing with the specified \ref AppletSystemButtonType. Internally this cmd checks a state field, verifies that the type is allowed, then runs the same func as \ref appletPerformSystemButtonPressing internally.
* @note Only available with [6.0.0+].
* @param[in] type \ref AppletSystemButtonType
*/
appletPerformSystemButtonPressingIfInFocus :: (type: AppletSystemButtonType) -> Result #foreign libnx;

/**
* @brief Sets whether PerformanceConfigurationChangedNotification is enabled.
* @note Only available with [7.0.0+].
* @param[in] flag Whether to enable the notification.
*/
appletSetPerformanceConfigurationChangedNotification :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets the current PerformanceConfiguration.
* @note Only available with [7.0.0+].
* @param PerformanceConfiguration Output PerformanceConfiguration.
*/
appletGetCurrentPerformanceConfiguration :: (PerformanceConfiguration: *u32) -> Result #foreign libnx;

/**
* @brief Opens an \ref AppletGpuErrorHandler.
* @note The cached value loaded from \ref setsysGetDebugModeFlag must be 1, otherwise an error is returned.
* @note Only available with [11.0.0+].
* @param[out] g \ref AppletGpuErrorHandler
*/
appletOpenMyGpuErrorHandler :: (g: *AppletGpuErrorHandler) -> Result #foreign libnx;

/**
* @brief Gets the OperationModeSystemInfo.
* @note Only available with [7.0.0+].
* @param[out] info Output info.
*/
appletGetOperationModeSystemInfo :: (info: *u32) -> Result #foreign libnx;

/**
* @brief This uses \ref setsysGetPlatformRegion internally.
* @note Only available with [9.0.0+].
* @param[out] out \ref SetSysPlatformRegion
*/
appletGetSettingsPlatformRegion :: (out: *SetSysPlatformRegion) -> Result #foreign libnx;

/**
* @brief ActivateMigrationService
* @note Only available with [10.0.0+].
*/
appletActivateMigrationService :: () -> Result #foreign libnx;

/**
* @brief DeactivateMigrationService
* @note Only available with [10.0.0+].
*/
appletDeactivateMigrationService :: () -> Result #foreign libnx;

/**
* @brief DisableSleepTillShutdown
* @note Only available with [11.0.0+].
*/
appletDisableSleepTillShutdown :: () -> Result #foreign libnx;

/**
* @brief SuppressDisablingSleepTemporarily
* @param[in] val Nanoseconds value.
* @note Only available with [11.0.0+].
*/
appletSuppressDisablingSleepTemporarily :: (val: u64) -> Result #foreign libnx;

/**
* @brief SetRequestExitToLibraryAppletAtExecuteNextProgramEnabled
* @note Only available with [11.0.0+].
*/
appletSetRequestExitToLibraryAppletAtExecuteNextProgramEnabled :: () -> Result #foreign libnx;

/**
* @brief Close an \ref AppletGpuErrorHandler.
* @param g \ref AppletGpuErrorHandler
*/
appletGpuErrorHandlerClose :: (g: *AppletGpuErrorHandler) -> void #foreign libnx;

/**
* @brief Gets the size of the info available with \ref appletGpuErrorHandlerGetManualGpuErrorInfo.
* @param g \ref AppletGpuErrorHandler
* @param[out] out Output size.
*/
appletGpuErrorHandlerGetManualGpuErrorInfoSize :: (g: *AppletGpuErrorHandler, out: *u64) -> Result #foreign libnx;

/**
* @brief GetManualGpuErrorInfo
* @param g \ref AppletGpuErrorHandler
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size, must be >= the output size from \ref appletGpuErrorHandlerGetManualGpuErrorInfoSize.
* @param[out] out Output value.
*/
appletGpuErrorHandlerGetManualGpuErrorInfo :: (g: *AppletGpuErrorHandler, buffer: *void, size: u64, out: *u64) -> Result #foreign libnx;

/**
* @brief GetManualGpuErrorDetectionSystemEvent
* @param g \ref AppletGpuErrorHandler
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGpuErrorHandlerGetManualGpuErrorDetectionSystemEvent :: (g: *AppletGpuErrorHandler, out_event: *Event) -> Result #foreign libnx;

/**
* @brief FinishManualGpuErrorHandling
* @param g \ref AppletGpuErrorHandler
*/
appletGpuErrorHandlerFinishManualGpuErrorHandling :: (g: *AppletGpuErrorHandler) -> Result #foreign libnx;

/**
* @brief Delay exiting until \ref appletUnlockExit is called, with a 15 second timeout once exit is requested.
* @note When exit is requested \ref appletMainLoop will return false, hence any main-loop using appletMainLoop will exit. This allows the app to handle cleanup post-main-loop instead of being force-terminated.
* @note If the above timeout occurs after exit was requested where \ref appletUnlockExit was not called, the process will be forced-terminated.
* @note \ref appletUnlockExit must be used before main() returns.
*/
appletLockExit :: () -> Result #foreign libnx;

/// Unlocks exiting, see \ref appletLockExit.
appletUnlockExit :: () -> Result #foreign libnx;

/**
* @brief Enter FatalSection.
*/
appletEnterFatalSection :: () -> Result #foreign libnx;

/**
* @brief Leave FatalSection.
*/
appletLeaveFatalSection :: () -> Result #foreign libnx;

/**
* @brief Controls whether screenshot-capture is allowed.
* @param permission \ref AppletScreenShotPermission
*/
appletSetScreenShotPermission :: (permission: AppletScreenShotPermission) -> Result #foreign libnx;

/**
* @brief Sets whether ::AppletMessage_Resume is enabled.
* @param[in] flag Whether to enable the notification.
*/
appletSetRestartMessageEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the \ref AppletIdentityInfo for screenshots.
* @param[in] info \ref AppletIdentityInfo
*/
appletSetScreenShotAppletIdentityInfo :: (info: *AppletIdentityInfo) -> Result #foreign libnx;

/**
* @brief Sets ControllerFirmwareUpdateSection.
* @note Only available with [3.0.0+].
* @note This throws error 0x40280 when the internal state flag already matches the input value.
* @param[in] flag Flag
*/
appletSetControllerFirmwareUpdateSection :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether ::AppletMessage_CaptureButtonShortPressed is enabled.
* @note Only available with [3.0.0+].
* @note When enabled with a non-Overlay applet, Overlay applet will not be notified of capture button short-presses for screenshots.
* @param[in] flag Whether to enable the notification.
*/
appletSetRequiresCaptureButtonShortPressedMessage :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the Album screenshot ImageOrientation.
* @note Only available with [3.0.0+].
* @param[in] orientation \ref AlbumImageOrientation
*/
appletSetAlbumImageOrientation :: (orientation: AlbumImageOrientation) -> Result #foreign libnx;

/**
* @brief Sets the DesirableKeyboardLayout.
* @note Only available with [4.0.0+].
* @param[in] layout Input \ref SetKeyboardLayout.
*/
appletSetDesirableKeyboardLayout :: (layout: SetKeyboardLayout) -> Result #foreign libnx;

appletCreateManagedDisplayLayer :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Checks whether SystemBufferSharing is enabled, throwing an error otherwise.
* @note Only available with [4.0.0+]. Not usable with AppletType_*Application.
*/
appletIsSystemBufferSharingEnabled :: () -> Result #foreign libnx;

/**
* @brief Gets the System SharedBufferHandle and SharedLayerHandle.
* @note Only available with [4.0.0+]. Not usable with AppletType_*Application.
* @param[out] SharedBufferHandle Output System SharedBufferHandle.
* @param[out] SharedLayerHandle Output System SharedLayerHandle.
*/
appletGetSystemSharedLayerHandle :: (SharedBufferHandle: *u64, SharedLayerHandle: *u64) -> Result #foreign libnx;

/**
* @brief Same as \ref appletGetSystemSharedLayerHandle except this just gets the SharedBufferHandle.
* @note Only available with [5.0.0+]. Not usable with AppletType_*Application.
* @param[out] SharedBufferHandle Output System SharedBufferHandle.
*/
appletGetSystemSharedBufferHandle :: (SharedBufferHandle: *u64) -> Result #foreign libnx;

/**
* @brief CreateManagedDisplaySeparableLayer
* @note Only available with [10.0.0+].
* @param[out] display_layer Output display_layer.
* @param[out] recording_layer Output recording_layer.
*/
appletCreateManagedDisplaySeparableLayer :: (display_layer: *u64, recording_layer: *u64) -> Result #foreign libnx;

/**
* @brief SetManagedDisplayLayerSeparationMode
* @note Only available with [10.0.0+].
* @param[in] mode Mode. Must be 0-1.
*/
appletSetManagedDisplayLayerSeparationMode :: (mode: u32) -> Result #foreign libnx;

/**
* @brief Sets whether ::AppletMessage_RequestToDisplay is enabled.
* @note Sets an internal state flag. When the input flag is 0, this will in additional run the same code as \ref appletApproveToDisplay.
* @param[in] flag Flag
*/
appletSetHandlesRequestToDisplay :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Approve the display requested by ::AppletMessage_RequestToDisplay, see also \ref appletSetHandlesRequestToDisplay.
*/
appletApproveToDisplay :: () -> Result #foreign libnx;

/**
* @brief OverrideAutoSleepTimeAndDimmingTime
* @param[in] inval0 Unknown input value.
* @param[in] inval1 Unknown input value.
* @param[in] inval2 Unknown input value.
* @param[in] inval3 Unknown input value.
*/
appletOverrideAutoSleepTimeAndDimmingTime :: (inval0: s32, inval1: s32, inval2: s32, inval3: s32) -> Result #foreign libnx;

/**
* @brief Sets the IdleTimeDetectionExtension.
* @param[in] ext \ref AppletIdleTimeDetectionExtension Must be 0-2: 0 = disabled, 1 = Extended, and 2 = ExtendedUnsafe.
*/
appletSetIdleTimeDetectionExtension :: (ext: AppletIdleTimeDetectionExtension) -> Result #foreign libnx;

/**
* @brief Gets the value set by \ref appletSetIdleTimeDetectionExtension.
* @param[out] ext \ref AppletIdleTimeDetectionExtension
*/
appletGetIdleTimeDetectionExtension :: (ext: *AppletIdleTimeDetectionExtension) -> Result #foreign libnx;

/**
* @brief Sets the InputDetectionSourceSet.
* @param[in] val Input value.
*/
appletSetInputDetectionSourceSet :: (val: u32) -> Result #foreign libnx;

/**
* @brief Reports that the user is active, for idle detection (screen dimming / auto-sleep). This is equivalent to when the user uses HID input.
* @note Only available with [2.0.0+].
*/
appletReportUserIsActive :: () -> Result #foreign libnx;

/**
* @brief Gets the current Illuminance from the light sensor.
* @note Only available with [3.0.0+].
* @param fLux Output fLux
*/
appletGetCurrentIlluminance :: (fLux: *float) -> Result #foreign libnx;

/**
* @brief Gets whether Illuminance is available.
* @note Only available with [3.0.0+].
* @param out Output flag
*/
appletIsIlluminanceAvailable :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Sets AutoSleepDisabled.
* @note Only available with [5.0.0+].
* @param[in] flag Flag
*/
appletSetAutoSleepDisabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets AutoSleepDisabled.
* @note Only available with [5.0.0+].
* @param[out] out Output flag
*/
appletIsAutoSleepDisabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the current Illuminance from the light sensor. Same as \ref appletGetCurrentIlluminance except for the additional param.
* @note Only available with [5.0.0+].
* @param bOverLimit Output bOverLimit
* @param fLux Output fLux
*/
appletGetCurrentIlluminanceEx :: (bOverLimit: *bool, fLux: *float) -> Result #foreign libnx;

/**
* @brief Sets the \ref AppletInputDetectionPolicy.
* @note Only available with [9.0.0+].
* @param[in] policy \ref AppletInputDetectionPolicy
*/
appletSetInputDetectionPolicy :: (policy: AppletInputDetectionPolicy) -> Result #foreign libnx;

/**
* @brief Sets the WirelessPriorityMode.
* @note Only available with [4.0.0+].
* @param[in] mode \ref AppletWirelessPriorityMode
*/
appletSetWirelessPriorityMode :: (mode: AppletWirelessPriorityMode) -> Result #foreign libnx;

/**
* @brief Gets the total time in nanoseconds that the current process was actively running (not suspended), relative to when \ref appletInitialize was last used.
* @note Only available with [6.0.0+].
* @param[out] activeTime Output nanoseconds value.
*/
appletGetProgramTotalActiveTime :: (activeTime: *u64) -> Result #foreign libnx;

/**
* @brief Sets whether ::AppletMessage_AlbumScreenShotTaken is enabled.
* @note Only available with [7.0.0+].
* @param[in] flag Whether to enable the notification.
*/
appletSetAlbumImageTakenNotificationEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the Application AlbumUserData.
* @note Only available with [8.0.0+].
* @param[in] buffer Buffer containing arbitrary UserData.
* @param[in] size Buffer size, must be <=0x400.
*/
appletSetApplicationAlbumUserData :: (buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief SaveCurrentScreenshot
* @note Only available with [11.0.0+].
* @param[in] option \ref AlbumReportOption
*/
appletSaveCurrentScreenshot :: (option: AlbumReportOption) -> Result #foreign libnx;

/**
* @brief Gets the AppletResourceUserId of the CallerApplet.
* @note Only available with [6.0.0+].
* @param[out] out AppletResourceUserId
*/
appletGetAppletResourceUserIdOfCallerApplet :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Sets the current applet WindowVisibility.
* @note Only available with [7.0.0+].
* @param[in] flag Flag
*/
appletSetAppletWindowVisibility :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the AppletGpuTimeSlice.
* @note Only available with [7.0.0+].
* @param[in] val Input value, must not be negative.
*/
appletSetAppletGpuTimeSlice :: (val: s64) -> Result #foreign libnx;

/**
* @brief Sets the ExpectedMasterVolume for MainApplet and LibraryApplet.
* @note Used by some official apps before/after launching LibraryApplets. Prior to changing the volume, the official app uses \ref appletGetExpectedMasterVolume, with the output being used to restore the volume after LibraryApplet handling.
* @param[in] mainAppletVolume MainApplet ExpectedMasterVolume.
* @param[in] libraryAppletVolume LibraryApplet ExpectedMasterVolume.
*/
appletSetExpectedMasterVolume :: (mainAppletVolume: float, libraryAppletVolume: float) -> Result #foreign libnx;

/**
* @brief Gets the ExpectedMasterVolume for MainApplet and LibraryApplet.
* @note See also \ref appletSetExpectedMasterVolume.
* @param[out] mainAppletVolume MainApplet ExpectedMasterVolume. Optional, can be NULL. Used with cmd GetMainAppletExpectedMasterVolume when not NULL.
* @param[out] libraryAppletVolume LibraryApplet ExpectedMasterVolume. Optional, can be NULL. Used with cmd GetLibraryAppletExpectedMasterVolume when not NULL.
*/
appletGetExpectedMasterVolume :: (mainAppletVolume: *float, libraryAppletVolume: *float) -> Result #foreign libnx;

/**
* @brief Change the MainApplet MasterVolume.
* @param[in] volume MainApplet MasterVolume.
* @param[in] unk Unknown.
*/
appletChangeMainAppletMasterVolume :: (volume: float, unk: u64) -> Result #foreign libnx;

/**
* @brief Sets the TransparentVolumeRate.
* @param[in] val Input value.
*/
appletSetTransparentVolumeRate :: (val: float) -> Result #foreign libnx;

/**
* @brief Update the LastForeground CaptureImage.
*/
appletUpdateLastForegroundCaptureImage :: () -> Result #foreign libnx;

/**
* @brief Update the CallerApplet CaptureImage.
*/
appletUpdateCallerAppletCaptureImage :: () -> Result #foreign libnx;

/**
* @brief Gets the LastForeground CaptureImage.
* @param[out] buffer Output buffer containing the 1280x720 RGBA8 image.
* @param[out] size Buffer size, must match 0x384000.
* @param[out] flag Output flag.
*/
appletGetLastForegroundCaptureImageEx :: (buffer: *void, size: u64, flag: *bool) -> Result #foreign libnx;

/**
* @brief Gets the LastApplication CaptureImage.
* @param[out] buffer Output buffer containing the 1280x720 RGBA8 image.
* @param[out] size Buffer size, must match 0x384000.
* @param[out] flag Output flag.
*/
appletGetLastApplicationCaptureImageEx :: (buffer: *void, size: u64, flag: *bool) -> Result #foreign libnx;

/**
* @brief Gets the CallerApplet CaptureImage.
* @param[out] buffer Output buffer containing the 1280x720 RGBA8 image.
* @param[out] size Buffer size, must match 0x384000.
* @param[out] flag Output flag.
*/
appletGetCallerAppletCaptureImageEx :: (buffer: *void, size: u64, flag: *bool) -> Result #foreign libnx;

/**
* @brief Takes a screenshot of the current applet Layer into the specified CaptureSharedBuffer.
* @note Only available with [2.0.0+].
* @param[in] flag Flag.
* @param[in] captureBuf \ref AppletCaptureSharedBuffer
*/
appletTakeScreenShotOfOwnLayer :: (flag: bool, captureBuf: AppletCaptureSharedBuffer) -> Result #foreign libnx;

/**
* @brief Copies image data from a CaptureSharedBuffer to another CaptureSharedBuffer.
* @note Only available with [5.0.0+].
* @param[in] dstCaptureBuf Destination \ref AppletCaptureSharedBuffer.
* @param[in] srcCaptureBuf Source \ref AppletCaptureSharedBuffer.
*/
appletCopyBetweenCaptureBuffers :: (dstCaptureBuf: AppletCaptureSharedBuffer, srcCaptureBuf: AppletCaptureSharedBuffer) -> Result #foreign libnx;

/**
* @brief Clear the input CaptureSharedBuffer with the specified color.
* @note Only available with [3.0.0+].
* @param[in] flag Flag.
* @param[in] captureBuf \ref AppletCaptureSharedBuffer
* @param[in] color RGBA8 color.
*/
appletClearCaptureBuffer :: (flag: bool, captureBuf: AppletCaptureSharedBuffer, color: u32) -> Result #foreign libnx;

/**
* @brief Clear the AppletTransitionBuffer with the specified color.
* @note Only available with [3.0.0+].
* @param[in] color RGBA8 color.
*/
appletClearAppletTransitionBuffer :: (color: u32) -> Result #foreign libnx;

/**
* @brief Acquire the LastApplication CaptureSharedBuffer.
* @note Only available with [4.0.0+].
* @param[out] flag Output flag.
* @param[out] id Output ID.
*/
appletAcquireLastApplicationCaptureSharedBuffer :: (flag: *bool, id: *s32) -> Result #foreign libnx;

/**
* @brief Release the LastApplication CaptureSharedBuffer.
* @note Only available with [4.0.0+].
*/
appletReleaseLastApplicationCaptureSharedBuffer :: () -> Result #foreign libnx;

/**
* @brief Acquire the LastForeground CaptureSharedBuffer.
* @note Only available with [4.0.0+].
* @param[out] flag Output flag.
* @param[out] id Output ID.
*/
appletAcquireLastForegroundCaptureSharedBuffer :: (flag: *bool, id: *s32) -> Result #foreign libnx;

/**
* @brief Release the LastForeground CaptureSharedBuffer.
* @note Only available with [4.0.0+].
*/
appletReleaseLastForegroundCaptureSharedBuffer :: () -> Result #foreign libnx;

/**
* @brief Acquire the CallerApplet CaptureSharedBuffer.
* @note Only available with [4.0.0+].
* @param[out] flag Output flag.
* @param[out] id Output ID.
*/
appletAcquireCallerAppletCaptureSharedBuffer :: (flag: *bool, id: *s32) -> Result #foreign libnx;

/**
* @brief Release the CallerApplet CaptureSharedBuffer.
* @note Only available with [4.0.0+].
*/
appletReleaseCallerAppletCaptureSharedBuffer :: () -> Result #foreign libnx;

/**
* @brief Takes a screenshot of the current applet Layer into the specified CaptureSharedBuffer. Same as \ref appletTakeScreenShotOfOwnLayer except for the additional immediately param.
* @note Only available with [6.0.0+].
* @param[in] flag0 Flag0.
* @param[in] immediately Whether the screenshot should be taken immediately.
* @param[in] captureBuf \ref AppletCaptureSharedBuffer
*/
appletTakeScreenShotOfOwnLayerEx :: (flag0: bool, immediately: bool, captureBuf: AppletCaptureSharedBuffer) -> Result #foreign libnx;

/**
* @brief Pushes a storage to the ContextStack. Normally this should only be used when AppletInfo::caller_flag is true.
* @note Only available with AppletType_LibraryApplet.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletPushContext :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pops a storage from the ContextStack. Normally this should only be used when AppletInfo::caller_flag is true.
* @note Only available with AppletType_LibraryApplet.
* @param[out] s Storage object.
*/
appletPopContext :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Closes a LockAccessor.
* @param a LockAccessor object.
*/
appletLockAccessorClose :: (a: *AppletLockAccessor) -> void #foreign libnx;

/**
* @brief TryLock a LockAccessor.
* @param a LockAccessor object.
* @param[out] flag Whether locking was successful, when false this indicates that this func should be called again.
*/
appletLockAccessorTryLock :: (a: *AppletLockAccessor, flag: *bool) -> Result #foreign libnx;

/**
* @brief Lock a LockAccessor.
* @note Similar to \ref appletLockAccessorTryLock, except this uses timeout UINT64_MAX with the eventWait call, and this uses TryLock repeatedly until the output flag value is true.
* @param a LockAccessor object.
*/
appletLockAccessorLock :: (a: *AppletLockAccessor) -> Result #foreign libnx;

/**
* @brief Unlock a LockAccessor.
* @param a LockAccessor object.
*/
appletLockAccessorUnlock :: (a: *AppletLockAccessor) -> Result #foreign libnx;

/**
* @brief Creates a LibraryApplet.
* @param h AppletHolder object.
* @param id See \ref AppletId.
* @param mode See \ref LibAppletMode.
*/
appletCreateLibraryApplet :: (h: *AppletHolder, id: AppletId, mode: LibAppletMode) -> Result #foreign libnx;

/**
* @brief Creates a LibraryApplet. This is for when a LibraryApplet creates itself.
* @note  Identical to \ref appletCreateLibraryApplet except this sets the creating_self flag to true.
* @param h AppletHolder object.
* @param id See \ref AppletId.
* @param mode See \ref LibAppletMode.
*/
appletCreateLibraryAppletSelf :: (h: *AppletHolder, id: AppletId, mode: LibAppletMode) -> Result #foreign libnx;

/**
* @brief TerminateAllLibraryApplets which were created by the current applet.
* @note Normally LibraryApplet cleanup should be handled via \ref AppletHolder.
*/
appletTerminateAllLibraryApplets :: () -> Result #foreign libnx;

/**
* @brief AreAnyLibraryAppletsLeft which were created by the current applet.
* @param[out] out Output flag.
*/
appletAreAnyLibraryAppletsLeft :: (out: *bool) -> Result #foreign libnx;

/// Closes an AppletHolder object.
appletHolderClose :: (h: *AppletHolder) -> void #foreign libnx;

/// Returns whether the AppletHolder object was initialized.
appletHolderActive :: (h: *AppletHolder) -> bool #foreign libnx;

/**
* @brief Gets the IndirectLayerConsumerHandle loaded during \ref appletCreateLibraryApplet, on [2.0.0+].
* @note  Only available when \ref LibAppletMode is ::LibAppletMode_BackgroundIndirect.
* @param h AppletHolder object.
* @param out Output IndirectLayerConsumerHandle.
*/
appletHolderGetIndirectLayerConsumerHandle :: (h: *AppletHolder, out: *u64) -> Result #foreign libnx;

/**
* @brief Starts the LibraryApplet.
* @param h AppletHolder object.
*/
appletHolderStart :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Jumps to the LibraryApplet, with the current-LibraryApplet being terminated. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_LibraryApplet.
* @param h AppletHolder object.
*/
appletHolderJump :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Requests the LibraryApplet to exit. The command is only used if \ref appletHolderCheckFinished returns false.
* @param h AppletHolder object.
*/
appletHolderRequestExit :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Terminate the LibraryApplet.
* @param h AppletHolder object.
*/
appletHolderTerminate :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Uses cmds GetAppletStateChangedEvent and RequestExit, then waits for the LibraryApplet to exit with the specified timeout. If a timeout occurs, the Terminate cmd is used.
* @param h AppletHolder object.
* @param[in] timeout Timeout in nanoseconds. UINT64_MAX for no timeout.
*/
appletHolderRequestExitOrTerminate :: (h: *AppletHolder, timeout: u64) -> Result #foreign libnx;

/**
* @brief Waits for the LibraryApplet to exit.
* @param h AppletHolder object.
*/
appletHolderJoin :: (h: *AppletHolder) -> void #foreign libnx;

/**
* @brief Waits on the LibraryApplet StateChangedEvent with timeout=0, and returns whether it was successful.
* @param h AppletHolder object.
*/
appletHolderCheckFinished :: (h: *AppletHolder) -> bool #foreign libnx;

/**
* @brief Gets the \ref LibAppletExitReason set by \ref appletHolderJoin.
* @param h AppletHolder object.
*/
appletHolderGetExitReason :: (h: *AppletHolder) -> LibAppletExitReason #foreign libnx;

/**
* @brief Sets OutOfFocusApplicationSuspendingEnabled.
* @note Only available with AppletType_*Application.
* @param h AppletHolder object.
* @param[in] flag Flag
*/
appletHolderSetOutOfFocusApplicationSuspendingEnabled :: (h: *AppletHolder, flag: bool) -> Result #foreign libnx;

/**
* @brief PresetLibraryAppletGpuTimeSliceZero
* @note Only available with [10.0.0+].
* @param h AppletHolder object.
*/
appletHolderPresetLibraryAppletGpuTimeSliceZero :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Gets the PopInteractiveOutDataEvent.
* @param h AppletHolder object.
* @param[out] out_event Output Event.
*/
appletHolderGetPopInteractiveOutDataEvent :: (h: *AppletHolder, out_event: **Event) -> Result #foreign libnx;

/**
* @brief Waits for the PopInteractiveOutDataEvent and StateChangedEvent.
* @return false for error / when StateChangedEvent was signaled, and true when PopInteractiveOutDataEvent was signaled. The latter is signaled when a new storage is available with \ref appletHolderPopInteractiveOutData where previously no storage was available (this willl not clear the event), this event is automatically cleared by the system once the last storage is popped.
* @param h AppletHolder object.
*/
appletHolderWaitInteractiveOut :: (h: *AppletHolder) -> bool #foreign libnx;

/**
* @brief Pushes a storage for LibraryApplet input.
* @note  This uses \ref appletStorageClose automatically.
* @param h AppletHolder object.
* @param[in] s Storage object.
*/
appletHolderPushInData :: (h: *AppletHolder, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pops a storage from LibraryApplet output.
* @param h AppletHolder object.
* @param[out] s Storage object.
*/
appletHolderPopOutData :: (h: *AppletHolder, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pushes a storage for LibraryApplet Extra storage input.
* @note  This uses \ref appletStorageClose automatically.
* @param h AppletHolder object.
* @param[in] s Storage object.
*/
appletHolderPushExtraStorage :: (h: *AppletHolder, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pushes a storage for LibraryApplet Interactive input.
* @note  This uses \ref appletStorageClose automatically.
* @param h AppletHolder object.
* @param[in] s Storage object.
*/
appletHolderPushInteractiveInData :: (h: *AppletHolder, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pops a storage from LibraryApplet Interactive output.
* @param h AppletHolder object.
* @param[out] s Storage object.
*/
appletHolderPopInteractiveOutData :: (h: *AppletHolder, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets the \ref LibAppletInfo for the specified LibraryApplet.
* @param h AppletHolder object.
* @param[out] info \ref LibAppletInfo
*/
appletHolderGetLibraryAppletInfo :: (h: *AppletHolder, info: *LibAppletInfo) -> Result #foreign libnx;

/**
* @brief Creates a storage.
* @param s Storage object.
* @param size Size of storage.
*/
appletCreateStorage :: (s: *AppletStorage, size: s64) -> Result #foreign libnx;

/**
* @brief Creates a TransferMemory storage.
* @param s Storage object.
* @param buffer TransferMemory buffer, will be automatically allocated if NULL.
* @param size Size of storage.
* @param writable Controls whether writing to the storage is allowed with \ref appletStorageWrite.
*/
appletCreateTransferMemoryStorage :: (s: *AppletStorage, buffer: *void, size: s64, writable: bool) -> Result #foreign libnx;

/**
* @brief Creates a HandleStorage.
* @note Only available on [2.0.0+].
* @param s Storage object.
* @param inval Arbitrary input value.
* @param handle Arbitrary input handle.
*/
appletCreateHandleStorage :: (s: *AppletStorage, inval: s64, handle: Handle) -> Result #foreign libnx;

/**
* @brief Creates a HandleStorage using TransferMemory. Wrapper for \ref appletCreateHandleStorage.
* @param s Storage object.
* @param buffer TransferMemory buffer, will be automatically allocated if NULL.
* @param size Size of storage.
*/
appletCreateHandleStorageTmem :: (s: *AppletStorage, buffer: *void, size: s64) -> Result #foreign libnx;

/// Closes the storage object. TransferMemory closing is seperate, see \ref appletStorageCloseTmem.
/// Other applet functions which push an input storage will automatically call this.
appletStorageClose :: (s: *AppletStorage) -> void #foreign libnx;

/// Closes the TransferMemory in the storage object. For TransferMemory storage created by the current process, this must be called after the LibraryApplet finishes using it (if sent to one).
appletStorageCloseTmem :: (s: *AppletStorage) -> void #foreign libnx;

/// Gets the size of the storage. This is not usable with HandleStorage, use \ref appletStorageGetHandle or \ref appletStorageMap instead for that.
appletStorageGetSize :: (s: *AppletStorage, size: *s64) -> Result #foreign libnx;

/**
* @brief Writes to a storage. offset(+size) must be within the actual storage size.
* @note  This is not usable with HandleStorage.
* @param s Storage object.
* @param offset Offset in storage.
* @param buffer Input data.
* @param size Data size.
*/
appletStorageWrite :: (s: *AppletStorage, offset: s64, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Reads from a storage. offset(+size) must be within the actual storage size.
* @note  This is not usable with HandleStorage.
* @param s Storage object.
* @param offset Offset in storage.
* @param buffer Input data.
* @param size Data size.
*/
appletStorageRead :: (s: *AppletStorage, offset: s64, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets data for a HandleStorage originally from \ref appletCreateHandleStorage input.
* @note  Only available on [2.0.0+].
* @param s Storage object.
* @param out Output value.
* @param handle Output handle.
*/
appletStorageGetHandle :: (s: *AppletStorage, out: *s64, handle: *Handle) -> Result #foreign libnx;

/**
* @brief Maps TransferMemory for a HandleStorage. Wrapper for \ref appletCreateHandleStorage.
* @note  The TransferMemory can be unmapped with \ref appletStorageCloseTmem.
* @note  Do not use this if the AppletStorage already contains initialized TransferMemory state.
* @param s Storage object.
* @param addr Output mapped address (optional).
* @param size Output size (optional).
*/
appletStorageMap :: (s: *AppletStorage, addr: **void, size: *u64) -> Result #foreign libnx;

/**
* @brief Pops a LaunchParameter AppletStorage, the storage will be removed from sysmodule state during this.
* @param[out] s Output storage.
* @param kind See \ref AppletLaunchParameterKind.
* @note Only available with AppletType_*Application.
* @note See also acc.h \ref accountGetPreselectedUser (wrapper for appletPopLaunchParameter etc).
*/
appletPopLaunchParameter :: (s: *AppletStorage, kind: AppletLaunchParameterKind) -> Result #foreign libnx;

/**
* @brief Requests to launch the specified application.
* @note Only available with AppletType_*Application, or AppletType_LibraryApplet on [5.0.0+].
* @param[in] application_id ApplicationId. Value 0 can be used to relaunch the current application.
* @param[in] s Optional AppletStorage object, can be NULL. This is automatically closed. When NULL on pre-4.0.0 (or with AppletType_LibraryApplet), this will internally create a tmp storage with size 0 for use with the cmd. This is the storage available to the launched application via \ref appletPopLaunchParameter with ::AppletLaunchParameterKind_UserChannel.
*/
appletRequestLaunchApplication :: (application_id: u64, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Requests to launch the specified application, for kiosk systems.
* @note Only available with AppletType_*Application on [3.0.0+].
* @note Identical to \ref appletRequestLaunchApplication, except this allows the user to specify the attribute fields instead of the defaults being used.
* @param[in] application_id ApplicationId
* @param[in] s Optional AppletStorage object, can be NULL. This is automatically closed. When NULL on pre-4.0.0, this will internally create a tmp storage with size 0 for use with the cmd. This is the storage available to the launched application via \ref appletPopLaunchParameter with ::AppletLaunchParameterKind_UserChannel.
* @param[in] attr Kiosk application attributes.
*/
appletRequestLaunchApplicationForQuest :: (application_id: u64, s: *AppletStorage, attr: *AppletApplicationAttributeForQuest) -> Result #foreign libnx;

/**
* @brief Gets the DesiredLanguage for the current host application control.nacp.
* @note Only available with AppletType_*Application.
* @param[out] LanguageCode Output LanguageCode, see set.h.
*/
appletGetDesiredLanguage :: (LanguageCode: *u64) -> Result #foreign libnx;

/**
* @brief Gets the DisplayVersion for the current host application control.nacp.
* @note Only available with AppletType_*Application.
* @param[out] displayVersion Output DisplayVersion string, must be at least 0x10-bytes. This is always NUL-terminated.
*/
appletGetDisplayVersion :: (displayVersion: *u8) -> Result #foreign libnx;

/**
* @brief Blocks the usage of the home button, for short (Home Menu) and long (Overlay) presses.
* @note Only available with AppletType_*Application.
* @param val Unknown. Official sw only uses hard-coded value 0 for this.
*/
appletBeginBlockingHomeButtonShortAndLongPressed :: (val: s64) -> Result #foreign libnx;

/**
* @brief Ends the blocking started by \ref appletBeginBlockingHomeButtonShortAndLongPressed.
* @note Only available with AppletType_*Application.
*/
appletEndBlockingHomeButtonShortAndLongPressed :: () -> Result #foreign libnx;

/**
* @brief Blocks the usage of the home button, for short presses (Home Menu).
* @note Only available with AppletType_*Application.
* @param val Unknown nanoseconds. Value 0 can be used.
*/
appletBeginBlockingHomeButton :: (val: s64) -> Result #foreign libnx;

/**
* @brief Ends the blocking started by \ref appletBeginBlockingHomeButton.
* @note Only available with AppletType_*Application.
*/
appletEndBlockingHomeButton :: () -> Result #foreign libnx;

/**
* @brief Notify that the app is now running, for the Application logo screen. This throws a fatal-error on failure.
* @note This will just return when applet-type isn't AppletType_Application, or when this was already used previously. Used automatically by \ref appletInitialize when __nx_applet_auto_notifyrunning is set to true (the default value).
*/
appletNotifyRunning :: (out: *bool) -> void #foreign libnx;

/**
* @brief Gets the PseudoDeviceId. This is derived from the output of a ns command, and from data in the host application control.nacp.
* @note Only available with AppletType_*Application on [2.0.0+].
* @param[out] out Output PseudoDeviceId.
*/
appletGetPseudoDeviceId :: (out: *Uuid) -> Result #foreign libnx;

/// Set media playback state.
/// If state is set to true, screen dimming and auto sleep is disabled.
/// For *Application, this uses cmd SetMediaPlaybackStateForApplication, otherwise cmd SetMediaPlaybackState is used.
appletSetMediaPlaybackState :: (state: bool) -> Result #foreign libnx;

/// Gets whether video recording is supported.
/// See also \ref appletInitializeGamePlayRecording.
appletIsGamePlayRecordingSupported :: (flag: *bool) -> Result #foreign libnx;

/// Disable/enable video recording. Only available after \ref appletInitializeGamePlayRecording was used.
/// See also \ref appletInitializeGamePlayRecording.
appletSetGamePlayRecordingState :: (state: bool) -> Result #foreign libnx;

/// Initializes video recording. This allocates a 0x6000000-byte buffer for the TransferMemory, cleanup is handled automatically during app exit in \ref appletExit.
/// Only available with AppletType_Application on [3.0.0+], hence errors from this can be ignored.
/// Video recording is only fully available system-side with [4.0.0+].
/// Only usable when running under an application which supports video recording. Using this is only needed when the host application control.nacp has VideoCaptureMode set to Enabled, with Automatic appletInitializeGamePlayRecording is not needed.
appletInitializeGamePlayRecording :: () -> Result #foreign libnx;

/**
* @brief Requests to save the video recording, as if the Capture-button was held.
* @note Only available with AppletType_*Application on [4.0.0+].
*/
appletRequestFlushGamePlayingMovieForDebug :: () -> Result #foreign libnx;

/**
* @brief Requests a system shutdown. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_*Application on [3.0.0+].
*/
appletRequestToShutdown :: () -> Result #foreign libnx;

/**
* @brief Requests a system reboot. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_*Application on [3.0.0+].
*/
appletRequestToReboot :: () -> Result #foreign libnx;

/**
* @brief RequestToSleep
* @note Only available with AppletType_*Application on [10.0.0+].
*/
appletRequestToSleep :: () -> Result #foreign libnx;

/**
* @brief Exit the application and return to the kiosk demo menu. This terminates the current process. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_*Application on [4.0.0+], on kiosk systems (QuestFlag set).
*/
appletExitAndRequestToShowThanksMessage :: () -> Result #foreign libnx;

/**
* @brief Initializes the ApplicationCopyrightFrameBuffer, with dimensions 1280x720 + the tmem for it. This is used as an overlay for screenshots.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note Cleanup for this is handled automatically during app exit in \ref appletExit.
*/
appletInitializeApplicationCopyrightFrameBuffer :: () -> Result #foreign libnx;

/**
* @brief Sets the RGBA8 image for use with \ref appletInitializeApplicationCopyrightFrameBuffer. Overrides the current image, if this was already used previously.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note The specified coordinates and width/height must be within the bounds of the framebuffer setup by \ref appletInitializeApplicationCopyrightFrameBuffer.
* @param[in] buffer Input image buffer.
* @param[in] size Input image buffer size.
* @param[in] x X coordinate. Must not be negative.
* @param[in] y Y coordinate. Must not be negative.
* @param[in] width Image width. Must be >=1.
* @param[in] height Image height. Must be >=1.
* @param[in] mode \ref AppletWindowOriginMode
*/
appletSetApplicationCopyrightImage :: (buffer: *void, size: u64, x: s32, y: s32, width: s32, height: s32, mode: AppletWindowOriginMode) -> Result #foreign libnx;

/**
* @brief Sets the visibility for the image set by \ref appletSetApplicationCopyrightImage, in screenshots.
* @note Only available with AppletType_*Application on [5.0.0+].
* @param[in] visible Whether the image is visible. The default is true.
*/
appletSetApplicationCopyrightVisibility :: (visible: bool) -> Result #foreign libnx;

/**
* @brief Gets ApplicationPlayStatistics.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note The input ApplicationIds must be allowed via control.nacp with the current host application. The minimum allowed ApplicationId is the ApplicationId for the current application.
* @param stats Output \ref PdmApplicationPlayStatistics array.
* @param application_ids Input ApplicationIds array.
* @param count Total entries in the input/output arrays.
* @param total_out Total output entries.
*/
appletQueryApplicationPlayStatistics :: (stats: *PdmApplicationPlayStatistics, application_ids: *u64, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Same as \ref appletQueryApplicationPlayStatistics except this gets playstats specific to the input userId.
* @note Only available with AppletType_*Application on [6.0.0+].
* @param[in] uid \ref AccountUid
* @param[out] stats Output \ref PdmApplicationPlayStatistics array.
* @param[in] application_ids Input ApplicationIds array.
* @param[in] count Total entries in the input/output arrays.
* @param[out] total_out Total output entries.
*/
appletQueryApplicationPlayStatisticsByUid :: (uid: AccountUid, stats: *PdmApplicationPlayStatistics, application_ids: *u64, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Launches Application {current_ApplicationId}+programIndex. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note Creates the storage if needed. Uses cmd ClearUserChannel. Uses cmd UnpopToUserChannel when the storage was created. Lastly cmd ExecuteProgramCmd is used.
* @param[in] programIndex ProgramIndex, must be 0x0-0xFF. 0 is the same as the current application. ProgramIndex values where the application is not installed should not be used.
* @param[in] buffer Optional buffer containing the storage data which will be used for ::AppletLaunchParameterKind_UserChannel with the launched Application, can be NULL.
* @param[in] size Size of the above buffer, 0 to not use the storage. Must be <=0x1000.
*/
appletExecuteProgram :: (programIndex: s32, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Launches the specified ApplicationId.
* @note Only available with AppletType_*Application on [5.0.0+], with DebugMode enabled.
* @note Creates the storage if needed. Uses cmd ClearUserChannel. Uses cmd UnpopToUserChannel when the storage was created. Lastly cmd ExecuteProgramCmd is used.
* @param[in] application_id ApplicationId.
* @param[in] buffer Optional buffer containing the storage data which will be used for ::AppletLaunchParameterKind_UserChannel with the launched Application, can be NULL.
* @param[in] size Size of the above buffer, 0 to not use the storage. Must be <=0x1000.
*/
appletJumpToSubApplicationProgramForDevelopment :: (application_id: u64, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Relaunches the current Application.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note Creates the storage if needed. Uses cmd ClearUserChannel. Uses cmd UnpopToUserChannel when the storage was created. Lastly cmd ExecuteProgramCmd is used.
* @param[in] buffer Optional buffer containing the storage data which will be used for ::AppletLaunchParameterKind_UserChannel with the launched Application, can be NULL.
* @param[in] size Size of the above buffer, 0 to not use the storage. Must be <=0x1000.
*/
appletRestartProgram :: (buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets the ProgramIndex of the program which launched this program.
* @note Only available with AppletType_*Application on [5.0.0+].
* @param[out] programIndex ProgramIndex, -1 when there was no previous program.
*/
appletGetPreviousProgramIndex :: (programIndex: *s32) -> Result #foreign libnx;

/**
* @brief SetDelayTimeToAbortOnGpuError
* @note Only available with AppletType_*Application on [11.0.0+].
* @param[in] val Input nanoseconds value.
*/
appletSetDelayTimeToAbortOnGpuError :: (val: u64) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletTryPopFromFriendInvitationStorageChannel where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note This is used by \ref friendsGetFriendInvitationNotificationEvent.
* @note Only available with AppletType_*Application on [9.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetFriendInvitationStorageChannelEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Pops a storage from the FriendInvitation StorageChannel.
* @note This is used by \ref friendsTryPopFriendInvitationNotificationInfo.
* @note Only available with AppletType_*Application on [9.0.0+].
* @param[out] s Storage object.
*/
appletTryPopFromFriendInvitationStorageChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletTryPopFromNotificationStorageChannel where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note This is used by \ref notifGetNotificationSystemEvent.
* @note Only available with AppletType_*Application on [9.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetNotificationStorageChannelEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Pops a storage from the Notification StorageChannel.
* @note This is used by \ref notifTryPopNotifiedApplicationParameter.
* @note Only available with AppletType_*Application on [9.0.0+].
* @param[out] s Storage object.
*/
appletTryPopFromNotificationStorageChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief GetHealthWarningDisappearedSystemEvent
* @note Only available with AppletType_*Application on [9.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetHealthWarningDisappearedSystemEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief SetHdcpAuthenticationActivated
* @note Only available with AppletType_*Application on [9.0.0+].
* @param[in] flag Whether HdcpAuthentication is activated.
*/
appletSetHdcpAuthenticationActivated :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetLastApplicationExitReason
* @note Only available with AppletType_*Application on [11.0.0+].
* @param[out] out Output value.
*/
appletGetLastApplicationExitReason :: (out: *s32) -> Result #foreign libnx;

/**
* @brief CreateMovieMaker. Do not use this directly, use \ref grcCreateMovieMaker instead.
* @note Only available with AppletType_*Application on [5.0.0+].
* @param[out] srv_out Output Service for applet IMovieMaker.
* @param[in] tmem TransferMemory
*/
appletCreateMovieMaker :: (srv_out: *Service, tmem: *TransferMemory) -> Result #foreign libnx;

/**
* @brief Launches the jit-sysmodule when it was not previously launched by this cmd. Returns 0 when it was previously launched.
* @note Only available with AppletType_*Application on [5.0.0+].
* @note Requires the jit-sysmodule to actually be installed.
*/
appletPrepareForJit :: () -> Result #foreign libnx;

/**
* @brief RequestToGetForeground
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
*/
appletRequestToGetForeground :: () -> Result #foreign libnx;

/**
* @brief LockForeground
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
*/
appletLockForeground :: () -> Result #foreign libnx;

/**
* @brief UnlockForeground
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
*/
appletUnlockForeground :: () -> Result #foreign libnx;

/**
* @brief Pops a storage from the general channel.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
* @param[out] s Storage object.
*/
appletPopFromGeneralChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletPopFromGeneralChannel where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetPopFromGeneralChannelEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets a \ref AppletLockAccessor for HomeButtonWriter.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet.
* @note Similar to using \ref appletGetWriterLockAccessorEx with inval=0.
* @param a LockAccessor object.
*/
appletGetHomeButtonWriterLockAccessor :: (a: *AppletLockAccessor) -> Result #foreign libnx;

/**
* @brief IsSleepEnabled
* @note Only available with AppletType_SystemApplet on [11.0.0+], or on [15.0.0+] with AppletType_LibraryApplet.
* @param[out] out Output flag.
*/
appletIsSleepEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief PopRequestLaunchApplicationForDebug
* @note Only available with AppletType_SystemApplet on [6.0.0+], or on [15.0.0+] with AppletType_LibraryApplet.
* @param[out] uids Output array of \ref AccountUid.
* @param[in] count Size of the uids array in entries, must be at least the size stored in state.
* @param[out] application_id Output ApplicationId.
* @param[out] total_out Total output userID entries.
*/
appletPopRequestLaunchApplicationForDebug :: (uids: *AccountUid, count: s32, application_id: *u64, total_out: *s32) -> Result #foreign libnx;

/**
* @brief IsForceTerminateApplicationDisabledForDebug
* @note Only available with AppletType_SystemApplet on [9.0.0+], or on [15.0.0+] with AppletType_LibraryApplet.
* @param[out] out Output flag. 0 when DebugMode is not enabled, otherwise this is loaded from a system-setting.
*/
appletIsForceTerminateApplicationDisabledForDebug :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Launches DevMenu and the dev Overlay-applet. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_SystemApplet on [8.0.0+], or on [15.0.0+] with AppletType_LibraryApplet.
* @note This verifies that DebugMode is enabled, then uses a ns cmd. That cmd then loads the system-settings for these two ProgramIds (which normally only exist on devunits), and verifies that these programs are installed + launches them.
*/
appletLaunchDevMenu :: () -> Result #foreign libnx;

/**
* @brief SetLastApplicationExitReason
* @note Only available with AppletType_SystemApplet on [11.0.0+], or on [15.0.0+] with AppletType_LibraryApplet.
* @param[in] reason Reason
*/
appletSetLastApplicationExitReason :: (reason: s32) -> Result #foreign libnx;

/**
* @brief Start the sequence for entering sleep-mode.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
* @param[in] flag Flag, official sw uses hard-coded value = true.
*/
appletStartSleepSequence :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Start the system-shutdown sequence.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
*/
appletStartShutdownSequence :: () -> Result #foreign libnx;

/**
* @brief Start the system-reboot sequence.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
*/
appletStartRebootSequence :: () -> Result #foreign libnx;

/**
* @brief IsAutoPowerDownRequested. Uses an idle:sys cmd internally.
* @note Only available with AppletType_SystemApplet on [7.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
* @param[out] out Output flag.
*/
appletIsAutoPowerDownRequested :: (out: *bool) -> Result #foreign libnx;

/**
* @brief LoadAndApplyIdlePolicySettings. Uses an idle:sys cmd internally.
* @note Only available with AppletType_SystemApplet, or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
*/
appletLoadAndApplyIdlePolicySettings :: () -> Result #foreign libnx;

/**
* @brief NotifyCecSettingsChanged. Uses an omm cmd internally.
* @note Only available with AppletType_SystemApplet on [2.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
*/
appletNotifyCecSettingsChanged :: () -> Result #foreign libnx;

/**
* @brief Sets the DefaultHomeButtonLongPressTime.
* @note Only available with AppletType_SystemApplet on [3.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
* @param[in] val Input value.
*/
appletSetDefaultHomeButtonLongPressTime :: (val: s64) -> Result #foreign libnx;

/**
* @brief UpdateDefaultDisplayResolution. Uses an omm cmd internally.
* @note Only available with AppletType_SystemApplet on [3.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
*/
appletUpdateDefaultDisplayResolution :: () -> Result #foreign libnx;

/**
* @brief ShouldSleepOnBoot. Uses an omm cmd internally.
* @note Only available with AppletType_SystemApplet on [3.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
* @param[out] out Output flag.
*/
appletShouldSleepOnBoot :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled for HdcpAuthenticationFailed.
* @note Only available with AppletType_SystemApplet on [4.0.0+], or on [15.0.0+] with AppletType_LibraryApplet/AppletType_OverlayApplet.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetHdcpAuthenticationFailedEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Creates an Application.
* @note Only available with AppletType_SystemApplet.
* @param[out] a \ref AppletApplication
* @param[in] application_id ApplicationId.
*/
appletCreateApplication :: (a: *AppletApplication, application_id: u64) -> Result #foreign libnx;

/**
* @brief Pops a \ref AppletApplication for a requested Application launch.
* @note Only available with AppletType_SystemApplet.
* @param[out] a \ref AppletApplication
*/
appletPopLaunchRequestedApplication :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Creates a SystemApplication.
* @note Only available with AppletType_SystemApplet.
* @param[out] a \ref AppletApplication
* @param[in] system_application_id SystemApplicationId.
*/
appletCreateSystemApplication :: (a: *AppletApplication, system_application_id: u64) -> Result #foreign libnx;

/**
* @brief PopFloatingApplicationForDevelopment.
* @note Only available with AppletType_SystemApplet. Should not be used if no FloatingApplication is available.
* @param[out] a \ref AppletApplication
*/
appletPopFloatingApplicationForDevelopment :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Close an \ref AppletApplication.
* @param a \ref AppletApplication
*/
appletApplicationClose :: (a: *AppletApplication) -> void #foreign libnx;

/**
* @brief Returns whether the AppletApplication object was initialized.
* @param a \ref AppletApplication
*/
appletApplicationActive :: (a: *AppletApplication) -> bool #foreign libnx;

/**
* @brief Starts the Application.
* @param a \ref AppletApplication
*/
appletApplicationStart :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Requests the Application to exit.
* @param a \ref AppletApplication
*/
appletApplicationRequestExit :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Terminate the Application.
* @param a \ref AppletApplication
*/
appletApplicationTerminate :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Waits for the Application to exit.
* @param a \ref AppletApplication
*/
appletApplicationJoin :: (a: *AppletApplication) -> void #foreign libnx;

/**
* @brief Waits on the Application StateChangedEvent with timeout=0, and returns whether it was successful.
* @param a \ref AppletApplication
*/
appletApplicationCheckFinished :: (a: *AppletApplication) -> bool #foreign libnx;

/**
* @brief Gets the \ref AppletApplicationExitReason set by \ref appletApplicationJoin.
* @param a \ref AppletApplication
*/
appletApplicationGetExitReason :: (a: *AppletApplication) -> AppletApplicationExitReason #foreign libnx;

/**
* @brief RequestForApplicationToGetForeground.
* @param a \ref AppletApplication
*/
appletApplicationRequestForApplicationToGetForeground :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief TerminateAllLibraryApplets which were created by the Application.
*/
appletApplicationTerminateAllLibraryApplets :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief AreAnyLibraryAppletsLeft which were created by the Application.
* @param a \ref AppletApplication
* @param[out] out Output flag.
*/
appletApplicationAreAnyLibraryAppletsLeft :: (a: *AppletApplication, out: *bool) -> Result #foreign libnx;

/**
* @brief Calls the same func as \ref appletHolderRequestExitOrTerminate with the output IAppletAccessor from the GetCurrentLibraryApplet cmd.
* @param a \ref AppletApplication
* @param[in] timeout Timeout in nanoseconds. UINT64_MAX for no timeout.
*/
appletApplicationRequestExitLibraryAppletOrTerminate :: (a: *AppletApplication, timeout: u64) -> Result #foreign libnx;

/**
* @brief Gets the ApplicationId for the Application.
* @param a \ref AppletApplication
* @param[out] application_id Output ApplicationId.
*/
appletApplicationGetApplicationId :: (a: *AppletApplication, application_id: *u64) -> Result #foreign libnx;

/**
* @brief Pushes a LaunchParameter AppletStorage to the Application.
* @note This uses \ref appletStorageClose automatically.
* @param a \ref AppletApplication
* @param[in] kind \ref AppletLaunchParameterKind
* @param[in] s Input storage.
*/
appletApplicationPushLaunchParameter :: (a: *AppletApplication, kind: AppletLaunchParameterKind, s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets the \ref NacpStruct for the Application.
* @note Not usable when the \ref AppletApplication is for an AppletType_SystemApplication.
* @param a \ref AppletApplication
* @param[out] nacp \ref NacpStruct
*/
appletApplicationGetApplicationControlProperty :: (a: *AppletApplication, nacp: *NacpStruct) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletApplicationLaunchProperty for the Application.
* @note Only available on [2.0.0+]. Not usable when the \ref AppletApplication is for an AppletType_SystemApplication.
* @param a \ref AppletApplication
* @param[out] out \ref AppletApplicationLaunchProperty
*/
appletApplicationGetApplicationLaunchProperty :: (a: *AppletApplication, out: *AppletApplicationLaunchProperty) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletApplicationLaunchRequestInfo for the Application.
* @note Only available on [6.0.0+].
* @param a \ref AppletApplication
* @param[out] out \ref AppletApplicationLaunchRequestInfo
*/
appletApplicationGetApplicationLaunchRequestInfo :: (a: *AppletApplication, out: *AppletApplicationLaunchRequestInfo) -> Result #foreign libnx;

/**
* @brief SetUsers for the Application.
* @note Only available on [6.0.0+].
* @param a \ref AppletApplication
* @param[in] uids Input array of \ref AccountUid.
* @param[in] count Size of the uids array in entries, must be <=ACC_USER_LIST_SIZE.
* @param[in] flag When this flag is true, this just clears the users_available state flag to 0 and returns.
*/
appletApplicationSetUsers :: (a: *AppletApplication, uids: *AccountUid, count: s32, flag: bool) -> Result #foreign libnx;

/**
* @brief CheckRightsEnvironmentAvailable.
* @note Only available on [6.0.0+].
* @param a \ref AppletApplication
* @param[out] out Output flag.
*/
appletApplicationCheckRightsEnvironmentAvailable :: (a: *AppletApplication, out: *bool) -> Result #foreign libnx;

/**
* @brief GetNsRightsEnvironmentHandle.
* @note Only available on [6.0.0+].
* @param a \ref AppletApplication
* @param[out] handle Output NsRightsEnvironmentHandle.
*/
appletApplicationGetNsRightsEnvironmentHandle :: (a: *AppletApplication, handle: *u64) -> Result #foreign libnx;

/**
* @brief Gets an array of userIds for the Application DesirableUids.
* @note Only available on [6.0.0+].
* @note qlaunch only uses 1 userId with this.
* @param a \ref AppletApplication
* @param[out] uids Output array of \ref AccountUid.
* @param[in] count Size of the uids array in entries, must be at least the size stored in state.
* @param[out] total_out Total output entries.
*/
appletApplicationGetDesirableUids :: (a: *AppletApplication, uids: *AccountUid, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief ReportApplicationExitTimeout.
* @note Only available on [6.0.0+].
* @param a \ref AppletApplication
*/
appletApplicationReportApplicationExitTimeout :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Sets the \ref AppletApplicationAttribute for the Application.
* @note Only available on [8.0.0+].
* @param a \ref AppletApplication
* @param[in] attr \ref AppletApplicationAttribute
*/
appletApplicationSetApplicationAttribute :: (a: *AppletApplication, attr: *AppletApplicationAttribute) -> Result #foreign libnx;

/**
* @brief Gets whether the savedata specified by the input ApplicationId is accessible.
* @note Only available on [8.0.0+].
* @param a \ref AppletApplication
* @param[in] application_id ApplicationId for the savedata.
* @param[out] out Output flag.
*/
appletApplicationHasSaveDataAccessPermission :: (a: *AppletApplication, application_id: u64, out: *bool) -> Result #foreign libnx;

/**
* @brief Creates a storage using the specified input then pushes it to the FriendInvitation StorageChannel.
* @note The system will clear the StorageChannel before pushing the storage.
* @note Only available on [9.0.0+].
* @param a \ref AppletApplication
* @param[in] uid \ref AccountUid
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
*/
appletApplicationPushToFriendInvitationStorageChannel :: (a: *AppletApplication, uid: AccountUid, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Creates a storage using the specified input then pushes it to the Notification StorageChannel.
* @note The system will clear the StorageChannel before pushing the storage.
* @note Only available on [9.0.0+].
* @param a \ref AppletApplication
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
*/
appletApplicationPushToNotificationStorageChannel :: (a: *AppletApplication, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief RequestApplicationSoftReset
* @note Only available on [10.0.0+].
* @param a \ref AppletApplication
*/
appletApplicationRequestApplicationSoftReset :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief RestartApplicationTimer
* @note Only available on [10.0.0+].
* @param a \ref AppletApplication
*/
appletApplicationRestartApplicationTimer :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Pops a storage from current-LibraryApplet input.
* @note Only available with AppletType_LibraryApplet.
* @param[out] s Storage object.
*/
appletPopInData :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pushes a storage for current-LibraryApplet output.
* @note Only available with AppletType_LibraryApplet.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletPushOutData :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pops a storage from current-LibraryApplet Interactive input.
* @note Only available with AppletType_LibraryApplet.
* @param[out] s Storage object.
*/
appletPopInteractiveInData :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Pushes a storage for current-LibraryApplet Interactive output.
* @note Only available with AppletType_LibraryApplet.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletPushInteractiveOutData :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletPopInData where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note Only available with AppletType_LibraryApplet.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetPopInDataEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletPopInteractiveInData where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note Only available with AppletType_LibraryApplet.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetPopInteractiveInDataEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets the \ref LibAppletInfo for the current LibraryApplet.
* @note Only available with AppletType_LibraryApplet.
* @param[out] info \ref LibAppletInfo
*/
appletGetLibraryAppletInfo :: (info: *LibAppletInfo) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletIdentityInfo for the MainApplet.
* @note Only available with AppletType_LibraryApplet.
* @param[out] info \ref AppletIdentityInfo
*/
appletGetMainAppletIdentityInfo :: (info: *AppletIdentityInfo) -> Result #foreign libnx;

/**
* @brief CanUseApplicationCore
* @note Only available with AppletType_LibraryApplet.
* @param[out] out Output flag.
*/
appletCanUseApplicationCore :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletIdentityInfo for the CallerApplet.
* @note Only available with AppletType_LibraryApplet.
* @param[out] info \ref AppletIdentityInfo
*/
appletGetCallerAppletIdentityInfo :: (info: *AppletIdentityInfo) -> Result #foreign libnx;

/**
* @brief Gets the \ref NacpStruct for the MainApplet.
* @note Only available with AppletType_LibraryApplet on [2.0.0+].
* @param[out] nacp \ref NacpStruct
*/
appletGetMainAppletApplicationControlProperty :: (nacp: *NacpStruct) -> Result #foreign libnx;

/**
* @brief Gets the NcmStorageId for the MainApplet.
* @note Only available with AppletType_LibraryApplet on [2.0.0+].
* @param[out] storageId \ref NcmStorageId
*/
appletGetMainAppletStorageId :: (storageId: *NcmStorageId) -> Result #foreign libnx;

/**
* @brief Gets an array of \ref AppletIdentityInfo for the CallerStack.
* @note Only available with AppletType_LibraryApplet on [3.0.0+].
* @param[out] stack Output array of \ref AppletIdentityInfo.
* @param[in] count Size of the stack array.
* @param[out] total_out Total output entries.
*/
appletGetCallerAppletIdentityInfoStack :: (stack: *AppletIdentityInfo, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletIdentityInfo for the NextReturnDestinationApplet.
* @note Only available with AppletType_LibraryApplet on [4.0.0+].
* @param[out] info \ref AppletIdentityInfo
*/
appletGetNextReturnDestinationAppletIdentityInfo :: (info: *AppletIdentityInfo) -> Result #foreign libnx;

/**
* @brief Gets the DesirableKeyboardLayout previously set by \ref appletSetDesirableKeyboardLayout. An error is returned when it's not set.
* @note Only available with AppletType_LibraryApplet on [4.0.0+].
* @param[out] layout Output \ref SetKeyboardLayout.
*/
appletGetDesirableKeyboardLayout :: (layout: *SetKeyboardLayout) -> Result #foreign libnx;

/**
* @brief Pops a storage from current-LibraryApplet Extra input.
* @note Only available with AppletType_LibraryApplet.
* @param[out] s Storage object.
*/
appletPopExtraStorage :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when a new storage is available with \ref appletPopExtraStorage where previously no storage was available, this event is automatically cleared by the system once the last storage is popped.
* @note Only available with AppletType_LibraryApplet.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetPopExtraStorageEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Unpop a storage for current-LibraryApplet input.
* @note Only available with AppletType_LibraryApplet.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletUnpopInData :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Unpop a storage for current-LibraryApplet Extra input.
* @note Only available with AppletType_LibraryApplet.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletUnpopExtraStorage :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets the IndirectLayerProducerHandle.
* @note Only available with AppletType_LibraryApplet on [2.0.0+].
* @param[out] out Output IndirectLayerProducerHandle.
*/
appletGetIndirectLayerProducerHandle :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Gets the DesiredLanguage for the MainApplet.
* @note Only available with AppletType_LibraryApplet on [4.0.0+].
* @param[out] LanguageCode Output LanguageCode, see set.h.
*/
appletGetMainAppletApplicationDesiredLanguage :: (LanguageCode: *u64) -> Result #foreign libnx;

/**
* @brief Gets the ApplicationId for the currently running Application.
* @note Only available with AppletType_LibraryApplet on [8.0.0+].
* @param[out] application_id Output ApplicationId, 0 when no Application is running.
*/
appletGetCurrentApplicationId :: (application_id: *u64) -> Result #foreign libnx;

/**
* @brief Exits the current applet. Same as \ref appletHolderRequestExit except this is for the current applet.
* @note Only available with AppletType_LibraryApplet on [6.0.0+].
*/
appletRequestExitToSelf :: () -> Result #foreign libnx;

/**
* @brief CreateGameMovieTrimmer. Do not use this directly, use \ref grcTrimGameMovie instead.
* @note Only available with AppletType_LibraryApplet on [4.0.0+].
* @note See also \ref appletReserveResourceForMovieOperation and \ref appletUnreserveResourceForMovieOperation.
* @param[out] srv_out Output Service for grc IGameMovieTrimmer.
* @param[in] tmem TransferMemory
*/
appletCreateGameMovieTrimmer :: (srv_out: *Service, tmem: *TransferMemory) -> Result #foreign libnx;

/**
* @brief ReserveResourceForMovieOperation. Must be used at some point prior to \ref appletCreateGameMovieTrimmer.
* @note Only available with AppletType_LibraryApplet on [5.0.0+].
*/
appletReserveResourceForMovieOperation :: () -> Result #foreign libnx;

/**
* @brief UnreserveResourceForMovieOperation. Must be used at some point after all finished with GameMovieTrimmer usage (\ref appletCreateGameMovieTrimmer).
* @note Only available with AppletType_LibraryApplet on [5.0.0+].
*/
appletUnreserveResourceForMovieOperation :: () -> Result #foreign libnx;

/**
* @brief Gets an array of userIds for the MainApplet AvailableUsers.
* @note Only available with AppletType_LibraryApplet on [6.0.0+].
* @param[out] uids Output array of \ref AccountUid.
* @param[in] count Size of the uids array in entries, must be at least ACC_USER_LIST_SIZE.
* @param[out] flag When true, this indicates that no users are available.
* @param[out] total_out Total output entries. This is -1 when flag is true.
*/
appletGetMainAppletAvailableUsers :: (uids: *AccountUid, count: s32, flag: *bool, total_out: *s32) -> Result #foreign libnx;

/**
* @brief SetApplicationMemoryReservation
* @note Only available with AppletType_LibraryApplet on [10.0.0+].
* @note An Application must be currently running.
* @param[in] val Input value.
*/
appletSetApplicationMemoryReservation :: (val: u64) -> Result #foreign libnx;

/**
* @brief ShouldSetGpuTimeSliceManually
* @note Only available with AppletType_LibraryApplet on [10.0.0+].
* @param[out] out Output flag.
*/
appletShouldSetGpuTimeSliceManually :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Stops forwarding the input to the foreground app.
* @note Only available with AppletType_OverlayApplet.
* @note You have to call this to receive inputs through the hid service when running as the overlay applet.
*/
appletBeginToWatchShortHomeButtonMessage :: () -> Result #foreign libnx;

/**
* @brief Forwards input to the foreground app.
* @note Only available with AppletType_OverlayApplet.
* @note After calling this the overlay applet won't receive any input until \ref appletBeginToWatchShortHomeButtonMessage is called again.
*/
appletEndToWatchShortHomeButtonMessage :: () -> Result #foreign libnx;

/**
* @brief Gets the ApplicationId for displaying the logo screen during application launch.
* @note Only available with AppletType_OverlayApplet.
* @param[out] application_id Output ApplicationId, 0 when no application is running.
*/
appletGetApplicationIdForLogo :: (application_id: *u64) -> Result #foreign libnx;

/**
* @brief Sets the GpuTimeSliceBoost.
* @note Only available with AppletType_OverlayApplet.
* @param[in] val Input value.
*/
appletSetGpuTimeSliceBoost :: (val: u64) -> Result #foreign libnx;

/**
* @brief Sets AutoSleepTimeAndDimmingTimeEnabled.
* @note Only available with AppletType_OverlayApplet on [2.0.0+].
* @param[in] flag Flag
*/
appletSetAutoSleepTimeAndDimmingTimeEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief TerminateApplicationAndSetReason
* @note Only available with AppletType_OverlayApplet on [2.0.0+].
* @param[in] reason Result reason.
*/
appletTerminateApplicationAndSetReason :: (reason: Result) -> Result #foreign libnx;

/**
* @brief Sets ScreenShotPermissionGlobally.
* @note Only available with AppletType_OverlayApplet on [3.0.0+].
* @param[in] flag Flag
*/
appletSetScreenShotPermissionGlobally :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Start the system-shutdown sequence. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_OverlayApplet on [6.0.0+].
*/
appletStartShutdownSequenceForOverlay :: () -> Result #foreign libnx;

/**
* @brief Start the system-reboot sequence. This will enter an infinite-sleep-loop on success.
* @note Only available with AppletType_OverlayApplet on [6.0.0+].
*/
appletStartRebootSequenceForOverlay :: () -> Result #foreign libnx;

/**
* @brief SetHealthWarningShowingState
* @note Only available with AppletType_OverlayApplet on [9.0.0+].
* @param[in] flag Flag
*/
appletSetHealthWarningShowingState :: (flag: bool) -> Result #foreign libnx;

/**
* @brief IsHealthWarningRequired
* @note Only available with AppletType_OverlayApplet on [10.0.0+].
* @param[out] out Output flag.
*/
appletIsHealthWarningRequired :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Enables HID input for the OverlayApplet, without disabling input for the foreground applet. Generally \ref appletBeginToWatchShortHomeButtonMessage / appletEndToWatchShortHomeButtonMessage should be used instead.
* @note Only available with AppletType_OverlayApplet on [5.0.0+].
*/
appletBeginToObserveHidInputForDevelop :: () -> Result #foreign libnx;

/**
* @brief Reads the ThemeStorage for the current applet.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [7.0.0+].
* @note offset(+size) must be <=0x400.
* @param[out] buffer Output buffer data.
* @param[in] size Size to read.
* @param[in] offset Offset within the ThemeStorage.
* @param[out] transfer_size Actual read size.
*/
appletReadThemeStorage :: (buffer: *void, size: u64, offset: u64, transfer_size: *u64) -> Result #foreign libnx;

/**
* @brief Writes the ThemeStorage for the current applet.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [7.0.0+].
* @note offset(+size) must be <=0x400.
* @param[in] buffer Input buffer data.
* @param[in] size Size to write.
* @param[in] offset Offset within the ThemeStorage.
*/
appletWriteThemeStorage :: (buffer: *void, size: u64, offset: u64) -> Result #foreign libnx;

/**
* @brief This is similar to \ref appletPushToAppletBoundChannelForDebug (no DebugMode check), except the used channel is loaded from elsewhere and must be in the range 31-32.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [9.0.0+].
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
*/
appletPushToAppletBoundChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief This is similar to \ref appletTryPopFromAppletBoundChannelForDebug (no DebugMode check), except the used channel is loaded from elsewhere and must be in the range 31-32.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [9.0.0+].
* @param[out] s Storage object.
*/
appletTryPopFromAppletBoundChannel :: (s: *AppletStorage) -> Result #foreign libnx;

/**
* @brief Gets the DisplayLogicalResolution.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [8.0.0+].
* @param[out] width Output width.
* @param[out] height Output height.
*/
appletGetDisplayLogicalResolution :: (width: *s32, height: *s32) -> Result #foreign libnx;

/**
* @brief Sets the DisplayMagnification. This is essentially layer image crop, for everything non-Overlay.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [8.0.0+].
* @note x and width are multiplied with the same width value returned by \ref appletGetDisplayLogicalResolution, so these should be in the range 0.0f-1.0f. Likewise for y and height, except these are multipled with the height value.
* @param[in] x X position.
* @param[in] y Y position.
* @param[in] width Width.
* @param[in] height Height.
*/
appletSetDisplayMagnification :: (x: float, y: float, width: float, height: float) -> Result #foreign libnx;

/**
* @brief Sets whether HomeButtonDoubleClick is enabled.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [8.0.0+].
* @param[in] flag Flag
*/
appletSetHomeButtonDoubleClickEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets whether HomeButtonDoubleClick is enabled.
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [8.0.0+].
* @param[out] out Output flag.
*/
appletGetHomeButtonDoubleClickEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief IsHomeButtonShortPressedBlocked
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [10.0.0+].
* @param[out] out Output flag.
*/
appletIsHomeButtonShortPressedBlocked :: (out: *bool) -> Result #foreign libnx;

/**
* @brief IsVrModeCurtainRequired
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [11.0.0+].
* @param[out] out Output flag.
*/
appletIsVrModeCurtainRequired :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetCpuBoostRequestPriority
* @note Only available with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [11.0.0+].
* @param[in] priority Priority
*/
appletSetCpuBoostRequestPriority :: (priority: s32) -> Result #foreign libnx;

/**
* @brief Open an \ref AppletApplication for the currently running Application.
* @note Should not be used when no Application is running.
* @note Only available on [1.0.0-9.2.0].
* @param[out] a \ref AppletApplication
*/
appletOpenMainApplication :: (a: *AppletApplication) -> Result #foreign libnx;

/**
* @brief Perform SystemButtonPressing with the specified \ref AppletSystemButtonType.
* @param[in] type \ref AppletSystemButtonType
*/
appletPerformSystemButtonPressing :: (type: AppletSystemButtonType) -> Result #foreign libnx;

/**
* @brief InvalidateTransitionLayer.
*/
appletInvalidateTransitionLayer :: () -> Result #foreign libnx;

/**
* @brief Requests to launch the specified Application, with the specified users.
* @note Only available on [6.0.0+].
* @param[in] application_id ApplicationId.
* @param[in] uids Input array of \ref AccountUid.
* @param[in] total_uids Total input uids, must be <=ACC_USER_LIST_SIZE.
* @param[in] flag Whether to use the specified buffer to create a storage which will be pushed for ::AppletLaunchParameterKind_UserChannel.
* @param[in] buffer Buffer containing the above storage data.
* @param[in] size Size of the storage buffer.
*/
appletRequestLaunchApplicationWithUserAndArgumentForDebug :: (application_id: u64, uids: *AccountUid, total_uids: s32, flag: bool, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets the \ref AppletResourceUsageInfo.
* @note Only available on [6.0.0+].
* @param[out] info \ref AppletResourceUsageInfo
*/
appletGetAppletResourceUsageInfo :: (info: *AppletResourceUsageInfo) -> Result #foreign libnx;

/**
* @brief The channel must match the value already stored in state when the state value is non-zero, otherwise an error is returned. When the state value is 0, the channel is written into state. Then the input storage is pushed to the StorageChannel.
* @note Only available on [9.0.0+]. DebugMode must be enabled.
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
* @param[in] channel Channel.
*/
appletPushToAppletBoundChannelForDebug :: (s: *AppletStorage, channel: s32) -> Result #foreign libnx;

/**
* @brief The channel must not be 0 and must match the value previously saved by \ref appletPushToAppletBoundChannelForDebug, otherwise errors are returned. Then the output storage is popped from the StorageChannel.
* @note Only available on [9.0.0+]. DebugMode must be enabled.
* @param[out] s Storage object.
* @param[in] channel Channel.
*/
appletTryPopFromAppletBoundChannelForDebug :: (s: *AppletStorage, channel: s32) -> Result #foreign libnx;

/**
* @brief Clears a StorageChannel, pushes the input storage there, and writes the ApplicationId into state.
* @note Only available on [9.0.0+].
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
* @param[in] application_id ApplicationId
*/
appletAlarmSettingNotificationEnableAppEventReserve :: (s: *AppletStorage, application_id: u64) -> Result #foreign libnx;

/**
* @brief Clears the StorageChannel/saved-ApplicationId used by \ref appletAlarmSettingNotificationEnableAppEventReserve.
* @note Only available on [9.0.0+].
*/
appletAlarmSettingNotificationDisableAppEventReserve :: () -> Result #foreign libnx;

/**
* @brief Same as \ref appletApplicationPushToNotificationStorageChannel except this uses the MainApplication.
* @note Only available on [9.0.0+].
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
*/
appletAlarmSettingNotificationPushAppEventNotify :: (buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Clears a StorageChannel, pushes the input storage there, and writes the ApplicationId into state.
* @note Only available on [9.0.0+].
* @note This uses \ref appletStorageClose automatically.
* @param[in] s Storage object.
* @param[in] application_id ApplicationId
*/
appletFriendInvitationSetApplicationParameter :: (s: *AppletStorage, application_id: u64) -> Result #foreign libnx;

/**
* @brief Clears the StorageChannel/saved-ApplicationId used by \ref appletFriendInvitationSetApplicationParameter.
* @note Only available on [9.0.0+].
*/
appletFriendInvitationClearApplicationParameter :: () -> Result #foreign libnx;

/**
* @brief Same as \ref appletApplicationPushToFriendInvitationStorageChannel except this uses the MainApplication.
* @note Only available on [9.0.0+].
* @param[in] uid \ref AccountUid
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
*/
appletFriendInvitationPushApplicationParameter :: (uid: AccountUid, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief SetTerminateResult
* @note Only available with AppletType_*Application. Or with AppletType_SystemApplet, AppletType_LibraryApplet, or AppletType_OverlayApplet, on [9.0.0+].
* @param[in] res Result
*/
appletSetTerminateResult :: (res: Result) -> Result #foreign libnx;

/**
* @brief Gets the LaunchStorageInfo.
* @note Only available with AppletType_*Application on [2.0.0+], or with AppletType_LibraryApplet on [9.0.0+].
* @param[out] app_storageId Same as AppletApplicationLaunchProperty::app_storageId.
* @param[out] update_storageId Same as AppletApplicationLaunchProperty::update_storageId.
*/
appletGetLaunchStorageInfoForDebug :: (app_storageId: *NcmStorageId, update_storageId: *NcmStorageId) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled for GpuErrorDetected.
* @note Only available with AppletType_*Application on [8.0.0+], or with AppletType_LibraryApplet on [9.0.0+].
* @note The Event must be closed by the user once finished with it.
* @note Official sw waits on this Event from a seperate thread, triggering an abort when it's signaled.
* @param[out] out_event Output Event with autoclear=false.
*/
appletGetGpuErrorDetectedSystemEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Sets HandlingHomeButtonShortPressedEnabled.
* @note Only available with AppletType_OverlayApplet on [8.0.0+]. Or with non-AppletType_OverlayApplet on [9.1.0+].
* @param[in] flag Flag
*/
appletSetHandlingHomeButtonShortPressedEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets the cached \ref AppletInfo loaded during \ref appletInitialize. This will return NULL when the info is not initialized, due to not running as AppletType_LibraryApplet, or when any of the used cmds fail.
* @note Only available with AppletType_LibraryApplet.
*/
appletGetAppletInfo :: () -> *AppletInfo #foreign libnx;

/**
* @brief Gets the event associated with notification messages.
*/
appletGetMessageEvent :: () -> *Event #foreign libnx;

/**
* @brief Gets a notification message, see \ref AppletMessage.
*/
appletGetMessage :: (msg: *u32) -> Result #foreign libnx;

/**
* @brief Processes the current applet status using the specified msg.
* @param msg Notification message, normally from \ref appletGetMessage.
* @return Whether the application should continue running.
*/
appletProcessMessage :: (msg: u32) -> bool #foreign libnx;

/**
* @brief Processes the current applet status. Generally used within a main loop.
* @note Uses \ref appletGetMessage and \ref appletProcessMessage internally.
* @return Whether the application should continue running.
*/
appletMainLoop :: () -> bool #foreign libnx;

/**
* @brief Sets up an applet status hook.
* @param cookie Hook cookie to use.
* @param callback Function to call when applet's status changes.
* @param param User-defined parameter to pass to the callback.
*/
appletHook :: (cookie: *AppletHookCookie, callback: AppletHookFn, param: *void) -> void #foreign libnx;

/**
* @brief Removes an applet status hook.
* @param cookie Hook cookie to remove.
*/
appletUnhook :: (cookie: *AppletHookCookie) -> void #foreign libnx;

/// These return state which is updated by appletMainLoop() when notifications are received.
appletGetOperationMode :: () -> AppletOperationMode #foreign libnx;
appletGetPerformanceMode :: () -> ApmPerformanceMode #foreign libnx;
appletGetFocusState :: () -> AppletFocusState #foreign libnx;

/**
* @brief Sets the current \ref AppletFocusHandlingMode.
* @note Should only be called with AppletType_Application.
*/
appletSetFocusHandlingMode :: (mode: AppletFocusHandlingMode) -> Result #foreign libnx;

/// Error type for ErrorCommonHeader.type.
ErrorType :: enum u32 {
    Normal           :: 0;
    System           :: 1;
    Application      :: 2;
    Eula             :: 3;
    Pctl             :: 4;
    Record           :: 5;
    SystemUpdateEula :: 8;
}

/// Stores error-codes which are displayed as XXXX-XXXX, low for the former and desc for the latter.
ErrorCode :: struct {
    low:  u32; ///< The module portion of the error, normally this should be set to module + 2000.
    desc: u32; ///< The error description.
}

/// Error type for ErrorContext.type
ErrorContextType :: enum u32 {
    None              :: 0;
    Http              :: 1;
    FileSystem        :: 2;
    WebMediaPlayer    :: 3;
    LocalContentShare :: 4;
}

/// Error context.
ErrorContext :: struct {
    type: u8; ///< Type, see \ref ErrorContextType.
    pad:  [7] u8; ///< Padding
    data: [500] u8; ///< Data
    res:  Result; ///< Result
}

/// Common header for the start of the arg storage.
ErrorCommonHeader :: struct {
    type:         u8; ///< Type, see \ref ErrorType.
    jumpFlag:     u8; ///< When clear, this indicates WithoutJump.
    unk_x2:       [3] u8; ///< Unknown
    contextFlag:  u8; ///< When set with ::ErrorType_Normal, indicates that an additional storage is pushed for \ref ErrorResultBacktrace. [4.0.0+] Otherwise, when set indicates that an additional storage is pushed for \ref ErrorContext.
    resultFlag:   u8; ///< ErrorCommonArg: When clear, errorCode is used, otherwise the applet generates the error-code from res.
    contextFlag2: u8; ///< Similar to contextFlag except for ErrorCommonArg, indicating \ref ErrorContext is used.
}

/// Common error arg data.
ErrorCommonArg :: struct {
    hdr:       ErrorCommonHeader; ///< Common header.
    errorCode: ErrorCode; ///< \ref ErrorCode
    res:       Result; ///< Result
}

/// Error arg data for certain errors with module PCTL.
ErrorPctlArg :: struct {
    hdr: ErrorCommonHeader; ///< Common header.
    res: Result; ///< Result
}

/// ResultBacktrace
ErrorResultBacktrace :: struct {
    count:     s32; ///< Total entries in the backtrace array.
    backtrace: [32] Result; ///< Result backtrace.
}

/// Error arg data for EULA.
ErrorEulaArg :: struct {
    hdr:        ErrorCommonHeader; ///< Common header.
    regionCode: SetRegion; ///< \ref SetRegion
}

/// Additional input storage data for \ref errorSystemUpdateEulaShow.
ErrorEulaData :: struct {
    data: [131072] u8; ///< data
}

/// Error arg data for Record.
ErrorRecordArg :: struct {
    hdr:       ErrorCommonHeader; ///< Common header.
    errorCode: ErrorCode; ///< \ref ErrorCode
    timestamp: u64; ///< POSIX timestamp.
}

/// SystemErrorArg
ErrorSystemArg :: struct {
    hdr:               ErrorCommonHeader; ///< Common header.
    errorCode:         ErrorCode; ///< \ref ErrorCode
    languageCode:      u64; ///< See set.h.
    dialogMessage:     [2048] u8; ///< UTF-8 Dialog message.
    fullscreenMessage: [2048] u8; ///< UTF-8 Fullscreen message (displayed when the user clicks on "Details").
}

/// Error system config.
ErrorSystemConfig :: struct {
    arg: ErrorSystemArg; ///< Arg data.
    ctx: ErrorContext; ///< Optional error context.
}

/// ApplicationErrorArg
ErrorApplicationArg :: struct {
    hdr:               ErrorCommonHeader; ///< Common header.
    errorNumber:       u32; ///< Raw decimal error number which is displayed in the dialog.
    languageCode:      u64 #align 4; ///< See set.h.
    dialogMessage:     [2048] u8; ///< UTF-8 Dialog message.
    fullscreenMessage: [2048] u8; ///< UTF-8 Fullscreen message (displayed when the user clicks on "Details").
}

/// Error application config.
ErrorApplicationConfig :: struct {
    arg: ErrorApplicationArg; ///< Arg data.
}

/**
* @brief Launches the applet for displaying the specified Result.
* @param res Result
* @param jumpFlag Jump flag, normally this is true.
* @param ctx Optional \ref ErrorContext, can be NULL. Unused when jumpFlag=false. Ignored on pre-4.0.0, since it's only available for [4.0.0+].
* @note Sets the following fields: jumpFlag and contextFlag2. Uses ::ErrorType_Normal normally.
* @note For module=PCTL errors with desc 100-119 this sets uses ::ErrorType_Pctl, in which case the applet will display the following special dialog: "This software is restricted by Parental Controls".
* @note If the input Result is 0xC8A2, the applet will display a special dialog regarding the current application requiring a software update, with buttons "Later" and "Restart".
* @note [3.0.0+] If the input Result is 0xCAA2, the applet will display a special dialog related to DLC version.
* @warning This applet creates an error report that is logged in the system, when not handling the above special dialogs. Proceed at your own risk!
*/
errorResultShow :: (res: Result, jumpFlag: bool, ctx: *ErrorContext) -> Result #foreign libnx;

/**
* @brief Launches the applet for displaying the specified ErrorCode.
* @param errorCode \ref ErrorCode
* @param jumpFlag Jump flag, normally this is true.
* @param ctx Optional \ref ErrorContext, can be NULL. Unused when jumpFlag=false. Ignored on pre-4.0.0, since it's only available for [4.0.0+].
* @note Sets the following fields: jumpFlag and contextFlag2. resultFlag=1. Uses ::ErrorType_Normal.
* @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
*/
errorCodeShow :: (errorCode: ErrorCode, jumpFlag: bool, ctx: *ErrorContext) -> Result #foreign libnx;

/**
* @brief Creates an ErrorResultBacktrace struct.
* @param backtrace \ref ErrorResultBacktrace struct.
* @param count Total number of entries.
* @param entries Input array of Result.
*/
errorResultBacktraceCreate :: (backtrace: *ErrorResultBacktrace, count: s32, entries: *Result) -> Result #foreign libnx;

/**
* @brief Launches the applet for \ref ErrorResultBacktrace.
* @param backtrace ErrorResultBacktrace struct.
* @param res Result
* @note Sets the following fields: jumpFlag=1, contextFlag=1, and uses ::ErrorType_Normal.
* @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
*/
errorResultBacktraceShow :: (res: Result, backtrace: *ErrorResultBacktrace) -> Result #foreign libnx;

/**
* @brief Launches the applet for displaying the EULA.
* @param RegionCode \ref SetRegion
* @note Sets the following fields: jumpFlag=1, regionCode, and uses ::ErrorType_Eula.
*/
errorEulaShow :: (RegionCode: SetRegion) -> Result #foreign libnx;

/**
* @brief Launches the applet for displaying the system-update EULA.
* @param RegionCode \ref SetRegion
* @param eula EULA data. Address must be 0x1000-byte aligned.
* @note Sets the following fields: jumpFlag=1, regionCode, and uses ::ErrorType_SystemUpdateEula.
*/
errorSystemUpdateEulaShow :: (RegionCode: SetRegion, eula: *ErrorEulaData) -> Result #foreign libnx;

/**
* @brief Launches the applet for displaying an error full-screen, using the specified ErrorCode and timestamp.
* @param errorCode \ref ErrorCode
* @param timestamp POSIX timestamp.
* @note Sets the following fields: jumpFlag=1, errorCode, timestamp, and uses ::ErrorType_Record.
* @note The applet does not log an error report for this. error*RecordShow is used by qlaunch for displaying previously logged error reports.
*/
errorCodeRecordShow :: (errorCode: ErrorCode, timestamp: u64) -> Result #foreign libnx;

/**
* @brief Creates an ErrorSystemConfig struct.
* @param c ErrorSystemConfig struct.
* @param dialog_message UTF-8 dialog message.
* @param fullscreen_message UTF-8 fullscreen message, displayed when the user clicks on "Details". Optional, can be NULL (which disables displaying Details).
* @note Sets the following fields: {strings}, and uses ::ErrorType_System. The rest are cleared.
* @note On pre-5.0.0 this will initialize languageCode by using: setInitialize(), setMakeLanguageCode(SetLanguage_ENUS, ...), and setExit(). This is needed since an empty languageCode wasn't supported until [5.0.0+] (which would also use SetLanguage_ENUS).
* @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
*/
errorSystemCreate :: (c: *ErrorSystemConfig, dialog_message: *u8, fullscreen_message: *u8) -> Result #foreign libnx;

/**
* @brief Launches the applet with the specified config.
* @param c ErrorSystemConfig struct.
*/
errorSystemShow :: (c: *ErrorSystemConfig) -> Result #foreign libnx;

/**
* @brief Sets the ErrorContext.
* @note Only available on [4.0.0+], on older versions this will return without setting the context.
* @param c   ErrorSystemConfig struct.
* @param ctx ErrorContext, NULL to clear it.
*/
errorSystemSetContext :: (c: *ErrorSystemConfig, ctx: *ErrorContext) -> void #foreign libnx;

/**
* @brief Creates an ErrorApplicationConfig struct.
* @param c ErrorApplicationConfig struct.
* @param dialog_message UTF-8 dialog message.
* @param fullscreen_message UTF-8 fullscreen message, displayed when the user clicks on "Details". Optional, can be NULL (which disables displaying Details).
* @note Sets the following fields: jumpFlag=1, {strings}, and uses ::ErrorType_Application. The rest are cleared.
* @note On pre-5.0.0 this will initialize languageCode by using: setInitialize(), setMakeLanguageCode(SetLanguage_ENUS, ...), and setExit(). This is needed since an empty languageCode wasn't supported until [5.0.0+] (which would also use SetLanguage_ENUS).
* @note With [10.0.0+] this must only be used when running under an Application, since otherwise the applet will trigger a fatalerr.
* @warning This applet creates an error report that is logged in the system. Proceed at your own risk!
*/
errorApplicationCreate :: (c: *ErrorApplicationConfig, dialog_message: *u8, fullscreen_message: *u8) -> Result #foreign libnx;

/**
* @brief Launches the applet with the specified config.
* @param c ErrorApplicationConfig struct.
*/
errorApplicationShow :: (c: *ErrorApplicationConfig) -> Result #foreign libnx;

/// AsyncValue
AsyncValue :: struct {
    s:     Service; ///< IAsyncValue
    event: Event; ///< Event with autoclear=false.
}

/// AsyncResult
AsyncResult :: struct {
    s:     Service; ///< IAsyncResult
    event: Event; ///< Event with autoclear=false.
}

/**
* @brief Close a \ref AsyncValue.
* @note When the object is initialized, this uses \ref asyncValueCancel then \ref asyncValueWait with timeout=UINT64_MAX.
* @param a \ref AsyncValue
*/
asyncValueClose :: (a: *AsyncValue) -> void #foreign libnx;

/**
* @brief Waits for the async operation to finish using the specified timeout.
* @param a \ref AsyncValue
* @param[in] timeout Timeout in nanoseconds. UINT64_MAX for no timeout.
*/
asyncValueWait :: (a: *AsyncValue, timeout: u64) -> Result #foreign libnx;

/**
* @brief Gets the value size.
* @param a \ref AsyncValue
* @param[out] size Output size.
*/
asyncValueGetSize :: (a: *AsyncValue, size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the value.
* @note Prior to using the cmd, this uses \ref asyncResultWait with timeout=UINT64_MAX.
* @param a \ref AsyncValue
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size.
*/
asyncValueGet :: (a: *AsyncValue, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Cancels the async operation.
* @note Used automatically by \ref asyncValueClose.
* @param a \ref AsyncValue
*/
asyncValueCancel :: (a: *AsyncValue) -> Result #foreign libnx;

/**
* @brief Gets the \ref ErrorContext.
* @note Only available on [4.0.0+].
* @param a \ref AsyncValue
* @param[out] context \ref ErrorContext
*/
asyncValueGetErrorContext :: (a: *AsyncValue, _context: *ErrorContext) -> Result #foreign libnx;

/**
* @brief Close a \ref AsyncResult.
* @note When the object is initialized, this uses \ref asyncResultCancel then \ref asyncResultWait with timeout=UINT64_MAX.
* @param a \ref AsyncResult
*/
asyncResultClose :: (a: *AsyncResult) -> void #foreign libnx;

/**
* @brief Waits for the async operation to finish using the specified timeout.
* @param a \ref AsyncResult
* @param[in] timeout Timeout in nanoseconds. UINT64_MAX for no timeout.
*/
asyncResultWait :: (a: *AsyncResult, timeout: u64) -> Result #foreign libnx;

/**
* @brief Gets the Result.
* @note Prior to using the cmd, this uses \ref asyncResultWait with timeout=UINT64_MAX.
* @param a \ref AsyncResult
*/
asyncResultGet :: (a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief Cancels the async operation.
* @note Used automatically by \ref asyncResultClose.
* @param a \ref AsyncResult
*/
asyncResultCancel :: (a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief Gets the \ref ErrorContext.
* @note Only available on [4.0.0+].
* @param a \ref AsyncResult
* @param[out] context \ref ErrorContext
*/
asyncResultGetErrorContext :: (a: *AsyncResult, _context: *ErrorContext) -> Result #foreign libnx;

/// PcmFormat
PcmFormat :: enum u32 {
    Invalid :: 0;
    Int8    :: 1;
    Int16   :: 2;
    Int24   :: 3;
    Int32   :: 4;
    Float   :: 5;
    Adpcm   :: 6;
}

/// AudioDeviceName
AudioDeviceName :: struct {
    name: [256] u8;
}

AudioTarget :: enum u32 {
    Invalid         :: 0;
    Speaker         :: 1;
    Headphone       :: 2;
    Tv              :: 3;
    UsbOutputDevice :: 4;
    Bluetooth       :: 5;
}

AudioOutputMode :: enum u32 {
    Invalid :: 0;
    Pcm1ch  :: 1;
    Pcm2ch  :: 2;
    Pcm6ch  :: 3;
    PcmAuto :: 4;
}

AudioForceMutePolicy :: enum u32 {
    Disable                         :: 0;
    SpeakerMuteOnHeadphoneUnplugged :: 1;
}

AudioHeadphoneOutputLevelMode :: enum u32 {
    Normal    :: 0;
    HighPower :: 1;
}

audctlInitialize :: () -> Result #foreign libnx;
audctlExit :: () -> void #foreign libnx;
audctlGetServiceSession :: () -> *Service #foreign libnx;

audctlGetTargetVolume :: (volume_out: *s32, target: AudioTarget) -> Result #foreign libnx;
audctlSetTargetVolume :: (target: AudioTarget, volume: s32) -> Result #foreign libnx;
audctlGetTargetVolumeMin :: (volume_out: *s32) -> Result #foreign libnx;
audctlGetTargetVolumeMax :: (volume_out: *s32) -> Result #foreign libnx;
audctlIsTargetMute :: (mute_out: *bool, target: AudioTarget) -> Result #foreign libnx;
audctlSetTargetMute :: (target: AudioTarget, mute: bool) -> Result #foreign libnx;
audctlIsTargetConnected :: (connected_out: *bool, target: AudioTarget) -> Result #foreign libnx;
audctlSetDefaultTarget :: (target: AudioTarget, fade_in_ns: u64, fade_out_ns: u64) -> Result #foreign libnx;
audctlGetDefaultTarget :: (target_out: *AudioTarget) -> Result #foreign libnx;
audctlGetAudioOutputMode :: (mode_out: *AudioOutputMode, target: AudioTarget) -> Result #foreign libnx;
audctlSetAudioOutputMode :: (target: AudioTarget, mode: AudioOutputMode) -> Result #foreign libnx;
audctlSetForceMutePolicy :: (policy: AudioForceMutePolicy) -> Result #foreign libnx;
audctlGetForceMutePolicy :: (policy_out: *AudioForceMutePolicy) -> Result #foreign libnx;
audctlGetOutputModeSetting :: (mode_out: *AudioOutputMode, target: AudioTarget) -> Result #foreign libnx;
audctlSetOutputModeSetting :: (target: AudioTarget, mode: AudioOutputMode) -> Result #foreign libnx;
audctlSetOutputTarget :: (target: AudioTarget) -> Result #foreign libnx;
audctlSetInputTargetForceEnabled :: (enable: bool) -> Result #foreign libnx;
audctlSetHeadphoneOutputLevelMode :: (mode: AudioHeadphoneOutputLevelMode) -> Result #foreign libnx;
audctlGetHeadphoneOutputLevelMode :: (mode_out: *AudioHeadphoneOutputLevelMode) -> Result #foreign libnx;
audctlAcquireAudioVolumeUpdateEventForPlayReport :: (event_out: *Event) -> Result #foreign libnx;
audctlAcquireAudioOutputDeviceUpdateEventForPlayReport :: (event_out: *Event) -> Result #foreign libnx;
audctlGetAudioOutputTargetForPlayReport :: (target_out: *AudioTarget) -> Result #foreign libnx;
audctlNotifyHeadphoneVolumeWarningDisplayedEvent :: () -> Result #foreign libnx;
audctlSetSystemOutputMasterVolume :: (volume: float) -> Result #foreign libnx;
audctlGetSystemOutputMasterVolume :: (volume_out: *float) -> Result #foreign libnx;
audctlGetActiveOutputTarget :: (target: *AudioTarget) -> Result #foreign libnx;

AudioInState :: enum u32 {
    Started :: 0;
    Stopped :: 1;
}

AudioInBuffer :: struct {
    next:        *AudioInBuffer; ///< Next buffer. (Unused)
    buffer:      *void; ///< Sample buffer (aligned to 0x1000 bytes).
    buffer_size: u64; ///< Sample buffer size (aligned to 0x1000 bytes).
    data_size:   u64; ///< Size of data inside the buffer.
    data_offset: u64; ///< Offset of data inside the buffer. (Unused?)
}

/// Initialize audin.
audinInitialize :: () -> Result #foreign libnx;

/// Exit audin.
audinExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual audin service session.
audinGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for IAudioIn.
audinGetServiceSession_AudioIn :: () -> *Service #foreign libnx;

audinListAudioIns :: (DeviceNames: *u8, count: s32, DeviceNamesCount: *u32) -> Result #foreign libnx;
audinOpenAudioIn :: (DeviceNameIn: *u8, DeviceNameOut: *u8, SampleRateIn: u32, ChannelCountIn: u32, SampleRateOut: *u32, ChannelCountOut: *u32, Format: *PcmFormat, State: *AudioInState) -> Result #foreign libnx;
audinGetAudioInState :: (State: *AudioInState) -> Result #foreign libnx;
audinStartAudioIn :: () -> Result #foreign libnx;
audinStopAudioIn :: () -> Result #foreign libnx;

/// Submits an \ref AudioInBuffer for capturing.
audinAppendAudioInBuffer :: (Buffer: *AudioInBuffer) -> Result #foreign libnx;

audinGetReleasedAudioInBuffer :: (Buffer: **AudioInBuffer, ReleasedBuffersCount: *u32) -> Result #foreign libnx;
audinContainsAudioInBuffer :: (Buffer: *AudioInBuffer, ContainsBuffer: *bool) -> Result #foreign libnx;

/**
* @brief Submits an audio sample data buffer for capturing and waits for it to finish capturing.
* @brief Uses \ref audinAppendAudioInBuffer and \ref audinWaitCaptureFinish internally.
* @param source AudioInBuffer containing the buffer to hold the captured sample data.
* @param released AudioInBuffer to receive the captured buffer after being released.
*/
audinCaptureBuffer :: (source: *AudioInBuffer, released: **AudioInBuffer) -> Result #foreign libnx;

/**
* @brief Waits for audio capture to finish.
* @param released AudioInBuffer to receive the first captured buffer after being released.
* @param released_count Pointer to receive the number of captured buffers.
* @param timeout Timeout value, use UINT64_MAX to wait until all finished.
*/
audinWaitCaptureFinish :: (released: **AudioInBuffer, released_count: *u32, timeout: u64) -> Result #foreign libnx;

/// These return the state associated with the currently active audio input device.
audinGetSampleRate :: () -> u32 #foreign libnx;
audinGetChannelCount :: () -> u32 #foreign libnx;
audinGetPcmFormat :: () -> PcmFormat #foreign libnx;
audinGetDeviceState :: () -> AudioInState #foreign libnx;

AudioOutState :: enum u32 {
    Started :: 0;
    Stopped :: 1;
}

AudioOutBuffer :: struct {
    next:        *AudioOutBuffer; ///< Next buffer. (Unused)
    buffer:      *void; ///< Sample buffer (aligned to 0x1000 bytes).
    buffer_size: u64; ///< Sample buffer size (aligned to 0x1000 bytes).
    data_size:   u64; ///< Size of data inside the buffer.
    data_offset: u64; ///< Offset of data inside the buffer. (Unused?)
}

/// Initialize audout.
audoutInitialize :: () -> Result #foreign libnx;

/// Exit audout.
audoutExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual audout service session.
audoutGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for IAudioOut.
audoutGetServiceSession_AudioOut :: () -> *Service #foreign libnx;

audoutListAudioOuts :: (DeviceNames: *u8, count: s32, DeviceNamesCount: *u32) -> Result #foreign libnx;
audoutOpenAudioOut :: (DeviceNameIn: *u8, DeviceNameOut: *u8, SampleRateIn: u32, ChannelCountIn: u32, SampleRateOut: *u32, ChannelCountOut: *u32, Format: *PcmFormat, State: *AudioOutState) -> Result #foreign libnx;
audoutGetAudioOutState :: (State: *AudioOutState) -> Result #foreign libnx;
audoutStartAudioOut :: () -> Result #foreign libnx;
audoutStopAudioOut :: () -> Result #foreign libnx;

/// Submits an \ref AudioOutBuffer for playing.
audoutAppendAudioOutBuffer :: (Buffer: *AudioOutBuffer) -> Result #foreign libnx;

audoutGetReleasedAudioOutBuffer :: (Buffer: **AudioOutBuffer, ReleasedBuffersCount: *u32) -> Result #foreign libnx;
audoutContainsAudioOutBuffer :: (Buffer: *AudioOutBuffer, ContainsBuffer: *bool) -> Result #foreign libnx;

/// Only available with [4.0.0+].
audoutGetAudioOutBufferCount :: (count: *u32) -> Result #foreign libnx;

/// Only available with [4.0.0+].
audoutGetAudioOutPlayedSampleCount :: (count: *u64) -> Result #foreign libnx;

/// Only available with [4.0.0+].
audoutFlushAudioOutBuffers :: (flushed: *bool) -> Result #foreign libnx;

/// Only available with [6.0.0+].
audoutSetAudioOutVolume :: (volume: float) -> Result #foreign libnx;

/// Only available with [6.0.0+].
audoutGetAudioOutVolume :: (volume: *float) -> Result #foreign libnx;

/**
* @brief Submits an audio sample data buffer for playing and waits for it to finish playing.
* @brief Uses \ref audoutAppendAudioOutBuffer and \ref audoutWaitPlayFinish internally.
* @param source AudioOutBuffer containing the source sample data to be played.
* @param released AudioOutBuffer to receive the played buffer after being released.
*/
audoutPlayBuffer :: (source: *AudioOutBuffer, released: **AudioOutBuffer) -> Result #foreign libnx;

/**
* @brief Waits for audio playback to finish.
* @param released AudioOutBuffer to receive the first played buffer after being released.
* @param released_count Pointer to receive the number of played buffers.
* @param timeout Timeout value, use UINT64_MAX to wait until all finished.
*/
audoutWaitPlayFinish :: (released: **AudioOutBuffer, released_count: *u32, timeout: u64) -> Result #foreign libnx;

/// These return the state associated with the currently active audio output device.
audoutGetSampleRate :: () -> u32 #foreign libnx;
audoutGetChannelCount :: () -> u32 #foreign libnx;
audoutGetPcmFormat :: () -> PcmFormat #foreign libnx;
audoutGetDeviceState :: () -> AudioOutState #foreign libnx;

FinalOutputRecorderBuffer :: struct {
    released_ns:            u64;
    next_buffer_ptr:        u64;
    sample_buffer_ptr:      u64;
    sample_buffer_capacity: u64;
    data_size:              u64;
    data_offset:            u64;
}

FinalOutputRecorderParameter :: struct {
    sample_rate:   u32;
    channel_count: u32;
}

FinalOutputRecorderParameterInternal :: struct {
    sample_rate:   u32;
    channel_count: u32;
    sample_format: u32;
    state:         u32;
}

AudrecRecorder :: struct {
    s: Service;
}

audrecInitialize :: () -> Result #foreign libnx;
audrecExit :: () -> void #foreign libnx;
audrecGetServiceSession :: () -> *Service #foreign libnx;

audrecOpenFinalOutputRecorder :: (recorder_out: *AudrecRecorder, param_in: *FinalOutputRecorderParameter, aruid: u64, param_out: *FinalOutputRecorderParameterInternal) -> Result #foreign libnx;

audrecRecorderStart :: (recorder: *AudrecRecorder) -> Result #foreign libnx;
audrecRecorderStop :: (recorder: *AudrecRecorder) -> Result #foreign libnx;
audrecRecorderRegisterBufferEvent :: (recorder: *AudrecRecorder, out_event: *Event) -> Result #foreign libnx;
audrecRecorderAppendFinalOutputRecorderBuffer :: (recorder: *AudrecRecorder, buffer_client_ptr: u64, param: *FinalOutputRecorderBuffer) -> Result #foreign libnx;
audrecRecorderGetReleasedFinalOutputRecorderBuffers :: (recorder: *AudrecRecorder, out_buffers: *u64, inout_count: *u64, out_released: *u64) -> Result #foreign libnx;
audrecRecorderClose :: (recorder: *AudrecRecorder) -> void #foreign libnx;

AudioRendererOutputRate :: enum u32 {
    _32kHz :: 0;
    _48kHz :: 1;
}

AudioRendererConfig :: struct {
    output_rate:     AudioRendererOutputRate;
    num_voices:      s32;
    num_effects:     s32;
    num_sinks:       s32;
    num_mix_objs:    s32;
    num_mix_buffers: s32;
}

/*
Output buffer layout:

AudioRendererUpdateDataHeader
AudioRendererMemPoolInfoOut * mempool_count
AudioRendererVoiceInfoOut * voice_count
(effects would go here)
AudioRendererSinkInfoOut * sink_count
AudioRendererPerformanceBufferInfoOut
AudioRendererBehaviorInfoOut
*/
AudioRendererUpdateDataHeader :: struct {
    revision:    u32;
    behavior_sz: u32;
    mempools_sz: u32;
    voices_sz:   u32;
    channels_sz: u32;
    effects_sz:  u32;
    mixes_sz:    u32;
    sinks_sz:    u32;
    perfmgr_sz:  u32;
    _padding:    [6] u32;
    total_sz:    u32;
}

AudioRendererBehaviorInfoIn :: struct {
    revision:  u32;
    _padding1: u32;
    flags:     u64;
}

AudioRendererBehaviorInfoOut :: struct {
    unknown:   [20] u64;
    _padding1: [2] u64;
}

AudioRendererMemPoolState :: enum u32 {
    Invalid       :: 0;
    New           :: 1;
    RequestDetach :: 2;
    Detached      :: 3;
    RequestAttach :: 4;
    Attached      :: 5;
    Released      :: 6;
}

AudioRendererMemPoolInfoIn :: struct {
    address:   *void;
    size:      u64;
    state:     AudioRendererMemPoolState;
    _padding2: [3] u32;
}

AudioRendererMemPoolInfoOut :: struct {
    new_state: AudioRendererMemPoolState;
    _padding2: [3] u32;
}

AudioRendererChannelInfoIn :: struct {
    id:        u32;
    mix:       [24] float;
    is_used:   bool;
    _padding1: [11] u8;
}

AudioRendererBiquadFilter :: struct {
    enable:      bool;
    _padding:    u8;
    numerator:   [3] s16;
    denominator: [2] s16;
}

AudioRendererAdpcmParameters :: struct {
    coefficients: [16] u16;
}

AudioRendererAdpcmContext :: struct {
    index:    u16;
    history0: s16;
    history1: s16;
}

AudioRendererWaveBuf :: struct {
    address:             *void;
    size:                u64;
    start_sample_offset: s32;
    end_sample_offset:   s32;
    is_looping:          bool;
    end_of_stream:       bool;
    sent_to_server:      bool;
    _padding1:           [5] u8;
    context_addr:        *void;
    context_sz:          u64;
    _padding2:           u64;
}

AudioRendererVoicePlayState :: enum u32 {
    Started :: 0;
    Stopped :: 1;
    Paused  :: 2;
}

AudioRendererVoiceInfoOut :: struct {
    played_sample_count:   u64;
    num_wavebufs_consumed: u32;
    voice_drops_count:     u32;
}

AudioRendererMixInfoIn :: struct {
    volume:           float;
    sample_rate:      u32;
    buffer_count:     u32;
    is_used:          bool;
    _padding1:        [3] u8;
    mix_id:           u32;
    _padding2:        u32;
    node_id:          u32;
    _padding3:        [2] u32;
    mix:              [24] [24] float; // [src_index][dest_index]
    dest_mix_id:      u32;
    dest_splitter_id: u32;
    _padding4:        u32;
}

AudioRendererDownMixParameters :: struct {
    coefficients: [16] u8;
}

AudioRendererSinkType :: enum u32 {
    Invalid        :: 0;
    Device         :: 1;
    CircularBuffer :: 2;
}

AudioRendererDeviceSinkInfoIn :: struct {
    name:                   [255] u8;
    _padding1:              u8;
    input_count:            u32;
    inputs:                 [6] u8;
    _padding2:              u8;
    downmix_params_enabled: bool;
    downmix_params:         AudioRendererDownMixParameters;
}

AudioRendererCircularBufferSinkInfoIn :: struct {
    buffer_ptr:       *void;
    buffer_sz:        u32;
    input_count:      u32;
    sample_count:     u32;
    last_read_offset: u32;
    sample_format:    PcmFormat;
    inputs:           [6] u8;
    _padding2:        [6] u8;
}

AudioRendererSinkInfoOut :: struct {
    last_written_offset: u32;
    unk1:                u32;
    unk2:                u64;
    _padding1:           [2] u64;
}

AudioRendererPerformanceBufferInfoIn :: struct {
    detail_target: u32;
    _padding1:     [3] u32;
}

AudioRendererPerformanceBufferInfoOut :: struct {
    written_sz: u32;
    _padding1:  [3] u32;
}

/// Initialize audren.
audrenInitialize :: (config: *AudioRendererConfig) -> Result #foreign libnx;

/// Exit audren.
audrenExit :: () -> void #foreign libnx;

/// Gets the Service object for IAudioRenderer.
audrenGetServiceSession_AudioRenderer :: () -> *Service #foreign libnx;

audrenWaitFrame :: () -> void #foreign libnx;
audrenGetState :: (out_state: *u32) -> Result #foreign libnx;
audrenRequestUpdateAudioRenderer :: (in_param_buf: *void, in_param_buf_size: u64, out_param_buf: *void, out_param_buf_size: u64, perf_buf: *void, perf_buf_size: u64) -> Result #foreign libnx;
audrenStartAudioRenderer :: () -> Result #foreign libnx;
audrenStopAudioRenderer :: () -> Result #foreign libnx;
audrenSetAudioRendererRenderingTimeLimit :: (percent: s32) -> Result #foreign libnx;

/// Initialize IAudioDevice.
auddevInitialize :: () -> Result #foreign libnx;

/// Exit IAudioDevice.
auddevExit :: () -> void #foreign libnx;

/// Gets the Service object for IAudioDevice.
auddevGetServiceSession :: () -> *Service #foreign libnx;

auddevListAudioDeviceName :: (DeviceNames: *AudioDeviceName, max_names: s32, total_names: *s32) -> Result #foreign libnx;
auddevSetAudioDeviceOutputVolume :: (DeviceName: *AudioDeviceName, volume: float) -> Result #foreign libnx;
auddevGetAudioDeviceOutputVolume :: (DeviceName: *AudioDeviceName, volume: *float) -> Result #foreign libnx;
auddevGetActiveAudioDeviceName :: (DeviceName: *AudioDeviceName) -> Result #foreign libnx;

HwopusDecoder :: struct {
    s:           Service;
    tmem:        TransferMemory;
    multistream: bool;
}

/// This structure is the start of opusin for \ref hwopusDecodeInterleaved, with the actual opus packet following this.
/// These fields are big-endian.
HwopusHeader :: struct {
    size:        u32; ///< Size of the packet following this header.
    final_range: u32; ///< Indicates the final range of the codec encoder's entropy coder. This can be left at zero.
}

/// Used internally.
HwopusMultistreamState :: struct {
    SampleRate:        s32;
    ChannelCount:      s32;
    TotalStreamCount:  s32;
    StereoStreamCount: s32;
    channel_mapping:   [256] u8;
}

hwopusDecoderInitialize :: (decoder: *HwopusDecoder, SampleRate: s32, ChannelCount: s32) -> Result #foreign libnx;
hwopusDecoderExit :: (decoder: *HwopusDecoder) -> void #foreign libnx;

/// Only available on [3.0.0+].
/// See libopus multistream docs.
hwopusDecoderMultistreamInitialize :: (decoder: *HwopusDecoder, SampleRate: s32, ChannelCount: s32, TotalStreamCount: s32, StereoStreamCount: s32, channel_mapping: *u8) -> Result #foreign libnx;

/// Decodes opus data.
hwopusDecodeInterleaved :: (decoder: *HwopusDecoder, DecodedDataSize: *s32, DecodedSampleCount: *s32, opusin: *void, opusin_size: u64, pcmbuf: *s16, pcmbuf_size: u64) -> Result #foreign libnx;

/// Initialize csrng.
csrngInitialize :: () -> Result #foreign libnx;

/// Exit csrng.
csrngExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual csrng service session.
csrngGetServiceSession :: () -> *Service #foreign libnx;

csrngGetRandomBytes :: (out: *void, out_size: u64) -> Result #foreign libnx;

LblBacklightSwitchStatus :: enum u32 {
    Disabled  :: 0;
    Enabled   :: 1;
    Enabling  :: 2;
    Disabling :: 3;
}

/// Initialize lbl.
lblInitialize :: () -> Result #foreign libnx;

/// Exit lbl.
lblExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual lbl service session.
lblGetServiceSession :: () -> *Service #foreign libnx;

lblSaveCurrentSetting :: () -> Result #foreign libnx;
lblLoadCurrentSetting :: () -> Result #foreign libnx;

/**
* @note The brightness goes from 0 to 1.0.
*/
lblSetCurrentBrightnessSetting :: (brightness: float) -> Result #foreign libnx;
lblGetCurrentBrightnessSetting :: (out_value: *float) -> Result #foreign libnx;

lblApplyCurrentBrightnessSettingToBacklight :: () -> Result #foreign libnx;
lblGetBrightnessSettingAppliedToBacklight :: (out_value: *float) -> Result #foreign libnx;

lblSwitchBacklightOn :: (fade_time: u64) -> Result #foreign libnx;
lblSwitchBacklightOff :: (fade_time: u64) -> Result #foreign libnx;
lblGetBacklightSwitchStatus :: (out_value: *LblBacklightSwitchStatus) -> Result #foreign libnx;

lblEnableDimming :: () -> Result #foreign libnx;
lblDisableDimming :: () -> Result #foreign libnx;
lblIsDimmingEnabled :: (out_value: *bool) -> Result #foreign libnx;

lblEnableAutoBrightnessControl :: () -> Result #foreign libnx;
lblDisableAutoBrightnessControl :: () -> Result #foreign libnx;
lblIsAutoBrightnessControlEnabled :: (out_value: *bool) -> Result #foreign libnx;

lblSetAmbientLightSensorValue :: (value: float) -> Result #foreign libnx;

/**
* @note Used internally by \ref appletGetAmbientLightSensorValue and \ref appletGetCurrentIlluminanceEx.
*/
lblGetAmbientLightSensorValue :: (over_limit: *bool, lux: *float) -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
* @note Used internally by \ref appletIsIlluminanceAvailable.
*/
lblIsAmbientLightSensorAvailable :: (out_value: *bool) -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
*/
lblSetCurrentBrightnessSettingForVrMode :: (brightness: float) -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
*/
lblGetCurrentBrightnessSettingForVrMode :: (out_value: *float) -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
* @note Used internally by \ref appletSetVrModeEnabled.
*/
lblEnableVrMode :: () -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
* @note Used internally by \ref appletSetVrModeEnabled.
*/
lblDisableVrMode :: () -> Result #foreign libnx;

/**
* @note Only available on [3.0.0+].
* @note Used internally by \ref appletIsVrModeEnabled.
*/
lblIsVrModeEnabled :: (out_value: *bool) -> Result #foreign libnx;

I2cDevice :: enum u32 {
    DebugPad        :: 0;
    TouchPanel      :: 1;
    Tmp451          :: 2;
    Nct72           :: 3;
    Alc5639         :: 4;
    Max77620Rtc     :: 5;
    Max77620Pmic    :: 6;
    Max77621Cpu     :: 7;
    Max77621Gpu     :: 8;
    Bq24193         :: 9;
    Max17050        :: 10;
    Bm92t30mwv      :: 11;
    Ina226Vdd15v0Hb :: 12;
    Ina226VsysCpuDs :: 13;
    Ina226VsysGpuDs :: 14;
    Ina226VsysDdrDs :: 15;
    Ina226VsysAp    :: 16;
    Ina226VsysBlDs  :: 17;
    Bh1730          :: 18;
    Ina226VsysCore  :: 19;
    Ina226Soc1V8    :: 20;
    Ina226Lpddr1V8  :: 21;
    Ina226Reg1V32   :: 22;
    Ina226Vdd3V3Sys :: 23;
    HdmiDdc         :: 24;
    HdmiScdc        :: 25;
    HdmiHdcp        :: 26;
    Fan53528        :: 27;
    Max77812_3      :: 28;
    Max77812_2      :: 29;
    Ina226VddDdr0V6 :: 30;

    Count           :: 31;
}

I2cSession :: struct {
    s: Service;
}

I2cTransactionOption :: enum u32 {
    Start :: 1;
    Stop  :: 2;

    All   :: 3;
}

/// Initialize i2c.
i2cInitialize :: () -> Result #foreign libnx;

/// Exit i2c.
i2cExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual i2c service session.
i2cGetServiceSession :: () -> *Service #foreign libnx;

i2cOpenSession :: (out: *I2cSession, dev: I2cDevice) -> Result #foreign libnx;

i2csessionSendAuto :: (s: *I2cSession, buf: *void, size: u64, option: I2cTransactionOption) -> Result #foreign libnx;
i2csessionReceiveAuto :: (s: *I2cSession, buf: *void, size: u64, option: I2cTransactionOption) -> Result #foreign libnx;
i2csessionExecuteCommandList :: (s: *I2cSession, dst: *void, dst_size: u64, cmd_list: *void, cmd_list_size: u64) -> Result #foreign libnx;
i2csessionClose :: (s: *I2cSession) -> void #foreign libnx;

GpioPadName :: enum u32 {
    AudioCodec    :: 1;
    ButtonVolUp   :: 25;
    ButtonVolDown :: 26;
    SdCd          :: 56;
}

GpioPadSession :: struct {
    s: Service;
}

GpioDirection :: enum u32 {
    Input  :: 0;
    Output :: 1;
}

GpioValue :: enum u32 {
    Low  :: 0;
    High :: 1;
}

GpioInterruptMode :: enum u32 {
    LowLevel    :: 0;
    HighLevel   :: 1;
    RisingEdge  :: 2;
    FallingEdge :: 3;
    AnyEdge     :: 4;
}

GpioInterruptStatus :: enum u32 {
    Inactive :: 0;
    Active   :: 1;
}

/// Initialize gpio.
gpioInitialize :: () -> Result #foreign libnx;

/// Exit gpio.
gpioExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual gpio service session.
gpioGetServiceSession :: () -> *Service #foreign libnx;

gpioOpenSession :: (out: *GpioPadSession, name: GpioPadName) -> Result #foreign libnx;
gpioOpenSession2 :: (out: *GpioPadSession, device_code: u32, access_mode: u32) -> Result #foreign libnx;

gpioIsWakeEventActive :: (out: *bool, name: GpioPadName) -> Result #foreign libnx;
gpioIsWakeEventActive2 :: (out: *bool, device_code: u32) -> Result #foreign libnx;

gpioPadSetDirection :: (p: *GpioPadSession, dir: GpioDirection) -> Result #foreign libnx;
gpioPadGetDirection :: (p: *GpioPadSession, out: *GpioDirection) -> Result #foreign libnx;
gpioPadSetInterruptMode :: (p: *GpioPadSession, mode: GpioInterruptMode) -> Result #foreign libnx;
gpioPadGetInterruptMode :: (p: *GpioPadSession, out: *GpioInterruptMode) -> Result #foreign libnx;
gpioPadSetInterruptEnable :: (p: *GpioPadSession, en: bool) -> Result #foreign libnx;
gpioPadGetInterruptEnable :: (p: *GpioPadSession, out: *bool) -> Result #foreign libnx;
gpioPadGetInterruptStatus :: (p: *GpioPadSession, out: *GpioInterruptStatus) -> Result #foreign libnx;
gpioPadClearInterruptStatus :: (p: *GpioPadSession) -> Result #foreign libnx;
gpioPadSetValue :: (p: *GpioPadSession, val: GpioValue) -> Result #foreign libnx;
gpioPadGetValue :: (p: *GpioPadSession, out: *GpioValue) -> Result #foreign libnx;
gpioPadBindInterrupt :: (p: *GpioPadSession, out: *Event) -> Result #foreign libnx;
gpioPadUnbindInterrupt :: (p: *GpioPadSession) -> Result #foreign libnx;
gpioPadSetDebounceEnabled :: (p: *GpioPadSession, en: bool) -> Result #foreign libnx;
gpioPadGetDebounceEnabled :: (p: *GpioPadSession, out: *bool) -> Result #foreign libnx;
gpioPadSetDebounceTime :: (p: *GpioPadSession, ms: s32) -> Result #foreign libnx;
gpioPadGetDebounceTime :: (p: *GpioPadSession, out: *s32) -> Result #foreign libnx;
gpioPadClose :: (p: *GpioPadSession) -> void #foreign libnx;

/// UartPort
UartPort :: enum u32 {
    Bluetooth :: 1;
    JoyConR   :: 2;
    JoyConL   :: 3;
    MCU       :: 4;
}

/// UartPortForDev
UartPortForDev :: enum u32 {
    JoyConR   :: 1;
    JoyConL   :: 2;
    Bluetooth :: 3;
}

/// FlowControlMode
UartFlowControlMode :: enum u32 {
    None     :: 0;
    Hardware :: 1;
}

/// PortEventType
UartPortEventType :: enum u32 {
    SendBufferEmpty    :: 0;
    SendBufferReady    :: 1;
    ReceiveBufferReady :: 2;
    ReceiveEnd         :: 3;
}

/// PortSession
UartPortSession :: struct {
    s: Service; ///< IPortSession
}

/// Initialize uart.
uartInitialize :: () -> Result #foreign libnx;

/// Exit uart.
uartExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual uart service session.
uartGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief HasPort
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPort
* @param[out] out Output success flag.
*/
uartHasPort :: (port: UartPort, out: *bool) -> Result #foreign libnx;

/**
* @brief HasPortForDev
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPortForDev
* @param[out] out Output success flag.
*/
uartHasPortForDev :: (port: UartPortForDev, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedBaudRate
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPort
* @param[in] baud_rate BaudRate
* @param[out] out Output success flag.
*/
uartIsSupportedBaudRate :: (port: UartPort, baud_rate: u32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedBaudRateForDev
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPortForDev
* @param[in] baud_rate BaudRate
* @param[out] out Output success flag.
*/
uartIsSupportedBaudRateForDev :: (port: UartPortForDev, baud_rate: u32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedFlowControlMode
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPort
* @param[in] flow_control_mode \ref UartFlowControlMode
* @param[out] out Output success flag.
*/
uartIsSupportedFlowControlMode :: (port: UartPort, flow_control_mode: UartFlowControlMode, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedFlowControlModeForDev
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPortForDev
* @param[in] flow_control_mode \ref UartFlowControlMode
* @param[out] out Output success flag.
*/
uartIsSupportedFlowControlModeForDev :: (port: UartPortForDev, flow_control_mode: UartFlowControlMode, out: *bool) -> Result #foreign libnx;

/**
* @brief Creates an \ref UartPortSession.
* @note Use \ref uartPortSessionOpenPort or \ref uartPortSessionOpenPortForDev before using any other cmds.
* @param[out] s \ref UartPortSession
*/
uartCreatePortSession :: (s: *UartPortSession) -> Result #foreign libnx;

/**
* @brief IsSupportedPortEvent
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPort
* @param[in] port_event_type \ref UartPortEventType
* @param[out] out Output success flag.
*/
uartIsSupportedPortEvent :: (port: UartPort, port_event_type: UartPortEventType, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedPortEventForDev
* @note Only available on [1.0.0-16.1.0].
* @param[in] port \ref UartPortForDev
* @param[in] port_event_type \ref UartPortEventType
* @param[out] out Output success flag.
*/
uartIsSupportedPortEventForDev :: (port: UartPortForDev, port_event_type: UartPortEventType, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedDeviceVariation
* @note Only available on [7.0.0-16.1.0].
* @param[in] port \ref UartPort
* @param[in] device_variation DeviceVariation
* @param[out] out Output success flag.
*/
uartIsSupportedDeviceVariation :: (port: UartPort, device_variation: u32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsSupportedDeviceVariationForDev
* @note Only available on [7.0.0-16.1.0].
* @param[in] port \ref UartPortForDev
* @param[in] device_variation DeviceVariation
* @param[out] out Output success flag.
*/
uartIsSupportedDeviceVariationForDev :: (port: UartPortForDev, device_variation: u32, out: *bool) -> Result #foreign libnx;

/**
* @brief Close an \ref UartPortSession.
* @param s \ref UartPortSession
*/
uartPortSessionClose :: (s: *UartPortSession) -> void #foreign libnx;

/**
* @brief OpenPort
* @note This is not usable when the specified \ref UartPort is already being used.
* @param s \ref UartPortSession
* @param[out] out Output success flag.
* @param[in] port \ref UartPort
* @param[in] baud_rate BaudRate
* @param[in] flow_control_mode \ref UartFlowControlMode
* @param[in] device_variation [7.0.0+] DeviceVariation
* @param[in] is_invert_tx [6.0.0+] IsInvertTx
* @param[in] is_invert_rx [6.0.0+] IsInvertRx
* @param[in] is_invert_rts [6.0.0+] IsInvertRts
* @param[in] is_invert_cts [6.0.0+] IsInvertCts
* @param[in] send_buffer Send buffer, must be 0x1000-byte aligned.
* @param[in] send_buffer_length Send buffer size, must be 0x1000-byte aligned.
* @param[in] receive_buffer Receive buffer, must be 0x1000-byte aligned.
* @param[in] receive_buffer_length Receive buffer size, must be 0x1000-byte aligned.
*/
uartPortSessionOpenPort :: (s: *UartPortSession, out: *bool, port: UartPort, baud_rate: u32, flow_control_mode: UartFlowControlMode, device_variation: u32, is_invert_tx: bool, is_invert_rx: bool, is_invert_rts: bool, is_invert_cts: bool, send_buffer: *void, send_buffer_length: u64, receive_buffer: *void, receive_buffer_length: u64) -> Result #foreign libnx;

/**
* @brief OpenPortForDev
* @note See the notes for \ref uartPortSessionOpenPort.
* @param s \ref UartPortSession
* @param[out] out Output success flag.
* @param[in] port \ref UartPortForDev
* @param[in] baud_rate BaudRate
* @param[in] flow_control_mode \ref UartFlowControlMode
* @param[in] device_variation [7.0.0+] DeviceVariation
* @param[in] is_invert_tx [6.0.0+] IsInvertTx
* @param[in] is_invert_rx [6.0.0+] IsInvertRx
* @param[in] is_invert_rts [6.0.0+] IsInvertRts
* @param[in] is_invert_cts [6.0.0+] IsInvertCts
* @param[in] send_buffer Send buffer, must be 0x1000-byte aligned.
* @param[in] send_buffer_length Send buffer size, must be 0x1000-byte aligned.
* @param[in] receive_buffer Receive buffer, must be 0x1000-byte aligned.
* @param[in] receive_buffer_length Receive buffer size, must be 0x1000-byte aligned.
*/
uartPortSessionOpenPortForDev :: (s: *UartPortSession, out: *bool, port: UartPortForDev, baud_rate: u32, flow_control_mode: UartFlowControlMode, device_variation: u32, is_invert_tx: bool, is_invert_rx: bool, is_invert_rts: bool, is_invert_cts: bool, send_buffer: *void, send_buffer_length: u64, receive_buffer: *void, receive_buffer_length: u64) -> Result #foreign libnx;

/**
* @brief GetWritableLength
* @param s \ref UartPortSession
* @param[out] out Output WritableLength.
*/
uartPortSessionGetWritableLength :: (s: *UartPortSession, out: *u64) -> Result #foreign libnx;

/**
* @brief Send
* @param s \ref UartPortSession
* @param[in] in_data Input data buffer.
* @param[in] size Input data buffer size.
* @param[out] out Output size.
*/
uartPortSessionSend :: (s: *UartPortSession, in_data: *void, size: u64, out: *u64) -> Result #foreign libnx;

/**
* @brief GetReadableLength
* @param s \ref UartPortSession
* @param[out] out Output ReadableLength.
*/
uartPortSessionGetReadableLength :: (s: *UartPortSession, out: *u64) -> Result #foreign libnx;

/**
* @brief Receive
* @param s \ref UartPortSession
* @param[out] out_data Output data buffer.
* @param[in] size Output data buffer size.
* @param[out] out Output size.
*/
uartPortSessionReceive :: (s: *UartPortSession, out_data: *void, size: u64, out: *u64) -> Result #foreign libnx;

/**
* @brief BindPortEvent
* @note The Event must be closed by the user after using \ref uartPortSessionUnbindPortEvent.
* @param s \ref UartPortSession
* @param[in] port_event_type \ref UartPortEventType
* @param[in] threshold Threshold
* @param[out] out Output success flag.
* @param[out] out_event Output Event with autoclear=false.
*/
uartPortSessionBindPortEvent :: (s: *UartPortSession, port_event_type: UartPortEventType, threshold: s64, out: *bool, out_event: *Event) -> Result #foreign libnx;

/**
* @brief UnbindPortEvent
* @param s \ref UartPortSession
* @param[in] port_event_type \ref UartPortEventType
* @param[out] out Output success flag.
*/
uartPortSessionUnbindPortEvent :: (s: *UartPortSession, port_event_type: UartPortEventType, out: *bool) -> Result #foreign libnx;

BpcSleepButtonState :: enum u32 {
    Held     :: 0;
    Released :: 1;
}

/// Initialize bpc.
bpcInitialize :: () -> Result #foreign libnx;

/// Exit bpc.
bpcExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual bpc service session.
bpcGetServiceSession :: () -> *Service #foreign libnx;

bpcShutdownSystem :: () -> Result #foreign libnx;
bpcRebootSystem :: () -> Result #foreign libnx;
bpcGetSleepButtonState :: (out: *BpcSleepButtonState) -> Result #foreign libnx;
bpcGetPowerButton :: (out_is_pushed: *bool) -> Result #foreign libnx;

PcvModule :: enum u32 {
    CpuBus            :: 0;
    GPU               :: 1;
    I2S1              :: 2;
    I2S2              :: 3;
    I2S3              :: 4;
    PWM               :: 5;
    I2C1              :: 6;
    I2C2              :: 7;
    I2C3              :: 8;
    I2C4              :: 9;
    I2C5              :: 10;
    I2C6              :: 11;
    SPI1              :: 12;
    SPI2              :: 13;
    SPI3              :: 14;
    SPI4              :: 15;
    DISP1             :: 16;
    DISP2             :: 17;
    ISP               :: 18;
    VI                :: 19;
    SDMMC1            :: 20;
    SDMMC2            :: 21;
    SDMMC3            :: 22;
    SDMMC4            :: 23;
    OWR               :: 24;
    CSITE             :: 25;
    TSEC              :: 26;
    MSELECT           :: 27;
    HDA2CODEC_2X      :: 28;
    ACTMON            :: 29;
    I2C_SLOW          :: 30;
    SOR1              :: 31;
    SATA              :: 32;
    HDA               :: 33;
    XUSB_CORE_HOST    :: 34;
    XUSB_FALCON       :: 35;
    XUSB_FS           :: 36;
    XUSB_CORE_DEV     :: 37;
    XUSB_SS_HOSTDEV   :: 38;
    UARTA             :: 39;
    UARTB             :: 40;
    UARTC             :: 41;
    UARTD             :: 42;
    HOST1X            :: 43;
    ENTROPY           :: 44;
    SOC_THERM         :: 45;
    VIC               :: 46;
    NVENC             :: 47;
    NVJPG             :: 48;
    NVDEC             :: 49;
    QSPI              :: 50;
    VI_I2C            :: 51;
    TSECB             :: 52;
    APE               :: 53;
    ACLK              :: 54;
    UARTAPE           :: 55;
    EMC               :: 56;
    PLLE0_0           :: 57;
    PLLE0_1           :: 58;
    DSI               :: 59;
    MAUD              :: 60;
    DPAUX1            :: 61;
    MIPI_CAL          :: 62;
    UART_FST_MIPI_CAL :: 63;
    OSC               :: 64;
    SCLK              :: 65;
    SOR_SAFE          :: 66;
    XUSB_SS           :: 67;
    XUSB_HOST         :: 68;
    XUSB_DEV          :: 69;
    EXTPERIPH1        :: 70;
    AHUB              :: 71;
    HDA2HDMICODEC     :: 72;
    PLLP5             :: 73;
    USBD              :: 74;
    USB2              :: 75;
    PCIE              :: 76;
    AFI               :: 77;
    PCIEXCLK          :: 78;
    PEX_USB_UPHY      :: 79;
    XUSB_PADCTL       :: 80;
    APBDMA            :: 81;
    USB2_TRK          :: 82;
    PLLE0_2           :: 83;
    PLLE0_3           :: 84;
    CEC               :: 85;
    EXTPERIPH2        :: 86;
    Count             :: 87;
}

/// Module id returned by [8.0.0+] pcv services
/// See also: https://switchbrew.org/wiki/PCV_services#Modules
PcvModuleId :: enum u32 {
    CpuBus            :: 1073741825;
    GPU               :: 1073741826;
    I2S1              :: 1073741827;
    I2S2              :: 1073741828;
    I2S3              :: 1073741829;
    PWM               :: 1073741830;
    I2C1              :: 33554433;
    I2C2              :: 33554434;
    I2C3              :: 33554435;
    I2C4              :: 33554436;
    I2C5              :: 33554437;
    I2C6              :: 33554438;
    SPI1              :: 117440512;
    SPI2              :: 117440513;
    SPI3              :: 117440514;
    SPI4              :: 117440515;
    DISP1             :: 1073741841;
    DISP2             :: 1073741842;
    ISP               :: 1073741843;
    VI                :: 1073741844;
    SDMMC1            :: 1073741845;
    SDMMC2            :: 1073741846;
    SDMMC3            :: 1073741847;
    SDMMC4            :: 1073741848;
    OWR               :: 1073741849;
    CSITE             :: 1073741850;
    TSEC              :: 1073741851;
    MSELECT           :: 1073741852;
    HDA2CODEC_2X      :: 1073741853;
    ACTMON            :: 1073741854;
    I2C_SLOW          :: 1073741855;
    SOR1              :: 1073741856;
    SATA              :: 1073741857;
    HDA               :: 1073741858;
    XUSB_CORE_HOST    :: 1073741859;
    XUSB_FALCON       :: 1073741860;
    XUSB_FS           :: 1073741861;
    XUSB_CORE_DEV     :: 1073741862;
    XUSB_SS_HOSTDEV   :: 1073741863;
    UARTA             :: 50331649;
    UARTB             :: 889193477;
    UARTC             :: 889193487;
    UARTD             :: 922746881;
    HOST1X            :: 1073741868;
    ENTROPY           :: 1073741869;
    SOC_THERM         :: 1073741870;
    VIC               :: 1073741871;
    NVENC             :: 1073741872;
    NVJPG             :: 1073741873;
    NVDEC             :: 1073741874;
    QSPI              :: 1073741875;
    VI_I2C            :: 1073741876;
    TSECB             :: 1073741877;
    APE               :: 1073741878;
    ACLK              :: 1073741879;
    UARTAPE           :: 1073741880;
    EMC               :: 1073741881;
    PLLE0_0           :: 1073741882;
    PLLE0_1           :: 1073741883;
    DSI               :: 1073741884;
    MAUD              :: 1073741885;
    DPAUX1            :: 1073741886;
    MIPI_CAL          :: 1073741887;
    UART_FST_MIPI_CAL :: 1073741888;
    OSC               :: 1073741889;
    SCLK              :: 1073741890;
    SOR_SAFE          :: 1073741891;
    XUSB_SS           :: 1073741892;
    XUSB_HOST         :: 1073741893;
    XUSB_DEV          :: 1073741894;
    EXTPERIPH1        :: 1073741895;
    AHUB              :: 1073741896;
    HDA2HDMICODEC     :: 1073741897;
    PLLP5             :: 1073741898;
    USBD              :: 1073741899;
    USB2              :: 1073741900;
    PCIE              :: 1073741901;
    AFI               :: 1073741902;
    PCIEXCLK          :: 1073741903;
    PEX_USB_UPHY      :: 1073741904;
    XUSB_PADCTL       :: 1073741905;
    APBDMA            :: 1073741906;
    USB2_TRK          :: 1073741907;
    PLLE0_2           :: 1073741908;
    PLLE0_3           :: 1073741909;
    CEC               :: 1073741910;
    EXTPERIPH2        :: 1073741911;
}

// Clock list type returned by GetPossibleClockRates
PcvClockRatesListType :: enum u32 {
    Invalid  :: 0;
    Discrete :: 1;
    Range    :: 2;
}

/// Initialize pcv.
pcvInitialize :: () -> Result #foreign libnx;

/// Exit pcv.
pcvExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pcv service session.
pcvGetServiceSession :: () -> *Service #foreign libnx;

pcvGetModuleId :: (module_id: *PcvModuleId, module: PcvModule) -> Result #foreign libnx;

/// Only available on [1.0.0-7.0.1].
pcvGetClockRate :: (module: PcvModule, out_hz: *u32) -> Result #foreign libnx;

/// Only available on [1.0.0-7.0.1].
pcvSetClockRate :: (module: PcvModule, hz: u32) -> Result #foreign libnx;

/// Only available on [1.0.0-7.0.1].
pcvSetVoltageEnabled :: (power_domain: u32, state: bool) -> Result #foreign libnx;

/// Only available on [1.0.0-7.0.1].
pcvGetVoltageEnabled :: (isEnabled: *bool, power_domain: u32) -> Result #foreign libnx;

/// Only available on [1.0.0-7.0.1].
pcvGetPossibleClockRates :: (module: PcvModule, rates: *u32, max_count: s32, out_type: *PcvClockRatesListType, out_count: *s32) -> Result #foreign libnx;

ClkrstSession :: struct {
    s: Service;
}

/// Initialize clkrst. Only available on [8.0.0+].
clkrstInitialize :: () -> Result #foreign libnx;

/// Exit clkrst.
clkrstExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual clkrst service session.
clkrstGetServiceSession :: () -> *Service #foreign libnx;

/// Opens a ClkrstSession for the requested PcvModuleId, unk is set to 3 in official sysmodules.
clkrstOpenSession :: (session_out: *ClkrstSession, module_id: PcvModuleId, unk: u32) -> Result #foreign libnx;
clkrstCloseSession :: (session: *ClkrstSession) -> void #foreign libnx;
clkrstSetClockRate :: (session: *ClkrstSession, hz: u32) -> Result #foreign libnx;
clkrstGetClockRate :: (session: *ClkrstSession, out_hz: *u32) -> Result #foreign libnx;
clkrstGetPossibleClockRates :: (session: *ClkrstSession, rates: *u32, max_count: s32, out_type: *PcvClockRatesListType, out_count: *s32) -> Result #foreign libnx;

FanController :: struct {
    s: Service;
}

/// Initialize fan.
fanInitialize :: () -> Result #foreign libnx;

/// Exit fan.
fanExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual fan service session.
fanGetServiceSession :: () -> *Service #foreign libnx;

/// Opens IController session.
fanOpenController :: (out: *FanController, device_code: u32) -> Result #foreign libnx;

/// Close IController session.
fanControllerClose :: (controller: *FanController) -> void #foreign libnx;

/// @warning Disabling your fan can damage your system.
fanControllerSetRotationSpeedLevel :: (controller: *FanController, level: float) -> Result #foreign libnx;
fanControllerGetRotationSpeedLevel :: (controller: *FanController, level: *float) -> Result #foreign libnx;

/// LaunchFlag
PglLaunchFlag :: enum u32 {
    None                                     :: 0;
    EnableDetailedCrashReport                :: 1;
    EnableCrashReportScreenShotForProduction :: 2;
    EnableCrashReportScreenShotForDevelop    :: 4;
}

/// SnapShotDumpType
PglSnapShotDumpType :: enum u32 {
    None :: 0;
    Auto :: 1;
    Full :: 2;
}

PglContentMetaInfo :: struct {
    id:           u64; ///< Program Id
    version:      u32; ///< Version
    content_type: u8; ///< NcmContentType
    id_offset:    u8; ///< Id Offset
    reserved_0E:  [2] u8; ///< Padding
}

PglEventObserver :: union {
    s: Service;
    t: TipcService;
}

/// Initialize pgl.
pglInitialize :: () -> Result #foreign libnx;

/// Exit pgl.
pglExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pgl service session. Requires < 12.0.0
pglGetServiceSessionCmif :: () -> *Service #foreign libnx;

/// Gets the TipcService object for the actual pgl service session. Requires 12.0.0+
pglGetServiceSessionTipc :: () -> *TipcService #foreign libnx;

pglLaunchProgram :: (out_pid: *u64, loc: *NcmProgramLocation, pm_launch_flags: u32, pgl_launch_flags: u8) -> Result #foreign libnx;
pglTerminateProcess :: (pid: u64) -> Result #foreign libnx;
pglLaunchProgramFromHost :: (out_pid: *u64, content_path: *u8, pm_launch_flags: u32) -> Result #foreign libnx;
pglGetHostContentMetaInfo :: (out: *PglContentMetaInfo, content_path: *u8) -> Result #foreign libnx;
pglGetApplicationProcessId :: (out: *u64) -> Result #foreign libnx;
pglBoostSystemMemoryResourceLimit :: (size: u64) -> Result #foreign libnx;
pglIsProcessTracked :: (out: *bool, pid: u64) -> Result #foreign libnx;
pglEnableApplicationCrashReport :: (en: bool) -> Result #foreign libnx;
pglIsApplicationCrashReportEnabled :: (out: *bool) -> Result #foreign libnx;
pglEnableApplicationAllThreadDumpOnCrash :: (en: bool) -> Result #foreign libnx;
pglTriggerApplicationSnapShotDumper :: (dump_type: PglSnapShotDumpType, arg: *u8) -> Result #foreign libnx;
pglGetEventObserver :: (out: *PglEventObserver) -> Result #foreign libnx;

pglEventObserverGetProcessEvent :: (observer: *PglEventObserver, out: *Event) -> Result #foreign libnx;
pglEventObserverGetProcessEventInfo :: (observer: *PglEventObserver, out: *PmProcessEventInfo) -> Result #foreign libnx;
pglEventObserverClose :: (observer: *PglEventObserver) -> void #foreign libnx;

PsmChargerType :: enum u32 {
    Unconnected  :: 0;
    EnoughPower  :: 1;
    LowPower     :: 2;
    NotSupported :: 3;
}

PsmBatteryVoltageState :: enum u32 {
    NeedsShutdown      :: 0;
    NeedsSleep         :: 1;
    NoPerformanceBoost :: 2;
    Normal             :: 3;
}

/// IPsmSession
PsmSession :: struct {
    s:                Service;
    StateChangeEvent: Event; ///< autoclear=false
}

/// Initialize psm.
psmInitialize :: () -> Result #foreign libnx;

/// Exit psm.
psmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual psm service session.
psmGetServiceSession :: () -> *Service #foreign libnx;

psmGetBatteryChargePercentage :: (out: *u32) -> Result #foreign libnx;
psmGetChargerType :: (out: *PsmChargerType) -> Result #foreign libnx;
psmGetBatteryVoltageState :: (out: *PsmBatteryVoltageState) -> Result #foreign libnx;
psmGetRawBatteryChargePercentage :: (out: *float64) -> Result #foreign libnx;
psmIsEnoughPowerSupplied :: (out: *bool) -> Result #foreign libnx;
psmGetBatteryAgePercentage :: (out: *float64) -> Result #foreign libnx;

/**
* @brief Wrapper func which opens a PsmSession and handles event setup.
* @note Uses the actual BindStateChangeEvent cmd internally.
* @note The event is not signalled on BatteryChargePercentage changes.
* @param[out] s PsmSession object.
* @param[in] ChargerType Passed to SetChargerTypeChangeEventEnabled.
* @param[in] PowerSupply Passed to SetPowerSupplyChangeEventEnabled.
* @param[in] BatteryVoltage Passed to SetBatteryVoltageStateChangeEventEnabled.
*/
psmBindStateChangeEvent :: (s: *PsmSession, ChargerType: bool, PowerSupply: bool, BatteryVoltage: bool) -> Result #foreign libnx;

/// Wait on the Event setup by \ref psmBindStateChangeEvent.
psmWaitStateChangeEvent :: (s: *PsmSession, timeout: u64) -> Result #foreign libnx;

/// Cleanup version of \ref psmBindStateChangeEvent. Must be called by the user once the PsmSession is done being used.
psmUnbindStateChangeEvent :: (s: *PsmSession) -> Result #foreign libnx;

/// Initialize spsm.
spsmInitialize :: () -> Result #foreign libnx;

/// Exit spsm.
spsmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual spsm service session.
spsmGetServiceSession :: () -> *Service #foreign libnx;

spsmShutdown :: (reboot: bool) -> Result #foreign libnx;
spsmPutErrorState :: () -> Result #foreign libnx;

/// Type of thrown fatal error.
FatalPolicy :: enum u32 {
    ErrorReportAndErrorScreen :: 0;
    ErrorReport               :: 1;
    ErrorScreen               :: 2;
}

/// Struct for fatal Cpu context, 64-bit.
FatalAarch64Context :: struct {
    union {
        x: [32] u64;
        struct {
            _x: [29] u64;
            fp: u64;
            lr: u64;
            sp: u64;
            pc: u64;
        }
    }

    pstate:             u64;
    afsr0:              u64;
    afsr1:              u64;
    esr:                u64;
    far:                u64;

    stack_trace:        [32] u64;
    start_address:      u64; ///< Address of first NSO loaded (generally, process entrypoint).
    register_set_flags: u64; ///< Bitmask, bit i indicates GPR i has a value.
    stack_trace_size:   u32;
}

/// Struct for fatal Cpu context, 32-bit.
FatalAarch32Context :: struct {
    union {
        r: [16] u32;
        struct {
            _r: [11] u32;
            fp: u32;
            ip: u32;
            sp: u32;
            lr: u32;
            pc: u32;
        }
    }

    pstate:             u32;
    afsr0:              u32;
    afsr1:              u32;
    esr:                u32;
    far:                u32;

    stack_trace:        [32] u32;
    stack_trace_size:   u32;
    start_address:      u32; ///< Address of first NSO loaded (generally, process entrypoint).
    register_set_flags: u32; ///< Bitmask, bit i indicates GPR i has a value.
}

FatalCpuContext :: struct {
    union {
        aarch64_ctx: FatalAarch64Context;
        aarch32_ctx: FatalAarch32Context;
    }

    is_aarch32: bool;
    type:       u32;
}

/**
* @brief Triggers a system fatal error.
* @param[in] err Result code to throw.
* @note This function does not return.
* @note This uses \ref fatalThrowWithPolicy with \ref FatalPolicy_ErrorScreen internally.
*/
fatalThrow :: (err: Result) -> void #foreign libnx;

/**
* @brief Triggers a system fatal error with a custom \ref FatalPolicy.
* @param[in] err Result code to throw.
* @param[in] type Type of fatal error to throw.
* @note This function may not return, depending on \ref FatalPolicy.
*/
fatalThrowWithPolicy :: (err: Result, type: FatalPolicy) -> void #foreign libnx;

/**
* @brief Triggers a system fatal error with a custom \ref FatalPolicy and \ref FatalCpuContext.
* @param[in] err  Result code to throw.
* @param[in] type Type of fatal error to throw.
* @param[in] ctx  Cpu context for fatal error to throw.
* @note This function may not return, depending on \ref FatalPolicy.
*/
fatalThrowWithContext :: (err: Result, type: FatalPolicy, ctx: *FatalCpuContext) -> void #foreign libnx;

/// Imported from libusb, with some adjustments.
usb_endpoint_descriptor :: struct {
    bLength:          u8;
    bDescriptorType:  u8; ///< Must match USB_DT_ENDPOINT.
    bEndpointAddress: u8; ///< Should be one of the usb_endpoint_direction values, the endpoint-number is automatically allocated.
    bmAttributes:     u8;
    wMaxPacketSize:   u16;
    bInterval:        u8;
}

/// Imported from libusb, with some adjustments.
usb_interface_descriptor :: struct {
    bLength:            u8;
    bDescriptorType:    u8; ///< Must match USB_DT_INTERFACE.
    bInterfaceNumber:   u8; ///< See also USBDS_DEFAULT_InterfaceNumber.
    bAlternateSetting:  u8; ///< Must match 0.
    bNumEndpoints:      u8;
    bInterfaceClass:    u8;
    bInterfaceSubClass: u8;
    bInterfaceProtocol: u8;
    iInterface:         u8; ///< Ignored.
}

/// Imported from libusb, with some adjustments.
usb_device_descriptor :: struct {
    bLength:            u8;
    bDescriptorType:    u8; ///< Must match USB_DT_Device.
    bcdUSB:             u16;
    bDeviceClass:       u8;
    bDeviceSubClass:    u8;
    bDeviceProtocol:    u8;
    bMaxPacketSize0:    u8;
    idVendor:           u16;
    idProduct:          u16;
    bcdDevice:          u16;
    iManufacturer:      u8;
    iProduct:           u8;
    iSerialNumber:      u8;
    bNumConfigurations: u8;
}

/// Imported from libusb, with some adjustments.
usb_config_descriptor :: struct {
    bLength:             u8;
    bDescriptorType:     u8;
    wTotalLength:        u16;
    bNumInterfaces:      u8;
    bConfigurationValue: u8;
    iConfiguration:      u8;
    bmAttributes:        u8;
    MaxPower:            u8;
}

/// Imported from libusb, with some adjustments.
usb_ss_endpoint_companion_descriptor :: struct {
    bLength:           u8;
    bDescriptorType:   u8; ///< Must match USB_DT_SS_ENDPOINT_COMPANION.
    bMaxBurst:         u8;
    bmAttributes:      u8;
    wBytesPerInterval: u16;
}

/// Imported from libusb, with some adjustments.
usb_string_descriptor :: struct {
    bLength:         u8;
    bDescriptorType: u8; ///< Must match USB_DT_STRING.
    wData:           [64] u16;
}

/// Imported from libusb, with changed names.
usb_class_code :: enum u32 {
    PER_INTERFACE       :: 0;
    AUDIO               :: 1;
    COMM                :: 2;
    HID                 :: 3;
    PHYSICAL            :: 5;
    PRINTER             :: 7;
    PTP                 :: 6;
    IMAGE               :: 6;
    MASS_STORAGE        :: 8;
    HUB                 :: 9;
    DATA                :: 10;
    SMART_CARD          :: 11;
    CONTENT_SECURITY    :: 13;
    VIDEO               :: 14;
    PERSONAL_HEALTHCARE :: 15;
    DIAGNOSTIC_DEVICE   :: 220;
    WIRELESS            :: 224;
    APPLICATION         :: 254;
    VENDOR_SPEC         :: 255;
}

/// Imported from libusb, with changed names.
usb_descriptor_type :: enum u32 {
    DEVICE                :: 1;
    CONFIG                :: 2;
    STRING                :: 3;
    INTERFACE             :: 4;
    ENDPOINT              :: 5;
    BOS                   :: 15;
    DEVICE_CAPABILITY     :: 16;
    HID                   :: 33;
    REPORT                :: 34;
    PHYSICAL              :: 35;
    HUB                   :: 41;
    SUPERSPEED_HUB        :: 42;
    SS_ENDPOINT_COMPANION :: 48;
}

/// Imported from libusb, with changed names.
usb_endpoint_direction :: enum u32 {
    IN  :: 128;
    OUT :: 0;
}

/// Imported from libusb, with changed names.
usb_transfer_type :: enum u32 {
    CONTROL     :: 0;
    ISOCHRONOUS :: 1;
    BULK        :: 2;
    INTERRUPT   :: 3;
    BULK_STREAM :: 4;
}

/// Imported from libusb, with changed names.
usb_standard_request :: enum u32 {
    REQUEST_GET_STATUS        :: 0;

    REQUEST_CLEAR_FEATURE     :: 1;

    REQUEST_SET_FEATURE       :: 3;

    REQUEST_SET_ADDRESS       :: 5;

    REQUEST_GET_DESCRIPTOR    :: 6;

    REQUEST_SET_DESCRIPTOR    :: 7;

    REQUEST_GET_CONFIGURATION :: 8;

    REQUEST_SET_CONFIGURATION :: 9;

    REQUEST_GET_INTERFACE     :: 10;

    REQUEST_SET_INTERFACE     :: 11;

    REQUEST_SYNCH_FRAME       :: 12;

    REQUEST_SET_SEL           :: 48;

    SET_ISOCH_DELAY           :: 49;
}

/// Imported from libusb, with changed names.
usb_iso_sync_type :: enum u32 {
    NONE     :: 0;
    ASYNC    :: 1;
    ADAPTIVE :: 2;
    SYNC     :: 3;
}

/// Imported from libusb, with changed names.
usb_iso_usage_type :: enum u32 {
    DATA     :: 0;
    FEEDBACK :: 1;
    IMPLICIT :: 2;
}

/// USB Device States, per USB 2.0 spec
UsbState :: enum u32 {
    Detached   :: 0;
    Attached   :: 1;
    Powered    :: 2;
    Default    :: 3;
    Address    :: 4;
    Configured :: 5;
    Suspended  :: 6;
}

///Value for usb_interface_descriptor bInterfaceNumber for automatically allocating the actual bInterfaceNumber.
UsbDsInterface :: struct {
    initialized:            bool;
    interface_index:        u8;
    s:                      Service;

    SetupEvent:             Event;
    CtrlInCompletionEvent:  Event;
    CtrlOutCompletionEvent: Event;
}

UsbDsEndpoint :: struct {
    initialized:     bool;
    s:               Service;
    CompletionEvent: Event;
}

UsbDsDeviceInfo :: struct {
    idVendor:     u16; ///< VID
    idProduct:    u16; ///< PID
    bcdDevice:    u16;
    Manufacturer: [32] u8;
    Product:      [32] u8;
    SerialNumber: [32] u8;
}

UsbDsReportEntry :: struct {
    id:              u32; ///< urbId from post-buffer cmds
    requestedSize:   u32;
    transferredSize: u32;
    urb_status:      u32;
}

UsbDsReportData :: struct {
    report:       [8] UsbDsReportEntry;
    report_count: u32;
}

UsbComplexId :: enum u32 {
    Default :: 2;
}

UsbDeviceSpeed :: enum u32 {
    Full  :: 2;
    High  :: 3;
    Super :: 4;
}

/// Opens a session with usb:ds.
usbDsInitialize :: () -> Result #foreign libnx;

/// Closes the usb:ds session. Any interfaces/endpoints which are left open are automatically closed, since otherwise usb-sysmodule won't fully reset usb:ds to defaults.
usbDsExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual usb:ds service session.
usbDsGetServiceSession :: () -> *Service #foreign libnx;

/// Helper func.
usbDsWaitReady :: (timeout: u64) -> Result #foreign libnx;

/// Helper func.
usbDsParseReportData :: (reportdata: *UsbDsReportData, urbId: u32, requestedSize: *u32, transferredSize: *u32) -> Result #foreign libnx;

///@name IDsService
///@{
usbDsGetStateChangeEvent :: () -> *Event #foreign libnx;

/// Gets the device state. See \ref UsbState.
usbDsGetState :: (out: *UsbState) -> Result #foreign libnx;

/// Removed in [5.0.0+].
usbDsGetDsInterface :: (out: **UsbDsInterface, descriptor: *usb_interface_descriptor, interface_name: *u8) -> Result #foreign libnx;

/// Removed in [5.0.0+].
usbDsSetVidPidBcd :: (deviceinfo: *UsbDsDeviceInfo) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsRegisterInterface :: (out: **UsbDsInterface) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsRegisterInterfaceEx :: (out: **UsbDsInterface, intf_num: u8) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsClearDeviceData :: () -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsAddUsbStringDescriptor :: (out_index: *u8, _string: *u8) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsAddUsbLanguageStringDescriptor :: (out_index: *u8, lang_ids: *u16, num_langs: u16) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsDeleteUsbStringDescriptor :: (index: u8) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsSetUsbDeviceDescriptor :: (speed: UsbDeviceSpeed, descriptor: *usb_device_descriptor) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsSetBinaryObjectStore :: (bos: *void, bos_size: u64) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsEnable :: () -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsDisable :: () -> Result #foreign libnx;

///@name IDsInterface
///@{
usbDsInterface_Close :: (_interface: *UsbDsInterface) -> void #foreign libnx;

usbDsInterface_GetSetupPacket :: (_interface: *UsbDsInterface, buffer: *void, size: u64) -> Result #foreign libnx;
usbDsInterface_EnableInterface :: (_interface: *UsbDsInterface) -> Result #foreign libnx;
usbDsInterface_DisableInterface :: (_interface: *UsbDsInterface) -> Result #foreign libnx;
usbDsInterface_CtrlInPostBufferAsync :: (_interface: *UsbDsInterface, buffer: *void, size: u64, urbId: *u32) -> Result #foreign libnx;
usbDsInterface_CtrlOutPostBufferAsync :: (_interface: *UsbDsInterface, buffer: *void, size: u64, urbId: *u32) -> Result #foreign libnx;
usbDsInterface_GetCtrlInReportData :: (_interface: *UsbDsInterface, out: *UsbDsReportData) -> Result #foreign libnx;
usbDsInterface_GetCtrlOutReportData :: (_interface: *UsbDsInterface, out: *UsbDsReportData) -> Result #foreign libnx;
usbDsInterface_StallCtrl :: (_interface: *UsbDsInterface) -> Result #foreign libnx;

/// Removed in [5.0.0+].
usbDsInterface_GetDsEndpoint :: (_interface: *UsbDsInterface, endpoint: **UsbDsEndpoint, descriptor: *usb_endpoint_descriptor) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsInterface_RegisterEndpoint :: (_interface: *UsbDsInterface, endpoint: **UsbDsEndpoint, endpoint_address: u8) -> Result #foreign libnx;

/// Only available on [5.0.0+].
usbDsInterface_AppendConfigurationData :: (_interface: *UsbDsInterface, speed: UsbDeviceSpeed, buffer: *void, size: u64) -> Result #foreign libnx;

///@name IDsEndpoint
///@{
usbDsEndpoint_Close :: (endpoint: *UsbDsEndpoint) -> void #foreign libnx;

usbDsEndpoint_Cancel :: (endpoint: *UsbDsEndpoint) -> Result #foreign libnx;
usbDsEndpoint_PostBufferAsync :: (endpoint: *UsbDsEndpoint, buffer: *void, size: u64, urbId: *u32) -> Result #foreign libnx;
usbDsEndpoint_GetReportData :: (endpoint: *UsbDsEndpoint, out: *UsbDsReportData) -> Result #foreign libnx;
usbDsEndpoint_Stall :: (endpoint: *UsbDsEndpoint) -> Result #foreign libnx;
usbDsEndpoint_SetZlt :: (endpoint: *UsbDsEndpoint, zlt: bool) -> Result #foreign libnx;

UsbHsInterfaceFilterFlags :: enum u32 {
    idVendor           :: 1;
    idProduct          :: 2;
    bcdDevice_Min      :: 4;
    bcdDevice_Max      :: 8;
    bDeviceClass       :: 16;
    bDeviceSubClass    :: 32;
    bDeviceProtocol    :: 64;

    bInterfaceClass    :: 128;
    bInterfaceSubClass :: 256;
    bInterfaceProtocol :: 512;
}

/// Interface filtering struct. When the associated flag bit is set, the associated descriptor field and struct field are compared, on mismatch the interface is filtered out.
/// [7.0.0+]: The filter struct has to be unique, it can't be used by anything else (including other processes). Hence, Flags has to be non-zero. When initialized with usb:hs:a and VID and/or PID filtering is enabled, the VID/PID will be checked against a blacklist.
UsbHsInterfaceFilter :: struct {
    Flags:              u16; ///< See \ref UsbHsInterfaceFilterFlags. Setting this to 0 is equivalent to disabling filtering.
    idVendor:           u16;
    idProduct:          u16;
    bcdDevice_Min:      u16; ///< Descriptor value must be >= bcdDevice_Min.
    bcdDevice_Max:      u16; ///< Descriptor value must be <= bcdDevice_Max.
    bDeviceClass:       u8;
    bDeviceSubClass:    u8;
    bDeviceProtocol:    u8;
    bInterfaceClass:    u8;
    bInterfaceSubClass: u8;
    bInterfaceProtocol: u8;
}

/// Descriptors which are not available are set to all-zero.
/// The INPUT/OUTPUT endpoint descriptors were swapped with [8.0.0+], libnx converts this struct to the newer layout when running on pre-8.0.0.
UsbHsInterfaceInfo :: struct {
    ID:                                 s32;
    deviceID_2:                         u32;
    unk_x8:                             u32;

    interface_desc:                     usb_interface_descriptor;
    pad_x15:                            [7] u8;
    input_endpoint_descs:               [15] usb_endpoint_descriptor;
    pad_x85:                            [7] u8;
    output_endpoint_descs:              [15] usb_endpoint_descriptor;
    pad_xf5:                            [6] u8;
    input_ss_endpoint_companion_descs:  [15] usb_ss_endpoint_companion_descriptor #align 1; ///< ?
    pad_x155:                           [6] u8;
    output_ss_endpoint_companion_descs: [15] usb_ss_endpoint_companion_descriptor #align 1; ///< ?
    pad_x1b5:                           [3] u8;
}

/// Interface struct. Note that devices have a seperate \ref UsbHsInterface for each interface.
UsbHsInterface :: struct {
    inf:         UsbHsInterfaceInfo;

    pathstr:     [64] u8;
    busID:       u32;
    deviceID:    u32;

    device_desc: usb_device_descriptor;
    config_desc: usb_config_descriptor;
    pad_x21b:    [5] u8;

    timestamp:   u64; ///< Unknown u64 timestamp for when the device was inserted?
}

UsbHsXferReport :: struct {
    xferId:          u32;
    res:             Result;
    requestedSize:   u32;
    transferredSize: u32;
    id:              u64; ///< id from \ref usbHsEpPostBufferAsync.
}

UsbHsRingHeader :: struct {
    write_index: vu64;
    read_index:  vu64;
}

/// The interface service object. These Events have autoclear=false.
UsbHsClientIfSession :: struct {
    s:             Service;
    event0:        Event; ///< Unknown.
    eventCtrlXfer: Event; ///< [2.0.0+] Signaled when CtrlXferAsync finishes.
    ID:            s32;

    inf:           UsbHsInterface #align 4; ///< Initialized with the input interface from \ref usbHsAcquireUsbIf, then overwritten with the cmd output. Pre-3.0.0 this only overwrites the first 0x1B8-bytes (data before pathstr).
}

UsbHsClientEpSession :: struct {
    s:           Service;
    eventXfer:   Event; ///< [2.0.0+] Signaled when PostBufferAsync finishes.
    maxUrbCount: u32;
    max_reports: u64;
    ringbuf:     *void;

    desc:        usb_endpoint_descriptor;
}

/// Initialize usb:hs.
usbHsInitialize :: () -> Result #foreign libnx;

/// Exit usb:hs.
usbHsExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual usb:hs service session.
usbHsGetServiceSession :: () -> *Service #foreign libnx;

/// Returns the Event loaded during init with autoclear=false.
/// Signaled when a device was removed.
/// When signaled, the user should use \ref usbHsQueryAcquiredInterfaces and cleanup state for all interfaces which are not listed in the output interfaces (none of the IDs match \ref usbHsIfGetID output).
usbHsGetInterfaceStateChangeEvent :: () -> *Event #foreign libnx;

/**
* @brief Returns an array of all \ref UsbHsInterface. Internally this loads the same interfaces as \ref usbHsQueryAvailableInterfaces, followed by \ref usbHsQueryAcquiredInterfaces. However, ID in \ref UsbHsInterface is set to -1, hence the output from this should not be used with \ref usbHsAcquireUsbIf.
* @param[in] filter \ref UsbHsInterfaceFilter.
* @param[out] interfaces Array of output interfaces.
* @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
* @param[out] total_entries Total number of output interfaces.
*/
usbHsQueryAllInterfaces :: (filter: *UsbHsInterfaceFilter, interfaces: *UsbHsInterface, interfaces_maxsize: u64, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Returns an array of \ref UsbHsInterface which are available.
* @param[in] filter \ref UsbHsInterfaceFilter.
* @param[out] interfaces Array of output interfaces.
* @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
* @param[out] total_entries Total number of output interfaces.
*/
usbHsQueryAvailableInterfaces :: (filter: *UsbHsInterfaceFilter, interfaces: *UsbHsInterface, interfaces_maxsize: u64, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Returns an array of \ref UsbHsInterface which were previously acquired.
* @param[out] interfaces Array of output interfaces.
* @param[in] interfaces_maxsize Max byte-size of the interfaces buffer.
* @param[out] total_entries Total number of output interfaces.
*/
usbHsQueryAcquiredInterfaces :: (interfaces: *UsbHsInterface, interfaces_maxsize: u64, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Creates an event which is signaled when an interface is available which passes the filtering checks.
* @param[out] out_event Event object.
* @param[in] autoclear Event autoclear.
* @param[in] index Event index, must be 0..2.
* @param[in] filter \ref UsbHsInterfaceFilter.
*/
usbHsCreateInterfaceAvailableEvent :: (out_event: *Event, autoclear: bool, index: u8, filter: *UsbHsInterfaceFilter) -> Result #foreign libnx;

/**
* @brief Destroys an event setup by \ref usbHsCreateInterfaceAvailableEvent. This *must* be used at some point during cleanup.
* @param[in] event Event object to close.
* @param[in] index Event index, must be 0..2.
*/
usbHsDestroyInterfaceAvailableEvent :: (event: *Event, index: u8) -> Result #foreign libnx;

/**
* @brief Acquires/opens the specified interface. This returns an error if the interface was already acquired by another process.
* @param[in] s The service object.
* @param[in] interface Interface to use.
*/
usbHsAcquireUsbIf :: (s: *UsbHsClientIfSession, _interface: *UsbHsInterface) -> Result #foreign libnx;

/// Closes the specified interface session.
usbHsIfClose :: (s: *UsbHsClientIfSession) -> void #foreign libnx;

/**
* @brief Selects an interface.
* @param[in] s The service object.
* @param[out] inf The output interface info. If NULL, the output is stored within s instead.
* @param[in] id ID
*/
usbHsIfSetInterface :: (s: *UsbHsClientIfSession, inf: *UsbHsInterfaceInfo, id: u8) -> Result #foreign libnx;

/**
* @brief Gets an interface.
* @param[in] s The service object.
* @param[out] inf The output interface info. If NULL, the output is stored within s instead.
*/
usbHsIfGetInterface :: (s: *UsbHsClientIfSession, inf: *UsbHsInterfaceInfo) -> Result #foreign libnx;

/**
* @brief Gets an alternate interface.
* @param[in] s The service object.
* @param[out] inf The output interface info. If NULL, the output is stored within s instead.
* @param[in] id ID
*/
usbHsIfGetAlternateInterface :: (s: *UsbHsClientIfSession, inf: *UsbHsInterfaceInfo, id: u8) -> Result #foreign libnx;

/// On [1.0.0] this is stubbed, just returns 0 with out=0.
usbHsIfGetCurrentFrame :: (s: *UsbHsClientIfSession, out: *u32) -> Result #foreign libnx;

/// Uses a control transfer, this will block until the transfer finishes. The buffer address and size should be aligned to 0x1000-bytes, where wLength is the original size.
usbHsIfCtrlXfer :: (s: *UsbHsClientIfSession, bmRequestType: u8, bRequest: u8, wValue: u16, wIndex: u16, wLength: u16, buffer: *void, transferredSize: *u32) -> Result #foreign libnx;

/**
* @brief Opens an endpoint. maxUrbCount*maxXferSize must be non-zero.
* @param[in] s The interface object.
* @param[out] ep The endpoint object.
* @param[in] maxUrbCount maxUrbCount, must be <0x11.
* @param[in] maxXferSize Max transfer size for a packet. This can be desc->wMaxPacketSize. Must be <=0xFF0000.
* @param[in] desc Endpoint descriptor.
*/
usbHsIfOpenUsbEp :: (s: *UsbHsClientIfSession, ep: *UsbHsClientEpSession, maxUrbCount: u16, maxXferSize: u32, desc: *usb_endpoint_descriptor) -> Result #foreign libnx;

/// Resets the device: has the same affect as unplugging the device and plugging it back in.
usbHsIfResetDevice :: (s: *UsbHsClientIfSession) -> Result #foreign libnx;

/// Closes the specified endpoint session.
usbHsEpClose :: (s: *UsbHsClientEpSession) -> void #foreign libnx;

/**
* @brief Starts an async data transfer with the specified endpoint. The Event from \ref usbHsEpGetXferEvent can be used to determine when the transfer finished. If you don't need async, \ref usbHsEpPostBuffer can be used instead.
* @note Only available on [2.0.0+].
* @param[in] s The endpoint object.
* @param buffer Data buffer. The buffer address and size should be aligned to 0x1000-bytes.
* @param[in] size The actual data size.
* @param[in] id This is an arbitrary value which will be later returned in \ref UsbHsXferReport. For example a value starting at 0 can be used, then if sending multiple requests at once this value can be incremented each time (with 0 for the first request in this set of requests).
* @param[out] xferId Output xferId.
*/
usbHsEpPostBufferAsync :: (s: *UsbHsClientEpSession, buffer: *void, size: u32, id: u64, xferId: *u32) -> Result #foreign libnx;

/**
* @brief Gets an array of \ref UsbHsXferReport for the specified endpoint. This should be used after waiting on the Event from \ref usbHsEpGetXferEvent.
* @note Only available on [2.0.0+].
* @param[in] s The endpoint object.
* @param[out] reports Output array of \ref UsbHsXferReport.
* @param[in] max_reports Size of the reports array in entries.
* @param[out] count Number of entries written to the array.
*/
usbHsEpGetXferReport :: (s: *UsbHsClientEpSession, reports: *UsbHsXferReport, max_reports: u32, count: *u32) -> Result #foreign libnx;

/**
* @brief Uses a data transfer with the specified endpoint, this will block until the transfer finishes. This wraps \ref usbHsEpPostBufferAsync and \ref usbHsEpGetXferReport, and also handles the Event (on pre-2.0.0 this handles using the relevant cmds instead). If async is needed, use \ref usbHsEpPostBufferAsync instead.
* @param[in] s The endpoint object.
* @param buffer Data buffer. The buffer address and size should be aligned to 0x1000-bytes.
* @param[in] size The actual data size.
* @param[out] transferredSize Output transferred size.
*/
usbHsEpPostBuffer :: (s: *UsbHsClientEpSession, buffer: *void, size: u32, transferredSize: *u32) -> Result #foreign libnx;

/**
* @brief This uses the same functionality internally as \ref usbHsEpPostBufferAsync except the urbs array and unk1/unk2 are specified by the user instead.
* @note Only available on [2.0.0+].
* @param[in] s The endpoint object.
* @param buffer Data buffer. The buffer address and size should be aligned to 0x1000-bytes.
* @param[in] urbs Input array of u32s for the size of each urb.
* @param[in] urbCount Total entries in the urbs array.
* @param[in] id Same as \ref usbHsEpPostBufferAsync.
* @param[in] unk1 \ref usbHsEpPostBufferAsync would internally pass value 0 here.
* @param[in] unk2 \ref usbHsEpPostBufferAsync would internally pass value 0 here.
* @param[out] xferId Output xferId.
*/
usbHsEpBatchBufferAsync :: (s: *UsbHsClientEpSession, buffer: *void, urbs: *u32, urbCount: u32, id: u64, unk1: u32, unk2: u32, xferId: *u32) -> Result #foreign libnx;

/**
* @brief This can be used to map the specified buffer as devicemem, which can then be used with \ref usbHsEpPostBufferAsync / \ref usbHsEpPostBuffer / \ref usbHsEpBatchBufferAsync. If the buffer address passed to those funcs is within this SmmuSpace, the specified buffer must be within the bounds of the SmmuSpace buffer.
* @note Only available on [4.0.0+].
* @note A buffer from usbHsEpCreateSmmuSpace can't be reused by another endpoint with the aforementioned funcs.
* @note This can only be used once per UsbHsClientEpSession object.
* @param[in] s The endpoint object.
* @param buffer Buffer address, this must be aligned to 0x1000-bytes.
* @param[in] size Buffer size, this must be aligned to 0x1000-bytes.
*/
usbHsEpCreateSmmuSpace :: (s: *UsbHsClientEpSession, buffer: *void, size: u32) -> Result #foreign libnx;

/**
* @brief This creates TransferMemory which is used to read \ref UsbHsXferReport when \ref usbHsEpGetXferReport is used, instead of using the service cmd.
* @note Only available on [4.0.0+].
* @param buffer Buffer, must be 0x1000-byte aligned.
* @param[in] size Buffer size, \ref usbHsEpGetReportRingSize can be used to calculate this.
*/
usbHsEpShareReportRing :: (s: *UsbHsClientEpSession, buffer: *void, size: u64) -> Result #foreign libnx;

/// HidDebugPadButton
HidDebugPadButton :: enum_flags u32 {
    A      :: 1;
    B      :: 2;
    X      :: 4;
    Y      :: 8;
    L      :: 16;
    R      :: 32;
    ZL     :: 64;
    ZR     :: 128;
    Start  :: 256;
    Select :: 512;
    Left   :: 1024;
    Up     :: 2048;
    Right  :: 4096;
    Down   :: 8192;
}

/// HidTouchScreenModeForNx
HidTouchScreenModeForNx :: enum u32 {
    UseSystemSetting :: 0;
    Finger           :: 1;
    Heat2            :: 2;
}

/// HidMouseButton
HidMouseButton :: enum_flags u32 {
    Left    :: 1;
    Right   :: 2;
    Middle  :: 4;
    Forward :: 8;
    Back    :: 16;
}

/// HidKeyboardKey
HidKeyboardKey :: enum u32 {
    A                :: 4;
    B                :: 5;
    C                :: 6;
    D                :: 7;
    E                :: 8;
    F                :: 9;
    G                :: 10;
    H                :: 11;
    I                :: 12;
    J                :: 13;
    K                :: 14;
    L                :: 15;
    M                :: 16;
    N                :: 17;
    O                :: 18;
    P                :: 19;
    Q                :: 20;
    R                :: 21;
    S                :: 22;
    T                :: 23;
    U                :: 24;
    V                :: 25;
    W                :: 26;
    X                :: 27;
    Y                :: 28;
    Z                :: 29;
    D1               :: 30;
    D2               :: 31;
    D3               :: 32;
    D4               :: 33;
    D5               :: 34;
    D6               :: 35;
    D7               :: 36;
    D8               :: 37;
    D9               :: 38;
    D0               :: 39;
    Return           :: 40;
    Escape           :: 41;
    Backspace        :: 42;
    Tab              :: 43;
    Space            :: 44;
    Minus            :: 45;
    Plus             :: 46;
    OpenBracket      :: 47;
    CloseBracket     :: 48;
    Pipe             :: 49;
    Tilde            :: 50;
    Semicolon        :: 51;
    Quote            :: 52;
    Backquote        :: 53;
    Comma            :: 54;
    Period           :: 55;
    Slash            :: 56;
    CapsLock         :: 57;
    F1               :: 58;
    F2               :: 59;
    F3               :: 60;
    F4               :: 61;
    F5               :: 62;
    F6               :: 63;
    F7               :: 64;
    F8               :: 65;
    F9               :: 66;
    F10              :: 67;
    F11              :: 68;
    F12              :: 69;
    PrintScreen      :: 70;
    ScrollLock       :: 71;
    Pause            :: 72;
    Insert           :: 73;
    Home             :: 74;
    PageUp           :: 75;
    Delete           :: 76;
    End              :: 77;
    PageDown         :: 78;
    RightArrow       :: 79;
    LeftArrow        :: 80;
    DownArrow        :: 81;
    UpArrow          :: 82;
    NumLock          :: 83;
    NumPadDivide     :: 84;
    NumPadMultiply   :: 85;
    NumPadSubtract   :: 86;
    NumPadAdd        :: 87;
    NumPadEnter      :: 88;
    NumPad1          :: 89;
    NumPad2          :: 90;
    NumPad3          :: 91;
    NumPad4          :: 92;
    NumPad5          :: 93;
    NumPad6          :: 94;
    NumPad7          :: 95;
    NumPad8          :: 96;
    NumPad9          :: 97;
    NumPad0          :: 98;
    NumPadDot        :: 99;
    Backslash        :: 100;
    Application      :: 101;
    Power            :: 102;
    NumPadEquals     :: 103;
    F13              :: 104;
    F14              :: 105;
    F15              :: 106;
    F16              :: 107;
    F17              :: 108;
    F18              :: 109;
    F19              :: 110;
    F20              :: 111;
    F21              :: 112;
    F22              :: 113;
    F23              :: 114;
    F24              :: 115;
    NumPadComma      :: 133;
    Ro               :: 135;
    KatakanaHiragana :: 136;
    Yen              :: 137;
    Henkan           :: 138;
    Muhenkan         :: 139;
    NumPadCommaPc98  :: 140;
    HangulEnglish    :: 144;
    Hanja            :: 145;
    Katakana         :: 146;
    Hiragana         :: 147;
    ZenkakuHankaku   :: 148;
    LeftControl      :: 224;
    LeftShift        :: 225;
    LeftAlt          :: 226;
    LeftGui          :: 227;
    RightControl     :: 228;
    RightShift       :: 229;
    RightAlt         :: 230;
    RightGui         :: 231;
}

/// HidKeyboardModifier
HidKeyboardModifier :: enum_flags u32 {
    Control    :: 1;
    Shift      :: 2;
    LeftAlt    :: 4;
    RightAlt   :: 8;
    Gui        :: 16;
    CapsLock   :: 256;
    ScrollLock :: 512;
    NumLock    :: 1024;
    Katakana   :: 2048;
    Hiragana   :: 4096;
}

/// KeyboardLockKeyEvent
HidKeyboardLockKeyEvent :: enum_flags u32 {
    NumLockOn        :: 1;
    NumLockOff       :: 2;
    NumLockToggle    :: 4;
    CapsLockOn       :: 8;
    CapsLockOff      :: 16;
    CapsLockToggle   :: 32;
    ScrollLockOn     :: 64;
    ScrollLockOff    :: 128;
    ScrollLockToggle :: 256;
}

/// HID controller IDs
HidNpadIdType :: enum u32 {
    No1      :: 0;
    No2      :: 1;
    No3      :: 2;
    No4      :: 3;
    No5      :: 4;
    No6      :: 5;
    No7      :: 6;
    No8      :: 7;
    Other    :: 16;
    Handheld :: 32;
}

/// HID controller styles
HidNpadStyleTag :: enum_flags u32 {
    NpadFullKey                  :: 1;
    NpadHandheld                 :: 2;
    NpadJoyDual                  :: 4;
    NpadJoyLeft                  :: 8;
    NpadJoyRight                 :: 16;
    NpadGc                       :: 32;
    NpadPalma                    :: 64;
    NpadLark                     :: 128;
    NpadHandheldLark             :: 256;
    NpadLucia                    :: 512;
    NpadLagon                    :: 1024;
    NpadLager                    :: 2048;
    NpadSystemExt                :: 536870912;
    NpadSystem                   :: 1073741824;

    HidNpadStyleSet_NpadFullCtrl :: 7;
    HidNpadStyleSet_NpadStandard :: 31;
}

/// HidColorAttribute
HidColorAttribute :: enum u32 {
    Ok           :: 0;
    ReadError    :: 1;
    NoController :: 2;
}

/// HidNpadButton
HidNpadButton :: enum_flags u64 {
    A             :: 1;
    B             :: 2;
    X             :: 4;
    Y             :: 8;
    StickL        :: 16;
    StickR        :: 32;
    L             :: 64;
    R             :: 128;
    ZL            :: 256;
    ZR            :: 512;
    Plus          :: 1024;
    Minus         :: 2048;
    Left          :: 4096;
    Up            :: 8192;
    Right         :: 16384;
    Down          :: 32768;
    StickLLeft    :: 65536;
    StickLUp      :: 131072;
    StickLRight   :: 262144;
    StickLDown    :: 524288;
    StickRLeft    :: 1048576;
    StickRUp      :: 2097152;
    StickRRight   :: 4194304;
    StickRDown    :: 8388608;
    LeftSL        :: 16777216;
    LeftSR        :: 33554432;
    RightSL       :: 67108864;
    RightSR       :: 134217728;
    Palma         :: 268435456;
    Verification  :: 536870912;
    HandheldLeftB :: 1073741824;
    LagonCLeft    :: 2147483648;
    LagonCUp      :: 4294967296;
    LagonCRight   :: 8589934592;
    LagonCDown    :: 17179869184;

    AnyLeft       :: 1118208;
    AnyUp         :: 2236416;
    AnyRight      :: 4472832;
    AnyDown       :: 8945664;
    AnySL         :: 83886080;
    AnySR         :: 167772160;
}

/// HidDebugPadAttribute
HidDebugPadAttribute :: enum_flags u32 {
    IsConnected :: 1;
}

/// HidTouchAttribute
HidTouchAttribute :: enum_flags u32 {
    Start :: 1;
    End   :: 2;
}

/// HidMouseAttribute
HidMouseAttribute :: enum_flags u32 {
    Transferable :: 1;
    IsConnected  :: 2;
}

/// HidNpadAttribute
HidNpadAttribute :: enum_flags u32 {
    IsConnected      :: 1;
    IsWired          :: 2;
    IsLeftConnected  :: 4;
    IsLeftWired      :: 8;
    IsRightConnected :: 16;
    IsRightWired     :: 32;
}

/// HidSixAxisSensorAttribute
HidSixAxisSensorAttribute :: enum_flags u32 {
    IsConnected    :: 1;
    IsInterpolated :: 2;
}

/// HidGestureAttribute
HidGestureAttribute :: enum_flags u32 {
    IsNewTouch  :: 16;
    IsDoubleTap :: 256;
}

/// HidGestureDirection
HidGestureDirection :: enum u32 {
    None  :: 0;
    Left  :: 1;
    Up    :: 2;
    Right :: 3;
    Down  :: 4;
}

/// HidGestureType
HidGestureType :: enum u32 {
    Idle     :: 0;
    Complete :: 1;
    Cancel   :: 2;
    Touch    :: 3;
    Press    :: 4;
    Tap      :: 5;
    Pan      :: 6;
    Swipe    :: 7;
    Pinch    :: 8;
    Rotate   :: 9;
}

/// GyroscopeZeroDriftMode
HidGyroscopeZeroDriftMode :: enum u32 {
    Loose    :: 0;
    Standard :: 1;
    Tight    :: 2;
}

/// NpadJoyHoldType
HidNpadJoyHoldType :: enum u32 {
    Vertical   :: 0;
    Horizontal :: 1;
}

/// NpadJoyDeviceType
HidNpadJoyDeviceType :: enum u32 {
    Left  :: 0;
    Right :: 1;
}

/// This controls how many Joy-Cons must be attached for handheld-mode to be activated.
HidNpadHandheldActivationMode :: enum u32 {
    Dual   :: 0;
    Single :: 1;
    None   :: 2;
}

/// NpadJoyAssignmentMode
HidNpadJoyAssignmentMode :: enum u32 {
    Dual   :: 0;
    Single :: 1;
}

/// NpadCommunicationMode
HidNpadCommunicationMode :: enum u32 {
    _5ms    :: 0;
    _10ms   :: 1;
    _15ms   :: 2;
    Default :: 3;
}

/// DeviceType (system)
HidDeviceTypeBits :: enum u32 {
    FullKey              :: 1;
    DebugPad             :: 2;
    HandheldLeft         :: 4;
    HandheldRight        :: 8;
    JoyLeft              :: 16;
    JoyRight             :: 32;
    Palma                :: 64;
    LarkHvcLeft          :: 128;
    LarkHvcRight         :: 256;
    LarkNesLeft          :: 512;
    LarkNesRight         :: 1024;
    HandheldLarkHvcLeft  :: 2048;
    HandheldLarkHvcRight :: 4096;
    HandheldLarkNesLeft  :: 8192;
    HandheldLarkNesRight :: 16384;
    Lucia                :: 32768;
    Lagon                :: 65536;
    Lager                :: 131072;
    System               :: 2147483648;
}

/// Internal DeviceType for [9.0.0+]. Converted to/from the pre-9.0.0 version of this by the hiddbg funcs.
HidDeviceType :: enum u32 {
    JoyRight1    :: 1;
    JoyLeft2     :: 2;
    FullKey3     :: 3;
    JoyLeft4     :: 4;
    JoyRight5    :: 5;
    FullKey6     :: 6;
    LarkHvcLeft  :: 7;
    LarkHvcRight :: 8;
    LarkNesLeft  :: 9;
    LarkNesRight :: 10;
    Lucia        :: 11;
    Palma        :: 12;
    FullKey13    :: 13;
    FullKey15    :: 15;
    DebugPad     :: 17;
    System19     :: 19;
    System20     :: 20;
    System21     :: 21;
    Lagon        :: 22;
    Lager        :: 28;
}

/// AppletFooterUiType (system)
HidAppletFooterUiType :: enum u32 {
    None                          :: 0;
    HandheldNone                  :: 1;
    HandheldJoyConLeftOnly        :: 2;
    HandheldJoyConRightOnly       :: 3;
    HandheldJoyConLeftJoyConRight :: 4;
    JoyDual                       :: 5;
    JoyDualLeftOnly               :: 6;
    JoyDualRightOnly              :: 7;
    JoyLeftHorizontal             :: 8;
    JoyLeftVertical               :: 9;
    JoyRightHorizontal            :: 10;
    JoyRightVertical              :: 11;
    SwitchProController           :: 12;
    CompatibleProController       :: 13;
    CompatibleJoyCon              :: 14;
    LarkHvc1                      :: 15;
    LarkHvc2                      :: 16;
    LarkNesLeft                   :: 17;
    LarkNesRight                  :: 18;
    Lucia                         :: 19;
    Verification                  :: 20;
    Lagon                         :: 21;
}

/// NpadInterfaceType (system)
HidNpadInterfaceType :: enum u32 {
    Bluetooth :: 1;
    Rail      :: 2;
    USB       :: 3;
    Unknown4  :: 4;
}

/// XcdInterfaceType
XcdInterfaceType :: enum u32 {
    Bluetooth :: 1;
    Uart      :: 2;
    Usb       :: 4;
    FieldSet  :: 128;
}

/// NpadLarkType
HidNpadLarkType :: enum u32 {
    Invalid :: 0;
    H1      :: 1;
    H2      :: 2;
    NL      :: 3;
    NR      :: 4;
}

/// NpadLuciaType
HidNpadLuciaType :: enum u32 {
    Invalid :: 0;
    J       :: 1;
    E       :: 2;
    U       :: 3;
}

/// NpadLagerType
HidNpadLagerType :: enum u32 {
    Invalid :: 0;
    J       :: 1;
    E       :: 2;
    U       :: 3;
}

/// Type values for HidVibrationDeviceInfo::type.
HidVibrationDeviceType :: enum u32 {
    Unknown                :: 0;
    LinearResonantActuator :: 1;
    GcErm                  :: 2;
}

/// VibrationDevicePosition
HidVibrationDevicePosition :: enum u32 {
    None  :: 0;
    Left  :: 1;
    Right :: 2;
}

/// VibrationGcErmCommand
HidVibrationGcErmCommand :: enum u32 {
    Stop     :: 0;
    Start    :: 1;
    StopHard :: 2;
}

/// PalmaOperationType
HidPalmaOperationType :: enum u32 {
    PlayActivity                       :: 0;
    SetFrModeType                      :: 1;
    ReadStep                           :: 2;
    EnableStep                         :: 3;
    ResetStep                          :: 4;
    ReadApplicationSection             :: 5;
    WriteApplicationSection            :: 6;
    ReadUniqueCode                     :: 7;
    SetUniqueCodeInvalid               :: 8;
    WriteActivityEntry                 :: 9;
    WriteRgbLedPatternEntry            :: 10;
    WriteWaveEntry                     :: 11;
    ReadDataBaseIdentificationVersion  :: 12;
    WriteDataBaseIdentificationVersion :: 13;
    SuspendFeature                     :: 14;
    ReadPlayLog                        :: 15;
    ResetPlayLog                       :: 16;
}

/// PalmaFrModeType
HidPalmaFrModeType :: enum u32 {
    Off        :: 0;
    B01        :: 1;
    B02        :: 2;
    B03        :: 3;
    Downloaded :: 4;
}

/// PalmaWaveSet
HidPalmaWaveSet :: enum u32 {
    Small  :: 0;
    Medium :: 1;
    Large  :: 2;
}

/// PalmaFeature
HidPalmaFeature :: enum u32 {
    FrMode         :: 1;
    RumbleFeedback :: 2;
    Step           :: 4;
    MuteSwitch     :: 8;
}

/// HidAnalogStickState
HidAnalogStickState :: struct {
    x: s32; ///< X
    y: s32; ///< Y
}

/// HidVector
HidVector :: struct {
    x: float;
    y: float;
    z: float;
}

/// HidDirectionState
HidDirectionState :: struct {
    direction: [3] [3] float; ///< 3x3 matrix
}

/// HidCommonLifoHeader
HidCommonLifoHeader :: struct {
    unused:       u64; ///< Unused
    buffer_count: u64; ///< BufferCount
    tail:         u64; ///< Tail
    count:        u64; ///< Count
}

/// HidDebugPadState
HidDebugPadState :: struct {
    sampling_number: u64; ///< SamplingNumber
    attributes:      u32; ///< Bitfield of \ref HidDebugPadAttribute.
    buttons:         u32; ///< Bitfield of \ref HidDebugPadButton.
    analog_stick_r:  HidAnalogStickState; ///< AnalogStickR
    analog_stick_l:  HidAnalogStickState; ///< AnalogStickL
}

/// HidDebugPadStateAtomicStorage
HidDebugPadStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidDebugPadState; ///< \ref HidDebugPadState
}

/// HidDebugPadLifo
HidDebugPadLifo :: struct {
    header:  HidCommonLifoHeader; ///< \ref HidCommonLifoHeader
    storage: [17] HidDebugPadStateAtomicStorage; ///< \ref HidDebugPadStateAtomicStorage
}

/// HidDebugPadSharedMemoryFormat
HidDebugPadSharedMemoryFormat :: struct {
    lifo:    HidDebugPadLifo;
    padding: [312] u8;
}

/// HidTouchState
HidTouchState :: struct {
    delta_time:     u64; ///< DeltaTime
    attributes:     u32; ///< Bitfield of \ref HidTouchAttribute.
    finger_id:      u32; ///< FingerId
    x:              u32; ///< X
    y:              u32; ///< Y
    diameter_x:     u32; ///< DiameterX
    diameter_y:     u32; ///< DiameterY
    rotation_angle: u32; ///< RotationAngle
    reserved:       u32; ///< Reserved
}

/// HidTouchScreenState
HidTouchScreenState :: struct {
    sampling_number: u64; ///< SamplingNumber
    count:           s32; ///< Number of entries in the touches array.
    reserved:        u32; ///< Reserved
    touches:         [16] HidTouchState; ///< Array of \ref HidTouchState, with the above count.
}

/// HidTouchScreenStateAtomicStorage
HidTouchScreenStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidTouchScreenState; ///< \ref HidTouchScreenState
}

/// HidTouchScreenLifo
HidTouchScreenLifo :: struct {
    header:  HidCommonLifoHeader; ///< \ref HidCommonLifoHeader
    storage: [17] HidTouchScreenStateAtomicStorage; ///< \ref HidTouchScreenStateAtomicStorage
}

/// HidTouchScreenSharedMemoryFormat
HidTouchScreenSharedMemoryFormat :: struct {
    lifo:    HidTouchScreenLifo;
    padding: [968] u8;
}

/// HidTouchScreenConfigurationForNx
HidTouchScreenConfigurationForNx :: struct {
    mode:     u8; ///< \ref HidTouchScreenModeForNx
    reserved: [15] u8; ///< Reserved
}

/// HidMouseState
HidMouseState :: struct {
    sampling_number: u64; ///< SamplingNumber
    x:               s32; ///< X
    y:               s32; ///< Y
    delta_x:         s32; ///< DeltaX
    delta_y:         s32; ///< DeltaY
    wheel_delta_x:   s32; ///< WheelDeltaX
    wheel_delta_y:   s32; ///< WheelDeltaY
    buttons:         u32; ///< Bitfield of \ref HidMouseButton.
    attributes:      u32; ///< Bitfield of \ref HidMouseAttribute.
}

/// HidMouseStateAtomicStorage
HidMouseStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidMouseState;
}

/// HidMouseLifo
HidMouseLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidMouseStateAtomicStorage;
}

/// HidMouseSharedMemoryFormat
HidMouseSharedMemoryFormat :: struct {
    lifo:    HidMouseLifo;
    padding: [176] u8;
}

/// HidKeyboardState
HidKeyboardState :: struct {
    sampling_number: u64; ///< SamplingNumber
    modifiers:       u64; ///< Bitfield of \ref HidKeyboardModifier.
    keys:            [4] u64;
}

/// HidKeyboardStateAtomicStorage
HidKeyboardStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidKeyboardState;
}

/// HidKeyboardLifo
HidKeyboardLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidKeyboardStateAtomicStorage;
}

/// HidKeyboardSharedMemoryFormat
HidKeyboardSharedMemoryFormat :: struct {
    lifo:    HidKeyboardLifo;
    padding: [40] u8;
}

/// Npad colors.
/// Color fields are zero when not set.
HidNpadControllerColor :: struct {
    main: u32; ///< RGBA Body Color
    sub:  u32; ///< RGBA Buttons Color
}

/// HidNpadFullKeyColorState
HidNpadFullKeyColorState :: struct {
    attribute: u32; ///< \ref HidColorAttribute
    full_key:  HidNpadControllerColor; ///< \ref HidNpadControllerColor FullKey
}

/// HidNpadJoyColorState
HidNpadJoyColorState :: struct {
    attribute: u32; ///< \ref HidColorAttribute
    left:      HidNpadControllerColor; ///< \ref HidNpadControllerColor Left
    right:     HidNpadControllerColor; ///< \ref HidNpadControllerColor Right
}

/// HidNpadCommonState
HidNpadCommonState :: struct {
    sampling_number: u64; ///< SamplingNumber
    buttons:         u64; ///< Bitfield of \ref HidNpadButton.
    analog_stick_l:  HidAnalogStickState; ///< AnalogStickL
    analog_stick_r:  HidAnalogStickState; ///< AnalogStickR
    attributes:      u32; ///< Bitfield of \ref HidNpadAttribute.
    reserved:        u32; ///< Reserved
}

HidNpadFullKeyState :: HidNpadCommonState;
HidNpadHandheldState :: HidNpadCommonState;
HidNpadJoyDualState :: HidNpadCommonState;
HidNpadJoyLeftState :: HidNpadCommonState;
HidNpadJoyRightState :: HidNpadCommonState;

/// State for ::HidNpadStyleTag_NpadGc. Loaded from the same lifo as \ref HidNpadFullKeyState, with the additional trigger_l/trigger_r loaded from elsewhere.
HidNpadGcState :: struct {
    sampling_number: u64; ///< SamplingNumber
    buttons:         u64; ///< Bitfield of \ref HidNpadButton.
    analog_stick_l:  HidAnalogStickState; ///< AnalogStickL
    analog_stick_r:  HidAnalogStickState; ///< AnalogStickR
    attributes:      u32; ///< Bitfield of \ref HidNpadAttribute.
    trigger_l:       u32; ///< L analog trigger. Valid range: 0x0-0x7FFF.
    trigger_r:       u32; ///< R analog trigger. Valid range: 0x0-0x7FFF.
    pad:             u32;
}

HidNpadPalmaState :: HidNpadCommonState;

/// State for ::HidNpadStyleTag_NpadLark. The base state is loaded from the same lifo as \ref HidNpadFullKeyState.
HidNpadLarkState :: struct {
    sampling_number:      u64; ///< SamplingNumber
    buttons:              u64; ///< Bitfield of \ref HidNpadButton.
    analog_stick_l:       HidAnalogStickState; ///< This is always zero.
    analog_stick_r:       HidAnalogStickState; ///< This is always zero.
    attributes:           u32; ///< Bitfield of \ref HidNpadAttribute.
    lark_type_l_and_main: HidNpadLarkType; ///< \ref HidNpadLarkType LarkTypeLAndMain
}

/// State for ::HidNpadStyleTag_NpadHandheldLark. The base state is loaded from the same lifo as \ref HidNpadHandheldState.
HidNpadHandheldLarkState :: struct {
    sampling_number:      u64; ///< SamplingNumber
    buttons:              u64; ///< Bitfield of \ref HidNpadButton.
    analog_stick_l:       HidAnalogStickState; ///< AnalogStickL
    analog_stick_r:       HidAnalogStickState; ///< AnalogStickR
    attributes:           u32; ///< Bitfield of \ref HidNpadAttribute.
    lark_type_l_and_main: HidNpadLarkType; ///< \ref HidNpadLarkType LarkTypeLAndMain
    lark_type_r:          HidNpadLarkType; ///< \ref HidNpadLarkType LarkTypeR
    pad:                  u32;
}

/// State for ::HidNpadStyleTag_NpadLucia. The base state is loaded from the same lifo as \ref HidNpadFullKeyState.
HidNpadLuciaState :: struct {
    sampling_number: u64; ///< SamplingNumber
    buttons:         u64; ///< Bitfield of \ref HidNpadButton.
    analog_stick_l:  HidAnalogStickState; ///< This is always zero.
    analog_stick_r:  HidAnalogStickState; ///< This is always zero.
    attributes:      u32; ///< Bitfield of \ref HidNpadAttribute.
    lucia_type:      HidNpadLuciaType; ///< \ref HidNpadLuciaType
}

HidNpadLagerState :: HidNpadCommonState;

HidNpadSystemExtState :: HidNpadCommonState;
HidNpadSystemState :: HidNpadCommonState;

/// HidNpadCommonStateAtomicStorage
HidNpadCommonStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidNpadCommonState;
}

/// HidNpadCommonLifo
HidNpadCommonLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidNpadCommonStateAtomicStorage;
}

/// HidNpadGcTriggerState
HidNpadGcTriggerState :: struct {
    sampling_number: u64; ///< SamplingNumber
    trigger_l:       u32;
    trigger_r:       u32;
}

/// HidNpadGcTriggerStateAtomicStorage
HidNpadGcTriggerStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidNpadGcTriggerState;
}

/// HidNpadGcTriggerLifo
HidNpadGcTriggerLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidNpadGcTriggerStateAtomicStorage;
}

/// HidSixAxisSensorState
HidSixAxisSensorState :: struct {
    delta_time:       u64; ///< DeltaTime
    sampling_number:  u64; ///< SamplingNumber
    acceleration:     HidVector; ///< Acceleration
    angular_velocity: HidVector; ///< AngularVelocity
    angle:            HidVector; ///< Angle
    direction:        HidDirectionState; ///< Direction
    attributes:       u32; ///< Bitfield of \ref HidSixAxisSensorAttribute.
    reserved:         u32; ///< Reserved
}

/// HidSixAxisSensorStateAtomicStorage
HidSixAxisSensorStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidSixAxisSensorState;
}

/// HidNpadSixAxisSensorLifo
HidNpadSixAxisSensorLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidSixAxisSensorStateAtomicStorage;
}

/// HidPowerInfo (system)
HidPowerInfo :: struct {
    is_powered:    bool; ///< IsPowered
    is_charging:   bool; ///< IsCharging
    reserved:      [6] u8; ///< Reserved
    battery_level: u32; ///< BatteryLevel, always 0-4.
}

/// XcdDeviceHandle
XcdDeviceHandle :: struct {
    handle: u64;
}

/// HidNfcXcdDeviceHandleStateImpl
HidNfcXcdDeviceHandleStateImpl :: struct {
    handle:          XcdDeviceHandle;
    is_available:    u8;
    is_activated:    u8;
    reserved:        [6] u8;
    sampling_number: u64; ///< SamplingNumber
}

/// HidNfcXcdDeviceHandleStateImplAtomicStorage
HidNfcXcdDeviceHandleStateImplAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidNfcXcdDeviceHandleStateImpl; ///< \ref HidNfcXcdDeviceHandleStateImpl
}

/// HidNfcXcdDeviceHandleState
HidNfcXcdDeviceHandleState :: struct {
    header:  HidCommonLifoHeader;
    storage: [2] HidNfcXcdDeviceHandleStateImplAtomicStorage;
}

/// HidNpadInternalState
HidNpadInternalState :: struct {
    style_set:                           u32; ///< Bitfield of \ref HidNpadStyleTag.
    joy_assignment_mode:                 u32; ///< \ref HidNpadJoyAssignmentMode
    full_key_color:                      HidNpadFullKeyColorState; ///< \ref HidNpadFullKeyColorState
    joy_color:                           HidNpadJoyColorState; ///< \ref HidNpadJoyColorState

    full_key_lifo:                       HidNpadCommonLifo; ///< FullKeyLifo
    handheld_lifo:                       HidNpadCommonLifo; ///< HandheldLifo
    joy_dual_lifo:                       HidNpadCommonLifo; ///< JoyDualLifo
    joy_left_lifo:                       HidNpadCommonLifo; ///< JoyLeftLifo
    joy_right_lifo:                      HidNpadCommonLifo; ///< JoyRightLifo
    palma_lifo:                          HidNpadCommonLifo; ///< PalmaLifo
    system_ext_lifo:                     HidNpadCommonLifo; ///< SystemExtLifo

    full_key_six_axis_sensor_lifo:       HidNpadSixAxisSensorLifo; ///< FullKeySixAxisSensorLifo
    handheld_six_axis_sensor_lifo:       HidNpadSixAxisSensorLifo; ///< HandheldSixAxisSensorLifo
    joy_dual_left_six_axis_sensor_lifo:  HidNpadSixAxisSensorLifo; ///< JoyDualLeftSixAxisSensorLifo
    joy_dual_right_six_axis_sensor_lifo: HidNpadSixAxisSensorLifo; ///< JoyDualRightSixAxisSensorLifo
    joy_left_six_axis_sensor_lifo:       HidNpadSixAxisSensorLifo; ///< JoyLeftSixAxisSensorLifo
    joy_right_six_axis_sensor_lifo:      HidNpadSixAxisSensorLifo; ///< JoyRightSixAxisSensorLifo

    device_type:                         u32; ///< Bitfield of \ref HidDeviceTypeBits.
    reserved:                            u32; ///< Reserved
    system_properties:                   HidNpadSystemProperties;
    system_button_properties:            HidNpadSystemButtonProperties;
    battery_level:                       [3] u32;
    union {
        struct {
            nfc_xcd_device_handle: HidNfcXcdDeviceHandleState;
        }

        struct {
            applet_footer_ui_attribute: u32; ///< Bitfield of AppletFooterUiAttribute.
            applet_footer_ui_type:      u8; ///< \ref HidAppletFooterUiType
            reserved_x41AD:             [91] u8;
        }
    }

    reserved_x4208:                      [32] u8; ///< Mutex on pre-10.0.0.
    gc_trigger_lifo:                     HidNpadGcTriggerLifo;
    lark_type_l_and_main:                u32; ///< \ref HidNpadLarkType
    lark_type_r:                         u32; ///< \ref HidNpadLarkType
    lucia_type:                          u32; ///< \ref HidNpadLuciaType
    lager_type:                          u32; ///< \ref HidNpadLagerType
}

/// HidNpadSharedMemoryEntry
HidNpadSharedMemoryEntry :: struct {
    internal_state: HidNpadInternalState;
    pad:            [3088] u8;
}

/// HidNpadSharedMemoryFormat
HidNpadSharedMemoryFormat :: struct {
    entries: [10] HidNpadSharedMemoryEntry;
}

/// HidGesturePoint
HidGesturePoint :: struct {
    x: u32; ///< X
    y: u32; ///< Y
}

/// HidGestureState
HidGestureState :: struct {
    sampling_number: u64; ///< SamplingNumber
    context_number:  u64; ///< ContextNumber
    type:            u32; ///< \ref HidGestureType
    direction:       u32; ///< \ref HidGestureDirection
    x:               u32; ///< X
    y:               u32; ///< Y
    delta_x:         s32; ///< DeltaX
    delta_y:         s32; ///< DeltaY
    velocity_x:      float; ///< VelocityX
    velocity_y:      float; ///< VelocityY
    attributes:      u32; ///< Bitfield of \ref HidGestureAttribute.
    scale:           float; ///< Scale
    rotation_angle:  float; ///< RotationAngle
    point_count:     s32; ///< Number of entries in the points array.
    points:          [4] HidGesturePoint; ///< Array of \ref HidGesturePoint with the above count.
}

/// HidGestureDummyStateAtomicStorage
HidGestureDummyStateAtomicStorage :: struct {
    sampling_number: u64; ///< SamplingNumber
    state:           HidGestureState;
}

/// HidGestureLifo
HidGestureLifo :: struct {
    header:  HidCommonLifoHeader;
    storage: [17] HidGestureDummyStateAtomicStorage;
}

/// HidGestureSharedMemoryFormat
HidGestureSharedMemoryFormat :: struct {
    lifo: HidGestureLifo;
    pad:  [248] u8;
}

/// HidConsoleSixAxisSensor
HidConsoleSixAxisSensor :: struct {
    sampling_number:                  u64; ///< SamplingNumber
    is_seven_six_axis_sensor_at_rest: u8; ///< IsSevenSixAxisSensorAtRest
    pad:                              [3] u8; ///< Padding
    verticalization_error:            float; ///< VerticalizationError
    gyro_bias:                        UtilFloat3; ///< GyroBias
    pad2:                             [4] u8; ///< Padding
}

/// HidSharedMemory
HidSharedMemory :: struct {
    debug_pad:               HidDebugPadSharedMemoryFormat;
    touchscreen:             HidTouchScreenSharedMemoryFormat;
    mouse:                   HidMouseSharedMemoryFormat;
    keyboard:                HidKeyboardSharedMemoryFormat;
    digitizer:               [4096] u8; ///< [10.0.0+] Digitizer [1.0.0-9.2.0] BasicXpad
    home_button:             [512] u8;
    sleep_button:            [512] u8;
    capture_button:          [512] u8;
    input_detector:          [2048] u8;
    unique_pad:              [16384] u8; ///< [1.0.0-4.1.0] UniquePad
    npad:                    HidNpadSharedMemoryFormat;
    gesture:                 HidGestureSharedMemoryFormat;
    console_six_axis_sensor: HidConsoleSixAxisSensor; ///< [5.0.0+] ConsoleSixAxisSensor
    unk_x3C220:              [15840] u8;
}

/// HidSevenSixAxisSensorState
HidSevenSixAxisSensorState :: struct {
    timestamp0:      u64;
    sampling_number: u64;

    unk_x10:         u64;
    unk_x18:         [10] float;
}

/// HidSevenSixAxisSensorStateEntry
HidSevenSixAxisSensorStateEntry :: struct {
    sampling_number: u64;
    unused:          u64;
    state:           HidSevenSixAxisSensorState;
}

/// HidSevenSixAxisSensorStates
HidSevenSixAxisSensorStates :: struct {
    header:  HidCommonLifoHeader;
    storage: [33] HidSevenSixAxisSensorStateEntry;
}

/// HidSixAxisSensorHandle
HidSixAxisSensorHandle :: union {
    type_value: u32; ///< TypeValue
}

/// HidVibrationDeviceHandle
HidVibrationDeviceHandle :: union {
    type_value: u32; ///< TypeValue
}

/// HidVibrationDeviceInfo
HidVibrationDeviceInfo :: struct {
    type:     u32; ///< \ref HidVibrationDeviceType
    position: u32; ///< \ref HidVibrationDevicePosition
}

/// HidVibrationValue
HidVibrationValue :: struct {
    amp_low:   float; ///< Low Band amplitude. 1.0f: Max amplitude.
    freq_low:  float; ///< Low Band frequency in Hz.
    amp_high:  float; ///< High Band amplitude. 1.0f: Max amplitude.
    freq_high: float; ///< High Band frequency in Hz.
}

/// PalmaConnectionHandle
HidPalmaConnectionHandle :: struct {
    handle: u64; ///< Handle
}

/// PalmaOperationInfo
HidPalmaOperationInfo :: struct {
    type: u32; ///< \ref HidPalmaOperationType
    res:  Result; ///< Result
    data: [320] u8; ///< Data
}

/// PalmaApplicationSectionAccessBuffer
HidPalmaApplicationSectionAccessBuffer :: struct {
    data: [256] u8; ///< Application data.
}

/// PalmaActivityEntry
HidPalmaActivityEntry :: struct {
    rgb_led_pattern_index: u16; ///< RgbLedPatternIndex
    pad:                   u16; ///< Padding
    wave_set:              u32; ///< \ref HidPalmaWaveSet
    wave_index:            u16; ///< WaveIndex
}

/// Initialize hid. Called automatically during app startup.
hidInitialize :: () -> Result #foreign libnx;

/// Exit hid. Called automatically during app exit.
hidExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual hid service session.
hidGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the address of the SharedMemory.
hidGetSharedmemAddr :: () -> *void #foreign libnx;

/// Initialize TouchScreen. Must be called when TouchScreen is being used. Used automatically by \ref hidScanInput when required.
hidInitializeTouchScreen :: () -> void #foreign libnx;

/**
* @brief Gets \ref HidTouchScreenState.
* @param[out] states Output array of \ref HidTouchScreenState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetTouchScreenStates :: (states: *HidTouchScreenState, count: u64) -> u64 #foreign libnx;

/// Initialize Mouse. Must be called when Mouse is being used. Used automatically by \ref hidScanInput when required.
hidInitializeMouse :: () -> void #foreign libnx;

/**
* @brief Gets \ref HidMouseState.
* @param[out] states Output array of \ref HidMouseState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetMouseStates :: (states: *HidMouseState, count: u64) -> u64 #foreign libnx;

/// Initialize Keyboard. Must be called when Keyboard is being used. Used automatically by \ref hidScanInput when required.
hidInitializeKeyboard :: () -> void #foreign libnx;

/**
* @brief Gets \ref HidKeyboardState.
* @param[out] states Output array of \ref HidKeyboardState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetKeyboardStates :: (states: *HidKeyboardState, count: u64) -> u64 #foreign libnx;

/// Initialize Npad. Must be called when Npad is being used. Used automatically by \ref hidScanInput when required.
hidInitializeNpad :: () -> void #foreign libnx;

/**
* @brief Gets the StyleSet for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @return Bitfield of \ref HidNpadStyleTag.
*/
hidGetNpadStyleSet :: (id: HidNpadIdType) -> u32 #foreign libnx;

/**
* @brief Gets the \ref HidNpadJoyAssignmentMode for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @return \ref HidNpadJoyAssignmentMode
*/
hidGetNpadJoyAssignment :: (id: HidNpadIdType) -> HidNpadJoyAssignmentMode #foreign libnx;

/**
* @brief Gets the main \ref HidNpadControllerColor for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @param[out] color \ref HidNpadControllerColor
*/
hidGetNpadControllerColorSingle :: (id: HidNpadIdType, color: *HidNpadControllerColor) -> Result #foreign libnx;

/**
* @brief Gets the left/right \ref HidNpadControllerColor for the specified Npad (Joy-Con pair in dual mode).
* @param[in] id \ref HidNpadIdType
* @param[out] color_left \ref HidNpadControllerColor
* @param[out] color_right \ref HidNpadControllerColor
*/
hidGetNpadControllerColorSplit :: (id: HidNpadIdType, color_left: *HidNpadControllerColor, color_right: *HidNpadControllerColor) -> Result #foreign libnx;

/**
* @brief Gets the DeviceType for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @return Bitfield of \ref HidDeviceTypeBits.
*/
hidGetNpadDeviceType :: (id: HidNpadIdType) -> u32 #foreign libnx;

/**
* @brief Gets the \ref HidNpadSystemProperties for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @param[out] out \ref HidNpadSystemProperties
*/
hidGetNpadSystemProperties :: (id: HidNpadIdType, out: *HidNpadSystemProperties) -> void #foreign libnx;

/**
* @brief Gets the \ref HidNpadSystemButtonProperties for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @param[out] out \ref HidNpadSystemButtonProperties
*/
hidGetNpadSystemButtonProperties :: (id: HidNpadIdType, out: *HidNpadSystemButtonProperties) -> void #foreign libnx;

/**
* @brief Gets the main \ref HidPowerInfo for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @param[out] info \ref HidPowerInfo
*/
hidGetNpadPowerInfoSingle :: (id: HidNpadIdType, info: *HidPowerInfo) -> void #foreign libnx;

/**
* @brief Gets the left/right \ref HidPowerInfo for the specified Npad (Joy-Con pair in dual mode).
* @param[in] id \ref HidNpadIdType
* @param[out] info_left \ref HidPowerInfo
* @param[out] info_right \ref HidPowerInfo
*/
hidGetNpadPowerInfoSplit :: (id: HidNpadIdType, info_left: *HidPowerInfo, info_right: *HidPowerInfo) -> void #foreign libnx;

/**
* @brief Gets the AppletFooterUiAttributesSet for the specified Npad.
* @note Only available on [9.0.0+].
* @param[in] id \ref HidNpadIdType
* @return Bitfield of AppletFooterUiAttribute (system).
*/
hidGetAppletFooterUiAttributesSet :: (id: HidNpadIdType) -> u32 #foreign libnx;

/**
* @brief Gets \ref HidAppletFooterUiType for the specified Npad.
* @note Only available on [9.0.0+].
* @param[in] id \ref HidNpadIdType
* @return \ref HidAppletFooterUiType
*/
hidGetAppletFooterUiTypes :: (id: HidNpadIdType) -> HidAppletFooterUiType #foreign libnx;

/**
* @brief Gets \ref HidNpadLagerType for the specified Npad.
* @param[in] id \ref HidNpadIdType
* @return \ref HidNpadLagerType
*/
hidGetNpadLagerType :: (id: HidNpadIdType) -> HidNpadLagerType #foreign libnx;

/**
* @brief Gets \ref HidNpadFullKeyState.
* @param[out] states Output array of \ref HidNpadFullKeyState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesFullKey :: (id: HidNpadIdType, states: *HidNpadFullKeyState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadHandheldState.
* @param[out] states Output array of \ref HidNpadHandheldState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesHandheld :: (id: HidNpadIdType, states: *HidNpadHandheldState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadJoyDualState.
* @param[out] states Output array of \ref HidNpadJoyDualState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesJoyDual :: (id: HidNpadIdType, states: *HidNpadJoyDualState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadJoyLeftState.
* @param[out] states Output array of \ref HidNpadJoyLeftState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesJoyLeft :: (id: HidNpadIdType, states: *HidNpadJoyLeftState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadJoyRightState.
* @param[out] states Output array of \ref HidNpadJoyRightState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesJoyRight :: (id: HidNpadIdType, states: *HidNpadJoyRightState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadGcState.
* @param[out] states Output array of \ref HidNpadGcState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesGc :: (id: HidNpadIdType, states: *HidNpadGcState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadPalmaState.
* @param[out] states Output array of \ref HidNpadPalmaState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesPalma :: (id: HidNpadIdType, states: *HidNpadPalmaState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadLarkState.
* @param[out] states Output array of \ref HidNpadLarkState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesLark :: (id: HidNpadIdType, states: *HidNpadLarkState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadHandheldLarkState.
* @param[out] states Output array of \ref HidNpadHandheldLarkState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesHandheldLark :: (id: HidNpadIdType, states: *HidNpadHandheldLarkState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadLuciaState.
* @param[out] states Output array of \ref HidNpadLuciaState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesLucia :: (id: HidNpadIdType, states: *HidNpadLuciaState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadLagerState.
* @param[out] states Output array of \ref HidNpadLagerState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesLager :: (id: HidNpadIdType, states: *HidNpadLagerState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadSystemExtState.
* @param[out] states Output array of \ref HidNpadSystemExtState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesSystemExt :: (id: HidNpadIdType, states: *HidNpadSystemExtState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidNpadSystemState.
* @param[out] states Output array of \ref HidNpadSystemState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetNpadStatesSystem :: (id: HidNpadIdType, states: *HidNpadSystemState, count: u64) -> u64 #foreign libnx;

/**
* @brief Gets \ref HidSixAxisSensorState for the specified handle.
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] states Output array of \ref HidSixAxisSensorState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetSixAxisSensorStates :: (handle: HidSixAxisSensorHandle, states: *HidSixAxisSensorState, count: u64) -> u64 #foreign libnx;

/// Initialize Gesture. Must be called when Gesture is being used.
hidInitializeGesture :: () -> void #foreign libnx;

/**
* @brief Gets \ref HidGestureState.
* @param[out] states Output array of \ref HidGestureState.
* @param[in] count Size of the states array in entries.
* @return Total output entries.
*/
hidGetGestureStates :: (states: *HidGestureState, count: u64) -> u64 #foreign libnx;

/**
* @brief SendKeyboardLockKeyEvent
* @note Same as \ref hidsysSendKeyboardLockKeyEvent.
* @note Only available on [6.0.0+].
* @param[in] events Bitfield of \ref HidKeyboardLockKeyEvent.
*/
hidSendKeyboardLockKeyEvent :: (events: u32) -> Result #foreign libnx;

/**
* @brief Gets SixAxisSensorHandles.
* @note Only ::HidNpadStyleTag_NpadJoyDual supports total_handles==2.
* @param[out] handles Output array of \ref HidSixAxisSensorHandle.
* @param[in] total_handles Total handles for the handles array. Must be 1 or 2, if 2 handles aren't supported by the specified style an error is thrown.
* @param[in] id \ref HidNpadIdType
* @param[in] style \ref HidNpadStyleTag
*/
hidGetSixAxisSensorHandles :: (handles: *HidSixAxisSensorHandle, total_handles: s32, id: HidNpadIdType, style: HidNpadStyleTag) -> Result #foreign libnx;

/**
* @brief Starts the SixAxisSensor for the specified handle.
* @param[in] handle \ref HidSixAxisSensorHandle
*/
hidStartSixAxisSensor :: (handle: HidSixAxisSensorHandle) -> Result #foreign libnx;

/**
* @brief Stops the SixAxisSensor for the specified handle.
* @param[in] handle \ref HidSixAxisSensorHandle
*/
hidStopSixAxisSensor :: (handle: HidSixAxisSensorHandle) -> Result #foreign libnx;

/**
* @brief IsSixAxisSensorFusionEnabled
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] out Output flag.
*/
hidIsSixAxisSensorFusionEnabled :: (handle: HidSixAxisSensorHandle, out: *bool) -> Result #foreign libnx;

/**
* @brief EnableSixAxisSensorFusion
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[in] flag Flag
*/
hidEnableSixAxisSensorFusion :: (handle: HidSixAxisSensorHandle, flag: bool) -> Result #foreign libnx;

/**
* @brief SetSixAxisSensorFusionParameters
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[in] unk0 Must be 0.0f-1.0f.
* @param[in] unk1 Unknown
*/
hidSetSixAxisSensorFusionParameters :: (handle: HidSixAxisSensorHandle, unk0: float, unk1: float) -> Result #foreign libnx;

/**
* @brief GetSixAxisSensorFusionParameters
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] unk0 Unknown
* @param[out] unk1 Unknown
*/
hidGetSixAxisSensorFusionParameters :: (handle: HidSixAxisSensorHandle, unk0: *float, unk1: *float) -> Result #foreign libnx;

/**
* @brief ResetSixAxisSensorFusionParameters
* @param[in] handle \ref HidSixAxisSensorHandle
*/
hidResetSixAxisSensorFusionParameters :: (handle: HidSixAxisSensorHandle) -> Result #foreign libnx;

/**
* @brief Sets the ::HidGyroscopeZeroDriftMode for the specified SixAxisSensorHandle.
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[in] mode \ref HidGyroscopeZeroDriftMode
*/
hidSetGyroscopeZeroDriftMode :: (handle: HidSixAxisSensorHandle, mode: HidGyroscopeZeroDriftMode) -> Result #foreign libnx;

/**
* @brief Gets the ::HidGyroscopeZeroDriftMode for the specified SixAxisSensorHandle.
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] mode \ref HidGyroscopeZeroDriftMode
*/
hidGetGyroscopeZeroDriftMode :: (handle: HidSixAxisSensorHandle, mode: *HidGyroscopeZeroDriftMode) -> Result #foreign libnx;

/**
* @brief Resets the ::HidGyroscopeZeroDriftMode for the specified SixAxisSensorHandle to ::HidGyroscopeZeroDriftMode_Standard.
* @param[in] handle \ref HidSixAxisSensorHandle
*/
hidResetGyroscopeZeroDriftMode :: (handle: HidSixAxisSensorHandle) -> Result #foreign libnx;

/**
* @brief IsSixAxisSensorAtRest
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] out Output flag.
*/
hidIsSixAxisSensorAtRest :: (handle: HidSixAxisSensorHandle, out: *bool) -> Result #foreign libnx;

/**
* @brief IsFirmwareUpdateAvailableForSixAxisSensor
* @note Only available on [6.0.0+].
* @param[in] handle \ref HidSixAxisSensorHandle
* @param[out] out Output flag.
*/
hidIsFirmwareUpdateAvailableForSixAxisSensor :: (handle: HidSixAxisSensorHandle, out: *bool) -> Result #foreign libnx;

/**
* @brief Sets which controller styles are supported.
* @note This is automatically called with the needed styles in \ref hidScanInput when required.
* @param[in] style_set Bitfield of \ref HidNpadStyleTag.
*/
hidSetSupportedNpadStyleSet :: (style_set: u32) -> Result #foreign libnx;

/**
* @brief Gets which controller styles are supported.
* @param[out] style_set Bitfield of \ref HidNpadStyleTag.
*/
hidGetSupportedNpadStyleSet :: (style_set: *u32) -> Result #foreign libnx;

/**
* @brief Sets which \ref HidNpadIdType are supported.
* @note This is automatically called with HidNpadIdType_No{1-8} and HidNpadIdType_Handheld when required in \ref hidScanInput.
* @param[in] ids Input array of \ref HidNpadIdType.
* @param[in] count Total entries in the ids array. Must be <=10.
*/
hidSetSupportedNpadIdType :: (ids: *HidNpadIdType, count: u64) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when the \ref hidGetNpadStyleSet output is updated for the specified controller.
* @note The Event must be closed by the user once finished with it.
* @param[in] id \ref HidNpadIdType
* @param[out] out_event Output Event.
* @param[in] autoclear The autoclear for the Event.
**/
hidAcquireNpadStyleSetUpdateEventHandle :: (id: HidNpadIdType, out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief DisconnectNpad
* @param[in] id \ref HidNpadIdType
*/
hidDisconnectNpad :: (id: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief GetPlayerLedPattern
* @param[in] id \ref HidNpadIdType
* @param[out] out Output value.
*/
hidGetPlayerLedPattern :: (id: HidNpadIdType, out: *u8) -> Result #foreign libnx;

/**
* @brief Sets the \ref HidNpadJoyHoldType.
* @note Used automatically by \ref hidScanInput when required.
* @param[in] type \ref HidNpadJoyHoldType
*/
hidSetNpadJoyHoldType :: (type: HidNpadJoyHoldType) -> Result #foreign libnx;

/**
* @brief Gets the \ref HidNpadJoyHoldType.
* @param[out] type \ref HidNpadJoyHoldType
*/
hidGetNpadJoyHoldType :: (type: *HidNpadJoyHoldType) -> Result #foreign libnx;

/**
* @brief This is the same as \ref hidSetNpadJoyAssignmentModeSingle, except ::HidNpadJoyDeviceType_Left is used for the type.
* @param[in] id \ref HidNpadIdType, must be HidNpadIdType_No*.
*/
hidSetNpadJoyAssignmentModeSingleByDefault :: (id: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief This is the same as \ref hidSetNpadJoyAssignmentModeSingleWithDestination, except without the output params.
* @param[in] id \ref HidNpadIdType, must be HidNpadIdType_No*.
* @param[in] type \ref HidNpadJoyDeviceType
*/
hidSetNpadJoyAssignmentModeSingle :: (id: HidNpadIdType, type: HidNpadJoyDeviceType) -> Result #foreign libnx;

/**
* @brief Use this if you want to use a pair of joy-cons as a single HidNpadIdType_No*. When used, both joy-cons in a pair should be used with this (HidNpadIdType_No1 and HidNpadIdType_No2 for example).
* @note Used automatically by \ref hidScanInput when required.
* @param[in] id \ref HidNpadIdType, must be HidNpadIdType_No*.
*/
hidSetNpadJoyAssignmentModeDual :: (id: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief Merge two single joy-cons into a dual-mode controller. Use this after \ref hidSetNpadJoyAssignmentModeDual, when \ref hidSetNpadJoyAssignmentModeSingleByDefault was previously used (this includes using this manually at application exit).
* @brief To be successful, id0/id1 must correspond to controllers supporting styles HidNpadStyleTag_NpadJoyLeft/Right, or HidNpadStyleTag_NpadJoyRight/Left.
* @brief If successful, the id of the resulting dual controller is set to id0.
* @param[in] id0 \ref HidNpadIdType
* @param[in] id1 \ref HidNpadIdType
*/
hidMergeSingleJoyAsDualJoy :: (id0: HidNpadIdType, id1: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief StartLrAssignmentMode
*/
hidStartLrAssignmentMode :: () -> Result #foreign libnx;

/**
* @brief StopLrAssignmentMode
*/
hidStopLrAssignmentMode :: () -> Result #foreign libnx;

/**
* @brief Sets the \ref HidNpadHandheldActivationMode.
* @param[in] mode \ref HidNpadHandheldActivationMode
*/
hidSetNpadHandheldActivationMode :: (mode: HidNpadHandheldActivationMode) -> Result #foreign libnx;

/**
* @brief Gets the \ref HidNpadHandheldActivationMode.
* @param[out] out \ref HidNpadHandheldActivationMode
*/
hidGetNpadHandheldActivationMode :: (out: *HidNpadHandheldActivationMode) -> Result #foreign libnx;

/**
* @brief SwapNpadAssignment
* @param[in] id0 \ref HidNpadIdType
* @param[in] id1 \ref HidNpadIdType
*/
hidSwapNpadAssignment :: (id0: HidNpadIdType, id1: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief EnableUnintendedHomeButtonInputProtection
* @note To get the state of this, use \ref hidGetNpadSystemButtonProperties to access HidNpadSystemButtonProperties::is_unintended_home_button_input_protection_enabled.
* @param[in] id \ref HidNpadIdType
* @param[in] flag Whether UnintendedHomeButtonInputProtection is enabled.
*/
hidEnableUnintendedHomeButtonInputProtection :: (id: HidNpadIdType, flag: bool) -> Result #foreign libnx;

/**
* @brief Use this if you want to use a single joy-con as a dedicated HidNpadIdType_No*. When used, both joy-cons in a pair should be used with this (HidNpadIdType_No1 and HidNpadIdType_No2 for example).
* @note Only available on [5.0.0+].
* @param[in] id \ref HidNpadIdType, must be HidNpadIdType_No*.
* @param[in] type \ref HidNpadJoyDeviceType
* @param[out] flag Whether the dest output is set.
* @param[out] dest \ref HidNpadIdType
*/
hidSetNpadJoyAssignmentModeSingleWithDestination :: (id: HidNpadIdType, type: HidNpadJoyDeviceType, flag: *bool, dest: *HidNpadIdType) -> Result #foreign libnx;

/**
* @brief SetNpadAnalogStickUseCenterClamp
* @note Only available on [6.1.0+].
* @param[in] flag Flag
*/
hidSetNpadAnalogStickUseCenterClamp :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Assigns the button(s) which trigger the CaptureButton.
* @note Only available on [8.0.0+].
* @param[in] style \ref HidNpadStyleTag, exactly 1 bit must be set.
* @param[in] buttons Bitfield of \ref HidNpadButton, multiple bits can be set.
*/
hidSetNpadCaptureButtonAssignment :: (style: HidNpadStyleTag, buttons: u64) -> Result #foreign libnx;

/**
* @brief ClearNpadCaptureButtonAssignment
* @note Only available on [8.0.0+].
*/
hidClearNpadCaptureButtonAssignment :: () -> Result #foreign libnx;

/**
* @brief Gets and initializes vibration handles.
* @note Only the following styles support total_handles 2: ::HidNpadStyleTag_NpadFullKey, ::HidNpadStyleTag_NpadHandheld, ::HidNpadStyleTag_NpadJoyDual, ::HidNpadStyleTag_NpadHandheldLark, ::HidNpadStyleTag_NpadSystem, ::HidNpadStyleTag_NpadSystemExt.
* @param[out] handles Output array of \ref HidVibrationDeviceHandle.
* @param[in] total_handles Total handles for the handles array. Must be 1 or 2, if 2 handles aren't supported by the specified style an error is thrown.
* @param[in] id \ref HidNpadIdType
* @param[in] style \ref HidNpadStyleTag
*/
hidInitializeVibrationDevices :: (handles: *HidVibrationDeviceHandle, total_handles: s32, id: HidNpadIdType, style: HidNpadStyleTag) -> Result #foreign libnx;

/**
* @brief Gets \ref HidVibrationDeviceInfo for the specified device.
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[out] out \ref HidVibrationDeviceInfo
*/
hidGetVibrationDeviceInfo :: (handle: HidVibrationDeviceHandle, out: *HidVibrationDeviceInfo) -> Result #foreign libnx;

/**
* @brief Sends the \ref HidVibrationDeviceHandle to the specified device.
* @note With ::HidVibrationDeviceType_GcErm, use \ref hidSendVibrationGcErmCommand instead.
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[in] value \ref HidVibrationValue
*/
hidSendVibrationValue :: (handle: HidVibrationDeviceHandle, value: *HidVibrationValue) -> Result #foreign libnx;

/**
* @brief Gets the current \ref HidVibrationValue for the specified device.
* @note With ::HidVibrationDeviceType_GcErm, use \ref hidGetActualVibrationGcErmCommand instead.
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[out] out \ref HidVibrationValue
*/
hidGetActualVibrationValue :: (handle: HidVibrationDeviceHandle, out: *HidVibrationValue) -> Result #foreign libnx;

/**
* @brief Sets whether vibration is allowed, this also affects the config displayed by System Settings.
* @param[in] flag Flag
*/
hidPermitVibration :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Gets whether vibration is allowed.
* @param[out] flag Flag
*/
hidIsVibrationPermitted :: (flag: *bool) -> Result #foreign libnx;

/**
* @brief Send vibration values[index] to handles[index].
* @note With ::HidVibrationDeviceType_GcErm, use \ref hidSendVibrationGcErmCommand instead.
* @param[in] handles Input array of \ref HidVibrationDeviceHandle.
* @param[in] values Input array of \ref HidVibrationValue.
* @param[in] count Total entries in the handles/values arrays.
*/
hidSendVibrationValues :: (handles: *HidVibrationDeviceHandle, values: *HidVibrationValue, count: s32) -> Result #foreign libnx;

/**
* @brief Send \ref HidVibrationGcErmCommand to the specified device, for ::HidVibrationDeviceType_GcErm.
* @note Only available on [4.0.0+].
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[in] cmd \ref HidVibrationGcErmCommand
*/
hidSendVibrationGcErmCommand :: (handle: HidVibrationDeviceHandle, cmd: HidVibrationGcErmCommand) -> Result #foreign libnx;

/**
* @brief Get \ref HidVibrationGcErmCommand for the specified device, for ::HidVibrationDeviceType_GcErm.
* @note Only available on [4.0.0+].
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[out] out \ref HidVibrationGcErmCommand
*/
hidGetActualVibrationGcErmCommand :: (handle: HidVibrationDeviceHandle, out: *HidVibrationGcErmCommand) -> Result #foreign libnx;

/**
* @brief Begins a forced-permitted vibration session.
* @note Only available on [4.0.0+].
*/
hidBeginPermitVibrationSession :: () -> Result #foreign libnx;

/**
* @brief Ends the session started by \ref hidBeginPermitVibrationSession.
* @note Only available on [4.0.0+].
*/
hidEndPermitVibrationSession :: () -> Result #foreign libnx;

/**
* @brief Gets whether vibration is available with the specified device.
* @note Only available on [7.0.0+].
* @param[in] handle \ref HidVibrationDeviceHandle
* @param[out] flag Flag
*/
hidIsVibrationDeviceMounted :: (handle: HidVibrationDeviceHandle, flag: *bool) -> Result #foreign libnx;

/**
* @brief Starts the SevenSixAxisSensor.
* @note Only available on [5.0.0+].
*/
hidStartSevenSixAxisSensor :: () -> Result #foreign libnx;

/**
* @brief Stops the SevenSixAxisSensor.
* @note Only available on [5.0.0+].
*/
hidStopSevenSixAxisSensor :: () -> Result #foreign libnx;

/**
* @brief Initializes the SevenSixAxisSensor.
* @note Only available on [5.0.0+].
*/
hidInitializeSevenSixAxisSensor :: () -> Result #foreign libnx;

/**
* @brief Finalizes the SevenSixAxisSensor.
* @note This must be called before \ref hidExit.
* @note Only available on [5.0.0+].
*/
hidFinalizeSevenSixAxisSensor :: () -> Result #foreign libnx;

/**
* @brief Sets the SevenSixAxisSensor FusionStrength.
* @note Only available on [5.0.0+].
* @param[in] strength Strength
*/
hidSetSevenSixAxisSensorFusionStrength :: (strength: float) -> Result #foreign libnx;

/**
* @brief Gets the SevenSixAxisSensor FusionStrength.
* @note Only available on [5.0.0+].
* @param[out] strength Strength
*/
hidGetSevenSixAxisSensorFusionStrength :: (strength: *float) -> Result #foreign libnx;

/**
* @brief Resets the timestamp for the SevenSixAxisSensor.
* @note Only available on [6.0.0+].
*/
hidResetSevenSixAxisSensorTimestamp :: () -> Result #foreign libnx;

/**
* @brief GetSevenSixAxisSensorStates
* @note Only available when \ref hidInitializeSevenSixAxisSensor was previously used.
* @param[out] states Output array of \ref HidSevenSixAxisSensorState.
* @param[in] count Size of the states array in entries.
* @param[out] total_out Total output entries.
*/
hidGetSevenSixAxisSensorStates :: (states: *HidSevenSixAxisSensorState, count: u64, total_out: *u64) -> Result #foreign libnx;

/**
* @brief IsSevenSixAxisSensorAtRest
* @note Only available when \ref hidInitializeSevenSixAxisSensor was previously used.
* @param[out] out Output flag.
*/
hidIsSevenSixAxisSensorAtRest :: (out: *bool) -> Result #foreign libnx;

/**
* @brief GetSensorFusionError
* @note Only available when \ref hidInitializeSevenSixAxisSensor was previously used.
* @param[out] out Output data.
*/
hidGetSensorFusionError :: (out: *float) -> Result #foreign libnx;

/**
* @brief GetGyroBias
* @note Only available when \ref hidInitializeSevenSixAxisSensor was previously used.
* @param[out] out \ref UtilFloat3
*/
hidGetGyroBias :: (out: *UtilFloat3) -> Result #foreign libnx;

/**
* @brief IsUsbFullKeyControllerEnabled
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
hidIsUsbFullKeyControllerEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EnableUsbFullKeyController
* @note Only available on [3.0.0+].
* @param[in] flag Flag
*/
hidEnableUsbFullKeyController :: (flag: bool) -> Result #foreign libnx;

/**
* @brief IsUsbFullKeyControllerConnected
* @note Only available on [3.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out Output flag.
*/
hidIsUsbFullKeyControllerConnected :: (id: HidNpadIdType, out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the \ref HidNpadInterfaceType for the specified controller.
* @note When available, \ref hidsysGetNpadInterfaceType should be used instead.
* @note Only available on [4.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out \ref HidNpadInterfaceType
*/
hidGetNpadInterfaceType :: (id: HidNpadIdType, out: *u8) -> Result #foreign libnx;

/**
* @brief GetNpadOfHighestBatteryLevel
* @note Only available on [10.0.0+].
* @param[in] ids Input array of \ref HidNpadIdType, ::HidNpadIdType_Handheld is ignored.
* @param[in] count Total entries in the ids array.
* @param[out] out \ref HidNpadIdType
*/
hidGetNpadOfHighestBatteryLevel :: (ids: *HidNpadIdType, count: u64, out: *HidNpadIdType) -> Result #foreign libnx;

/**
* @brief GetPalmaConnectionHandle
* @note Only available on [5.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out \ref HidPalmaConnectionHandle
*/
hidGetPalmaConnectionHandle :: (id: HidNpadIdType, out: *HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief InitializePalma
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidInitializePalma :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when data is available with \ref hidGetPalmaOperationInfo.
* @note The Event must be closed by the user once finished with it.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[out] out_event Output Event.
* @param[in] autoclear The autoclear for the Event.
**/
hidAcquirePalmaOperationCompleteEvent :: (handle: HidPalmaConnectionHandle, out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief Gets \ref HidPalmaOperationInfo for a completed operation.
* @note This must be used at some point following using any of the other Palma cmds which trigger an Operation, once the Event from \ref hidAcquirePalmaOperationCompleteEvent is signaled. Up to 4 Operations can be queued at once, the other cmds will throw an error once there's too many operations.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[out] out \ref HidPalmaOperationInfo
*/
hidGetPalmaOperationInfo :: (handle: HidPalmaConnectionHandle, out: *HidPalmaOperationInfo) -> Result #foreign libnx;

/**
* @brief PlayPalmaActivity
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] val Input value.
*/
hidPlayPalmaActivity :: (handle: HidPalmaConnectionHandle, val: u16) -> Result #foreign libnx;

/**
* @brief SetPalmaFrModeType
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] type \ref HidPalmaFrModeType
*/
hidSetPalmaFrModeType :: (handle: HidPalmaConnectionHandle, type: HidPalmaFrModeType) -> Result #foreign libnx;

/**
* @brief ReadPalmaStep
* @note See \ref hidGetPalmaOperationInfo.
* @note \ref hidEnablePalmaStep should be used before this.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidReadPalmaStep :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief EnablePalmaStep
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] flag Flag
*/
hidEnablePalmaStep :: (handle: HidPalmaConnectionHandle, flag: bool) -> Result #foreign libnx;

/**
* @brief ResetPalmaStep
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidResetPalmaStep :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief ReadPalmaApplicationSection
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] inval0 First input value.
* @param[in] size This must be within the size of \ref HidPalmaApplicationSectionAccessBuffer.
*/
hidReadPalmaApplicationSection :: (handle: HidPalmaConnectionHandle, inval0: s32, size: u64) -> Result #foreign libnx;

/**
* @brief WritePalmaApplicationSection
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] inval0 First input value.
* @param[in] size Size of the data in \ref HidPalmaApplicationSectionAccessBuffer.
* @param[in] buf \ref HidPalmaApplicationSectionAccessBuffer
*/
hidWritePalmaApplicationSection :: (handle: HidPalmaConnectionHandle, inval0: s32, size: u64, buf: *HidPalmaApplicationSectionAccessBuffer) -> Result #foreign libnx;

/**
* @brief ReadPalmaUniqueCode
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidReadPalmaUniqueCode :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief SetPalmaUniqueCodeInvalid
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidSetPalmaUniqueCodeInvalid :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief WritePalmaActivityEntry
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] unk Unknown
* @param[in] entry \ref HidPalmaActivityEntry
*/
hidWritePalmaActivityEntry :: (handle: HidPalmaConnectionHandle, unk: u16, entry: *HidPalmaActivityEntry) -> Result #foreign libnx;

/**
* @brief WritePalmaRgbLedPatternEntry
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] unk Unknown
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
*/
hidWritePalmaRgbLedPatternEntry :: (handle: HidPalmaConnectionHandle, unk: u16, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief WritePalmaWaveEntry
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] wave_set \ref HidPalmaWaveSet
* @param[in] unk Unknown
* @param[in] buffer TransferMemory buffer, must be 0x1000-byte aligned.
* @param[in] tmem_size TransferMemory buffer size, must be 0x1000-byte aligned.
* @param[in] size Actual size of the data in the buffer.
*/
hidWritePalmaWaveEntry :: (handle: HidPalmaConnectionHandle, wave_set: HidPalmaWaveSet, unk: u16, buffer: *void, tmem_size: u64, size: u64) -> Result #foreign libnx;

/**
* @brief SetPalmaDataBaseIdentificationVersion
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] version Version
*/
hidSetPalmaDataBaseIdentificationVersion :: (handle: HidPalmaConnectionHandle, version: s32) -> Result #foreign libnx;

/**
* @brief GetPalmaDataBaseIdentificationVersion
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidGetPalmaDataBaseIdentificationVersion :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief SuspendPalmaFeature
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] features Bitfield of \ref HidPalmaFeature.
*/
hidSuspendPalmaFeature :: (handle: HidPalmaConnectionHandle, features: u32) -> Result #foreign libnx;

/**
* @brief ReadPalmaPlayLog
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.1.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] unk Unknown
*/
hidReadPalmaPlayLog :: (handle: HidPalmaConnectionHandle, unk: u16) -> Result #foreign libnx;

/**
* @brief ResetPalmaPlayLog
* @note See \ref hidGetPalmaOperationInfo.
* @note Only available on [5.1.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[in] unk Unknown
*/
hidResetPalmaPlayLog :: (handle: HidPalmaConnectionHandle, unk: u16) -> Result #foreign libnx;

/**
* @brief Sets whether any Palma can connect.
* @note Only available on [5.1.0+].
* @param[in] flag Flag
*/
hidSetIsPalmaAllConnectable :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether paired Palma can connect.
* @note Only available on [5.1.0+].
* @param[in] flag Flag
*/
hidSetIsPalmaPairedConnectable :: (flag: bool) -> Result #foreign libnx;

/**
* @brief PairPalma
* @note Only available on [5.1.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidPairPalma :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief CancelWritePalmaWaveEntry
* @note Only available on [7.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
*/
hidCancelWritePalmaWaveEntry :: (handle: HidPalmaConnectionHandle) -> Result #foreign libnx;

/**
* @brief EnablePalmaBoostMode
* @note Only available on [5.1.0+]. Uses cmd EnablePalmaBoostMode on [8.0.0+], otherwise cmd SetPalmaBoostMode is used.
* @param[in] flag Flag
*/
hidEnablePalmaBoostMode :: (flag: bool) -> Result #foreign libnx;

/**
* @brief GetPalmaBluetoothAddress
* @note Only available on [8.0.0+].
* @param[in] handle \ref HidPalmaConnectionHandle
* @param[out] out \ref BtdrvAddress
*/
hidGetPalmaBluetoothAddress :: (handle: HidPalmaConnectionHandle, out: *BtdrvAddress) -> Result #foreign libnx;

/**
* @brief SetDisallowedPalmaConnection
* @note Only available on [8.0.0+].
* @param[in] addrs Input array of \ref BtdrvAddress.
* @param[in] count Total entries in the addrs array.
*/
hidSetDisallowedPalmaConnection :: (addrs: *BtdrvAddress, count: s32) -> Result #foreign libnx;

/**
* @brief SetNpadCommunicationMode
* @note [2.0.0+] Stubbed, just returns 0.
* @param[in] mode \ref HidNpadCommunicationMode
*/
hidSetNpadCommunicationMode :: (mode: HidNpadCommunicationMode) -> Result #foreign libnx;

/**
* @brief GetNpadCommunicationMode
* @note [2.0.0+] Stubbed, always returns output mode ::HidNpadCommunicationMode_Default.
* @param[out] out \ref HidNpadCommunicationMode
*/
hidGetNpadCommunicationMode :: (out: *HidNpadCommunicationMode) -> Result #foreign libnx;

/**
* @brief SetTouchScreenConfiguration
* @note Only available on [9.0.0+].
* @param[in] config \ref HidTouchScreenConfigurationForNx
*/
hidSetTouchScreenConfiguration :: (config: *HidTouchScreenConfigurationForNx) -> Result #foreign libnx;

/**
* @brief IsFirmwareUpdateNeededForNotification
* @note Only available on [9.0.0+].
* @param[out] out Output flag.
*/
hidIsFirmwareUpdateNeededForNotification :: (out: *bool) -> Result #foreign libnx;

/// BusType
HidbusBusType :: enum u32 {
    LeftJoyRail   :: 0;
    RightJoyRail  :: 1;
    RightLarkRail :: 2;
}

/// JoyPollingMode
HidbusJoyPollingMode :: enum u32 {
    SixAxisSensorDisable :: 0;
    SixAxisSensorEnable  :: 1;
    ButtonOnly           :: 2;
}

/// BusHandle
HidbusBusHandle :: struct {
    abstracted_pad_id: u32; ///< AbstractedPadId
    internal_index:    u8; ///< InternalIndex
    player_number:     u8; ///< PlayerNumber
    bus_type_id:       u8; ///< BusTypeId
    is_valid:          u8; ///< IsValid
}

/// JoyPollingReceivedData
HidbusJoyPollingReceivedData :: struct {
    data:            [48] u8; ///< Data.
    out_size:        u64; ///< Size of data.
    sampling_number: u64; ///< SamplingNumber
}

/// HidbusDataAccessorHeader
HidbusDataAccessorHeader :: struct {
    res:           Result; ///< Result.
    pad:           u32; ///< Padding.
    unused:        [24] u8; ///< Initialized sysmodule-side, not used by sdknso.
    latest_entry:  u64; ///< Latest entry.
    total_entries: u64; ///< Total entries.
}

/// HidbusJoyDisableSixAxisPollingDataAccessorEntryData
HidbusJoyDisableSixAxisPollingDataAccessorEntryData :: struct {
    data:            [38] u8; ///< Data.
    out_size:        u8; ///< Size of data.
    pad:             u8; ///< Padding.
    sampling_number: u64; ///< SamplingNumber
}

/// HidbusJoyDisableSixAxisPollingDataAccessorEntry
HidbusJoyDisableSixAxisPollingDataAccessorEntry :: struct {
    sampling_number: u64; ///< SamplingNumber
    data:            HidbusJoyDisableSixAxisPollingDataAccessorEntryData; ///< \ref HidbusJoyDisableSixAxisPollingDataAccessorEntryData
}

/// HidbusJoyEnableSixAxisPollingDataAccessorEntryData
HidbusJoyEnableSixAxisPollingDataAccessorEntryData :: struct {
    data:            [8] u8; ///< Data.
    out_size:        u8; ///< Size of data.
    pad:             [7] u8; ///< Padding.
    sampling_number: u64; ///< SamplingNumber
}

/// HidbusJoyEnableSixAxisPollingDataAccessorEntry
HidbusJoyEnableSixAxisPollingDataAccessorEntry :: struct {
    sampling_number: u64; ///< SamplingNumber
    data:            HidbusJoyEnableSixAxisPollingDataAccessorEntryData; ///< \ref HidbusJoyEnableSixAxisPollingDataAccessorEntryData
}

/// HidbusJoyButtonOnlyPollingDataAccessorEntryData
HidbusJoyButtonOnlyPollingDataAccessorEntryData :: struct {
    data:            [44] u8; ///< Data.
    out_size:        u8; ///< Size of data.
    pad:             [3] u8; ///< Padding.
    sampling_number: u64; ///< SamplingNumber
}

/// HidbusJoyButtonOnlyPollingDataAccessorEntry
HidbusJoyButtonOnlyPollingDataAccessorEntry :: struct {
    sampling_number: u64; ///< SamplingNumber
    data:            HidbusJoyButtonOnlyPollingDataAccessorEntryData; ///< \ref HidbusJoyEnableSixAxisPollingDataAccessorEntryData
}

/// HidbusJoyDisableSixAxisPollingDataAccessor
HidbusJoyDisableSixAxisPollingDataAccessor :: struct {
    hdr:     HidbusDataAccessorHeader; ///< \ref HidbusDataAccessorHeader
    entries: [11] HidbusJoyDisableSixAxisPollingDataAccessorEntry; ///< \ref HidbusJoyDisableSixAxisPollingDataAccessorEntry
}

/// HidbusJoyEnableSixAxisPollingDataAccessor
HidbusJoyEnableSixAxisPollingDataAccessor :: struct {
    hdr:     HidbusDataAccessorHeader; ///< \ref HidbusDataAccessorHeader
    entries: [11] HidbusJoyEnableSixAxisPollingDataAccessorEntry; ///< \ref HidbusJoyEnableSixAxisPollingDataAccessorEntry
}

/// HidbusJoyButtonOnlyPollingDataAccessor
HidbusJoyButtonOnlyPollingDataAccessor :: struct {
    hdr:     HidbusDataAccessorHeader; ///< \ref HidbusDataAccessorHeader
    entries: [11] HidbusJoyButtonOnlyPollingDataAccessorEntry; ///< \ref HidbusJoyButtonOnlyPollingDataAccessorEntry
}

/// Common data for HidbusStatusManagerEntry*.
HidbusStatusManagerEntryCommon :: struct {
    is_connected:        u8; ///< IsConnected
    pad:                 [3] u8; ///< Padding.
    is_connected_result: Result; ///< IsConnectedResult
    is_enabled:          u8; ///< Flag indicating whether a device is enabled (\ref hidbusEnableExternalDevice).
    is_in_focus:         u8; ///< Flag indicating whether this entry is valid.
    is_polling_mode:     u8; ///< Flag indicating whether polling is enabled (\ref hidbusEnableJoyPollingReceiveMode).
    reserved:            u8; ///< Reserved
    polling_mode:        u32; ///< \ref HidbusJoyPollingMode
}

/// HidbusStatusManagerEntry on 5.x.
HidbusStatusManagerEntryV5 :: struct {
    common:  HidbusStatusManagerEntryCommon; ///< \ref HidbusStatusManagerEntryCommon
    unk_x10: [240] u8; ///< Ignored by official sw.
}

/// HidbusStatusManagerEntry
HidbusStatusManagerEntry :: struct {
    common:  HidbusStatusManagerEntryCommon; ///< \ref HidbusStatusManagerEntryCommon
    unk_x10: [112] u8; ///< Ignored by official sw.
}

/// StatusManager on 5.x.
HidbusStatusManagerV5 :: struct {
    entries: [16] HidbusStatusManagerEntryV5; ///< \ref HidbusStatusManagerEntryV5
}

/// StatusManager
HidbusStatusManager :: struct {
    entries: [19] HidbusStatusManagerEntry; ///< \ref HidbusStatusManagerEntry
    unused:  [1664] u8; ///< Unused.
}

/// Gets the Service object for the actual hidbus service session. This object must be closed by the user once finished using cmds with this.
hidbusGetServiceSession :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the SharedMemory addr (\ref HidbusStatusManagerV5 on 5.x, otherwise \ref HidbusStatusManager). Only valid when at least one BusHandle is currently initialized (\ref hidbusInitialize).
hidbusGetSharedmemAddr :: () -> *void #foreign libnx;

/**
* @brief GetBusHandle
* @param[out] handle \ref HidbusBusHandle
* @param[out] flag Output flag indicating whether the handle is valid.
* @param[in] id \ref HidNpadIdType
* @param[in] bus_type \ref HidbusBusType
*/
hidbusGetBusHandle :: (handle: *HidbusBusHandle, flag: *bool, id: HidNpadIdType, bus_type: HidbusBusType) -> Result #foreign libnx;

/**
* @brief Initialize
* @param[in] handle \ref HidbusBusHandle
*/
hidbusInitialize :: (handle: HidbusBusHandle) -> Result #foreign libnx;

/**
* @brief Finalize
* @param[in] handle \ref HidbusBusHandle
*/
hidbusFinalize :: (handle: HidbusBusHandle) -> Result #foreign libnx;

/**
* @brief EnableExternalDevice
* @note This uses \ref hidLaShowControllerFirmwareUpdate if needed.
* @param[in] handle \ref HidbusBusHandle
* @param[in] flag Whether to enable the device (true = enable, false = disable). When false, this will internally use \ref hidbusDisableJoyPollingReceiveMode if needed.
* @param[in] device_id ExternalDeviceId which must match the connected device. Only used when flag is set.
*/
hidbusEnableExternalDevice :: (handle: HidbusBusHandle, flag: bool, device_id: u32) -> Result #foreign libnx;

/**
* @brief SendAndReceive
* @param[in] handle \ref HidbusBusHandle
* @param[in] inbuf Input buffer, containing the command data.
* @param[in] inbuf_size Input buffer size, must be <0x26.
* @param[out] outbuf Output buffer, containing the command reply data.
* @param[in] outbuf_size Output buffer max size.
* @param[out] out_size Actual output size.
*/
hidbusSendAndReceive :: (handle: HidbusBusHandle, inbuf: *void, inbuf_size: u64, outbuf: *void, outbuf_size: u64, out_size: *u64) -> Result #foreign libnx;

/**
* @brief EnableJoyPollingReceiveMode
* @param[in] handle \ref HidbusBusHandle
* @param[in] inbuf Input buffer, containing the command data.
* @param[in] inbuf_size Input buffer size, must be <0x26.
* @param[out] workbuf TransferMemory buffer, must be 0x1000-byte aligned. This buffer must not be written to until after \ref hidbusDisableJoyPollingReceiveMode is used.
* @param[in] workbuf_size TransferMemory buffer size, must be 0x1000-byte aligned.
* @param[in] polling_mode \ref HidbusJoyPollingMode
*/
hidbusEnableJoyPollingReceiveMode :: (handle: HidbusBusHandle, inbuf: *void, inbuf_size: u64, workbuf: *void, workbuf_size: u64, polling_mode: HidbusJoyPollingMode) -> Result #foreign libnx;

/**
* @brief DisableJoyPollingReceiveMode
* @note This can also be used via \ref hidbusEnableExternalDevice with flag=false.
* @param[in] handle \ref HidbusBusHandle
*/
hidbusDisableJoyPollingReceiveMode :: (handle: HidbusBusHandle) -> Result #foreign libnx;

/**
* @brief GetJoyPollingReceivedData
* @param[in] handle \ref HidbusBusHandle
* @param[out] recv_data Output array of \ref HidbusJoyPollingReceivedData.
* @param[in] count Total entries for the recv_data array. The maximum is 0xa. Official apps use range 0x1-0x9.
*/
hidbusGetJoyPollingReceivedData :: (handle: HidbusBusHandle, recv_data: *HidbusJoyPollingReceivedData, count: s32) -> Result #foreign libnx;

/// Selects what button to map to.
HidcfgDigitalButtonAssignment :: enum u32 {
    A             :: 0;
    B             :: 1;
    X             :: 2;
    Y             :: 3;
    StickL        :: 4;
    StickR        :: 5;
    L             :: 6;
    R             :: 7;
    ZL            :: 8;
    ZR            :: 9;
    Select        :: 10;
    Start         :: 11;
    Left          :: 12;
    Up            :: 13;
    Right         :: 14;
    Down          :: 15;
    LeftSL        :: 16;
    LeftSR        :: 17;
    RightSL       :: 18;
    RightSR       :: 19;
    HomeButton    :: 20;
    CaptureButton :: 21;
    Invalid       :: 22;
}

/// AnalogStickRotation
HidcfgAnalogStickRotation :: enum u32 {
    None            :: 0;
    Clockwise90     :: 1;
    Anticlockwise90 :: 2;
}

/// UniquePadType
HidsysUniquePadType :: enum u32 {
    Embedded           :: 0;
    FullKeyController  :: 1;
    RightController    :: 2;
    LeftController     :: 3;
    DebugPadController :: 4;
}

/// UniquePadId for a controller.
HidsysUniquePadId :: struct {
    id: u64; ///< UniquePadId
}

/// UniquePadSerialNumber
HidsysUniquePadSerialNumber :: struct {
    serial_number: [16] u8; ///< SerialNumber
}

/// Mini Cycle struct for \ref HidsysNotificationLedPattern.
HidsysNotificationLedPatternCycle :: struct {
    ledIntensity:      u8; ///< Mini Cycle X LED Intensity.
    transitionSteps:   u8; ///< Fading Transition Steps to Mini Cycle X (Uses PWM). Value 0x0: Instant. Each step duration is based on HidsysNotificationLedPattern::baseMiniCycleDuration.
    finalStepDuration: u8; ///< Final Step Duration Multiplier of Mini Cycle X. Value 0x0: 12.5ms, 0x1 - xF: 1x - 15x. Value is a Multiplier of HidsysNotificationLedPattern::baseMiniCycleDuration.
    pad:               u8;
}

/// Structure for \ref hidsysSetNotificationLedPattern.
/// See also: https://switchbrew.org/wiki/HID_services#NotificationLedPattern
/// Only the low 4bits of each used byte in this struct is used.
HidsysNotificationLedPattern :: struct {
    baseMiniCycleDuration: u8; ///< Mini Cycle Base Duration. Value 0x1-0xF: 12.5ms - 187.5ms. Value 0x0 = 0ms/OFF.
    totalMiniCycles:       u8; ///< Number of Mini Cycles + 1. Value 0x0-0xF: 1 - 16 mini cycles.
    totalFullCycles:       u8; ///< Number of Full Cycles. Value 0x1-0xF: 1 - 15 full cycles. Value 0x0 is repeat forever, but if baseMiniCycleDuration is set to 0x0, it does the 1st Mini Cycle with a 12.5ms step duration and then the LED stays on with startIntensity.
    startIntensity:        u8; ///< LED Start Intensity. Value 0x0=0% - 0xF=100%.

    miniCycles:            [16] HidsysNotificationLedPatternCycle; ///< Mini Cycles

    unk_x44:               [2] u8; ///< Unknown
    pad_x46:               [2] u8; ///< Padding
}

/// ButtonConfigEmbedded
HidsysButtonConfigEmbedded :: struct {
    unk_x0: [712] u8;
}

/// ButtonConfigFull
HidsysButtonConfigFull :: struct {
    unk_x0: [712] u8;
}

/// ButtonConfigLeft
HidsysButtonConfigLeft :: struct {
    unk_x0: [456] u8;
}

/// ButtonConfigRight
HidsysButtonConfigRight :: struct {
    unk_x0: [416] u8;
}

/// AnalogStickAssignment
HidcfgAnalogStickAssignment :: struct {
    rotation:                 u32; ///< \ref HidcfgAnalogStickRotation
    is_paired_stick_assigned: u8; ///< IsPairedStickAssigned
    reserved:                 [3] u8; ///< Reserved
}

/// ButtonConfigEmbedded
HidcfgButtonConfigEmbedded :: struct {
    hardware_button_left:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonLeft
    hardware_button_up:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonUp
    hardware_button_right:   u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonRight
    hardware_button_down:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonDown
    hardware_button_a:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonA
    hardware_button_b:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonB
    hardware_button_x:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonX
    hardware_button_y:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonY
    hardware_button_stick_l: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickL
    hardware_button_stick_r: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickR
    hardware_button_l:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonL
    hardware_button_r:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonR
    hardware_button_zl:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZL
    hardware_button_zr:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZR
    hardware_button_select:  u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonSelect
    hardware_button_start:   u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStart
    hardware_button_capture: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonCapture
    hardware_stick_l:        HidcfgAnalogStickAssignment; ///< HardwareStickL
    hardware_stick_r:        HidcfgAnalogStickAssignment; ///< HardwareStickR
}

/// ButtonConfigFull
HidcfgButtonConfigFull :: struct {
    hardware_button_left:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonLeft
    hardware_button_up:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonUp
    hardware_button_right:   u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonRight
    hardware_button_down:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonDown
    hardware_button_a:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonA
    hardware_button_b:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonB
    hardware_button_x:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonX
    hardware_button_y:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonY
    hardware_button_stick_l: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickL
    hardware_button_stick_r: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickR
    hardware_button_l:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonL
    hardware_button_r:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonR
    hardware_button_zl:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZL
    hardware_button_zr:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZR
    hardware_button_select:  u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonSelect
    hardware_button_start:   u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStart
    hardware_button_capture: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonCapture
    hardware_stick_l:        HidcfgAnalogStickAssignment; ///< HardwareStickL
    hardware_stick_r:        HidcfgAnalogStickAssignment; ///< HardwareStickR
}

/// ButtonConfigLeft
HidcfgButtonConfigLeft :: struct {
    hardware_button_left:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonLeft
    hardware_button_up:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonUp
    hardware_button_right:   u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonRight
    hardware_button_down:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonDown
    hardware_button_stick_l: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickL
    hardware_button_l:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonL
    hardware_button_zl:      u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZL
    hardware_button_select:  u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonSelect
    hardware_button_left_sl: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonLeftSL
    hardware_button_left_sr: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonLeftSR
    hardware_button_capture: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonCapture
    hardware_stick_l:        HidcfgAnalogStickAssignment; ///< HardwareStickL
}

/// ButtonConfigRight
HidcfgButtonConfigRight :: struct {
    hardware_button_a:        u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonA
    hardware_button_b:        u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonB
    hardware_button_x:        u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonX
    hardware_button_y:        u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonY
    hardware_button_stick_r:  u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStickR
    hardware_button_r:        u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonR
    hardware_button_zr:       u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonZR
    hardware_button_start:    u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonStart
    hardware_button_right_sl: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonRightSL
    hardware_button_right_sr: u32; ///< \ref HidcfgDigitalButtonAssignment HardwareButtonRightSR
    hardware_stick_r:         HidcfgAnalogStickAssignment; ///< HardwareStickR
}

/// StorageName
HidcfgStorageName :: struct {
    name: [129] u8; ///< UTF-8 NUL-terminated name string.
}

/// Initialize hidsys.
hidsysInitialize :: () -> Result #foreign libnx;

/// Exit hidsys.
hidsysExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual hidsys service session.
hidsysGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief SendKeyboardLockKeyEvent
* @param[in] events Bitfield of \ref HidKeyboardLockKeyEvent.
*/
hidsysSendKeyboardLockKeyEvent :: (events: u32) -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when HidHomeButtonState is updated.
* @note The Event must be closed by the user once finished with it.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
* @param[out] out_event Output Event.
* @param[in] Event autoclear.
**/
hidsysAcquireHomeButtonEventHandle :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief Activates the HomeButton sharedmem.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
**/
hidsysActivateHomeButton :: () -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when HidSleepButtonState is updated.
* @note The Event must be closed by the user once finished with it.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
* @param[out] out_event Output Event.
* @param[in] Event autoclear.
**/
hidsysAcquireSleepButtonEventHandle :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief Activates the SleepButton sharedmem.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
**/
hidsysActivateSleepButton :: () -> Result #foreign libnx;

/**
* @brief Gets an Event which is signaled when HidCaptureButtonState is updated.
* @note The Event must be closed by the user once finished with it.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
* @param[out] out_event Output Event.
* @param[in] Event autoclear.
**/
hidsysAcquireCaptureButtonEventHandle :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief Activates the CaptureButton sharedmem.
* @note This generally shouldn't be used, since AM-sysmodule uses it internally.
**/
hidsysActivateCaptureButton :: () -> Result #foreign libnx;

/**
* @brief Applies npad system common policy.
*/
hidsysApplyNpadSystemCommonPolicy :: () -> Result #foreign libnx;

/**
* @brief Gets the npad id type of the last controller that was active.
* @param[out] out of \ref HidNpadIdType.
*/
hidsysGetLastActiveNpad :: (out: *u32) -> Result #foreign libnx;

/**
* @brief Gets the SupportedNpadStyleSet for the CallerApplet. applet must be initialized in order to use this (uses \ref appletGetAppletResourceUserIdOfCallerApplet).
* @note Only available on [6.0.0+].
* @param[out] out Bitmask of \ref HidNpadStyleTag.
*/
hidsysGetSupportedNpadStyleSetOfCallerApplet :: (out: *u32) -> Result #foreign libnx;

/**
* @brief Gets the \ref HidNpadInterfaceType for the specified controller.
* @note Only available on [10.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out \ref HidNpadInterfaceType
*/
hidsysGetNpadInterfaceType :: (id: HidNpadIdType, out: *u8) -> Result #foreign libnx;

/**
* @brief GetNpadLeftRightInterfaceType
* @note Only available on [10.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out0 \ref HidNpadInterfaceType
* @param[out] out1 \ref HidNpadInterfaceType
*/
hidsysGetNpadLeftRightInterfaceType :: (id: HidNpadIdType, out0: *u8, out1: *u8) -> Result #foreign libnx;

/**
* @brief HasBattery
* @note Only available on [10.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out Output flag.
*/
hidsysHasBattery :: (id: HidNpadIdType, out: *bool) -> Result #foreign libnx;

/**
* @brief HasLeftRightBattery
* @note Only available on [10.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] out0 Output flag.
* @param[out] out1 Output flag.
*/
hidsysHasLeftRightBattery :: (id: HidNpadIdType, out0: *bool, out1: *bool) -> Result #foreign libnx;

/**
* @brief Gets the UniquePadIds for the specified controller.
* @note Only available on [3.0.0+].
* @param[in] id \ref HidNpadIdType
* @param[out] unique_pad_ids Output array of \ref HidsysUniquePadId.
* @param[in] count Max number of entries for the unique_pad_ids array.
* @param[out] total_out Total output array entries. Optional, can be NULL.
*/
hidsysGetUniquePadsFromNpad :: (id: HidNpadIdType, unique_pad_ids: *HidsysUniquePadId, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief EnableAppletToGetInput
* @param[in] enable Input flag.
**/
hidsysEnableAppletToGetInput :: (enable: bool) -> Result #foreign libnx;

/**
* @brief AcquireUniquePadConnectionEventHandle
* @param[out] out_event Output Event.
*/
hidsysAcquireUniquePadConnectionEventHandle :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Gets a list of all UniquePadIds.
* @param[out] unique_pad_ids Output array of \ref HidsysUniquePadId.
* @param[in] count Max number of entries for the unique_pad_ids array.
* @param[out] total_out Total output array entries. Optional, can be NULL.
*/
hidsysGetUniquePadIds :: (unique_pad_ids: *HidsysUniquePadId, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief AcquireJoyDetachOnBluetoothOffEventHandle
* @param[out] out_event Output Event.
* @param[in] Event autoclear.
*/
hidsysAcquireJoyDetachOnBluetoothOffEventHandle :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief GetUniquePadBluetoothAddress
* @note Only available on [3.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] address \ref BtdrvAddress
*/
hidsysGetUniquePadBluetoothAddress :: (unique_pad_id: HidsysUniquePadId, address: *BtdrvAddress) -> Result #foreign libnx;

/**
* @brief DisconnectUniquePad
* @note Only available on [3.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
*/
hidsysDisconnectUniquePad :: (unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief GetUniquePadType
* @note Only available on [5.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] pad_type \ref HidsysUniquePadType
*/
hidsysGetUniquePadType :: (unique_pad_id: HidsysUniquePadId, pad_type: *HidsysUniquePadType) -> Result #foreign libnx;

/**
* @brief GetUniquePadInterface
* @note Only available on [5.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] interface \ref HidNpadInterfaceType
*/
hidsysGetUniquePadInterface :: (unique_pad_id: HidsysUniquePadId, _interface: *HidNpadInterfaceType) -> Result #foreign libnx;

/**
* @brief Gets the \ref HidsysUniquePadSerialNumber.
* @note Only available on [5.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] serial \ref HidsysUniquePadSerialNumber
*/
hidsysGetUniquePadSerialNumber :: (unique_pad_id: HidsysUniquePadId, serial: *HidsysUniquePadSerialNumber) -> Result #foreign libnx;

/**
* @brief GetUniquePadControllerNumber
* @note Only available on [5.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] number Controller number.
*/
hidsysGetUniquePadControllerNumber :: (unique_pad_id: HidsysUniquePadId, number: *u64) -> Result #foreign libnx;

/**
* @brief Sets the HOME-button notification LED pattern, for the specified controller.
* @note Generally this should only be used if \ref hidsysSetNotificationLedPatternWithTimeout is not usable.
* @note Only available on [7.0.0+].
* @param[in] pattern \ref HidsysNotificationLedPattern
* @param[in] unique_pad_id \ref HidsysUniquePadId
*/
hidsysSetNotificationLedPattern :: (pattern: *HidsysNotificationLedPattern, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Sets the HOME-button notification LED pattern, for the specified controller. The LED will automatically be disabled once the specified timeout occurs.
* @note Only available on [9.0.0+], and with controllers which have the [9.0.0+] firmware installed.
* @param[in] pattern \ref HidsysNotificationLedPattern
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] timeout Timeout in nanoseconds.
*/
hidsysSetNotificationLedPatternWithTimeout :: (pattern: *HidsysNotificationLedPattern, unique_pad_id: HidsysUniquePadId, timeout: u64) -> Result #foreign libnx;

/**
* @brief IsUsbFullKeyControllerEnabled
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
hidsysIsUsbFullKeyControllerEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EnableUsbFullKeyController
* @note Only available on [3.0.0+].
* @param[in] flag Flag
*/
hidsysEnableUsbFullKeyController :: (flag: bool) -> Result #foreign libnx;

/**
* @brief IsUsbConnected
* @note Only available on [3.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output flag.
*/
hidsysIsUsbConnected :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief GetTouchScreenDefaultConfiguration
* @note Only available on [9.0.0+].
* @param[out] touch_screen_configuration \ref HidTouchScreenConfigurationForNx.
*/
hidsysGetTouchScreenDefaultConfiguration :: (touch_screen_configuration: *HidTouchScreenConfigurationForNx) -> Result #foreign libnx;

/**
* @brief IsFirmwareUpdateNeededForNotification
* @note Only available on [9.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output flag.
*/
hidsysIsFirmwareUpdateNeededForNotification :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief Legacy IsButtonConfigSupported.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysIsButtonConfigSupported instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output bool flag.
*/
hidsysLegacyIsButtonConfigSupported :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigSupported
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyIsButtonConfigSupported instead.
* @param[in] addr \ref BtdrvAddress
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigSupported :: (addr: BtdrvAddress, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigEmbeddedSupported
* @note Only available on [11.0.0+].
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigEmbeddedSupported :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Legacy DeleteButtonConfig.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysDeleteButtonConfig instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
*/
hidsysLegacyDeleteButtonConfig :: (unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfig
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyDeleteButtonConfig instead.
* @param[in] addr \ref BtdrvAddress
*/
hidsysDeleteButtonConfig :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfigEmbedded
* @note Only available on [11.0.0+].
*/
hidsysDeleteButtonConfigEmbedded :: () -> Result #foreign libnx;

/**
* @brief Legacy SetButtonConfigEnabled.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysSetButtonConfigEnabled instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] flag Input flag.
*/
hidsysLegacySetButtonConfigEnabled :: (unique_pad_id: HidsysUniquePadId, flag: bool) -> Result #foreign libnx;

/**
* @brief SetButtonConfigEnabled
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacySetButtonConfigEnabled instead.
* @param[in] addr \ref BtdrvAddress
* @param[in] flag Input flag.
*/
hidsysSetButtonConfigEnabled :: (addr: BtdrvAddress, flag: bool) -> Result #foreign libnx;

/**
* @brief SetButtonConfigEmbeddedEnabled
* @note Only available on [11.0.0+].
* @param[in] flag Input flag.
*/
hidsysSetButtonConfigEmbeddedEnabled :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Legacy IsButtonConfigEnabled.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysIsButtonConfigEnabled instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output bool flag.
*/
hidsysLegacyIsButtonConfigEnabled :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigEnabled
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyIsButtonConfigEnabled instead.
* @param[in] addr \ref BtdrvAddress
* @param[in] out Output bool flag.
*/
hidsysIsButtonConfigEnabled :: (addr: BtdrvAddress, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigEmbeddedEnabled
* @note Only available on [11.0.0+].
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigEmbeddedEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Legacy SetButtonConfigEmbedded.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysSetButtonConfigEmbedded instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidsysButtonConfigEmbedded
*/
hidsysLegacySetButtonConfigEmbedded :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief SetButtonConfigEmbedded
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacySetButtonConfigEmbedded instead.
* @param[in] config \ref HidsysButtonConfigEmbedded
*/
hidsysSetButtonConfigEmbedded :: (config: *HidsysButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief Legacy SetButtonConfigFull.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysSetButtonConfigFull instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidsysButtonConfigFull
*/
hidsysLegacySetButtonConfigFull :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigFull) -> Result #foreign libnx;

/**
* @brief SetButtonConfigFull
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacySetButtonConfigFull instead.
* @param[in] addr \ref BtdrvAddress
* @param[in] config \ref HidsysButtonConfigFull
*/
hidsysSetButtonConfigFull :: (addr: BtdrvAddress, config: *HidsysButtonConfigFull) -> Result #foreign libnx;

/**
* @brief Legacy SetButtonConfigLeft.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysSetButtonConfigLeft instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidsysButtonConfigLeft
*/
hidsysLegacySetButtonConfigLeft :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief SetButtonConfigLeft
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacySetButtonConfigLeft instead.
* @param[in] addr \ref BtdrvAddress
* @param[in] config \ref HidsysButtonConfigLeft
*/
hidsysSetButtonConfigLeft :: (addr: BtdrvAddress, config: *HidsysButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief Legacy SetButtonConfigRight.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysSetButtonConfigRight instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidsysButtonConfigRight
*/
hidsysLegacySetButtonConfigRight :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigRight) -> Result #foreign libnx;

/**
* @brief SetButtonConfigRight
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacySetButtonConfigRight instead.
* @param[in] addr \ref BtdrvAddress
* @param[in] config \ref HidsysButtonConfigRight
*/
hidsysSetButtonConfigRight :: (addr: BtdrvAddress, config: *HidsysButtonConfigRight) -> Result #foreign libnx;

/**
* @brief Legacy GetButtonConfigEmbedded.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysGetButtonConfigEmbedded instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidsysButtonConfigEmbedded
*/
hidsysLegacyGetButtonConfigEmbedded :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief GetButtonConfigEmbedded
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyGetButtonConfigEmbedded instead.
* @param[out] config \ref HidsysButtonConfigEmbedded
*/
hidsysGetButtonConfigEmbedded :: (config: *HidsysButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief Legacy GetButtonConfigFull.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysGetButtonConfigFull instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidsysButtonConfigFull
*/
hidsysLegacyGetButtonConfigFull :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigFull) -> Result #foreign libnx;

/**
* @brief GetButtonConfigFull
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyGetButtonConfigFull instead.
* @param[in] addr \ref BtdrvAddress
* @param[out] config \ref HidsysButtonConfigFull
*/
hidsysGetButtonConfigFull :: (addr: BtdrvAddress, config: *HidsysButtonConfigFull) -> Result #foreign libnx;

/**
* @brief Legacy GetButtonConfigLeft.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysGetButtonConfigLeft instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidsysButtonConfigLeft
*/
hidsysLegacyGetButtonConfigLeft :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief GetButtonConfigLeft
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyGetButtonConfigLeft instead.
* @param[in] addr \ref BtdrvAddress
* @param[out] config \ref HidsysButtonConfigLeft
*/
hidsysGetButtonConfigLeft :: (addr: BtdrvAddress, config: *HidsysButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief Legacy GetButtonConfigRight.
* @note Only available on [10.0.0-10.2.0]. On [11.0.0+], use \ref hidsysGetButtonConfigRight instead.
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidsysButtonConfigRight
*/
hidsysLegacyGetButtonConfigRight :: (unique_pad_id: HidsysUniquePadId, config: *HidsysButtonConfigRight) -> Result #foreign libnx;

/**
* @brief GetButtonConfigRight
* @note Only available on [11.0.0+]. On [10.0.0-10.2.0], use \ref hidsysLegacyGetButtonConfigRight instead.
* @param[in] addr \ref BtdrvAddress
* @param[out] config \ref HidsysButtonConfigRight
*/
hidsysGetButtonConfigRight :: (addr: BtdrvAddress, config: *HidsysButtonConfigRight) -> Result #foreign libnx;

/**
* @brief IsCustomButtonConfigSupported
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output bool flag.
*/
hidsysIsCustomButtonConfigSupported :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief IsDefaultButtonConfigEmbedded
* @note Only available on [10.0.0+].
* @param[in] config \ref HidcfgButtonConfigEmbedded
* @param[out] out Output bool flag.
*/
hidsysIsDefaultButtonConfigEmbedded :: (config: *HidcfgButtonConfigEmbedded, out: *bool) -> Result #foreign libnx;

/**
* @brief IsDefaultButtonConfigFull
* @note Only available on [10.0.0+].
* @param[in] config \ref HidcfgButtonConfigFull
* @param[out] out Output bool flag.
*/
hidsysIsDefaultButtonConfigFull :: (config: *HidcfgButtonConfigFull, out: *bool) -> Result #foreign libnx;

/**
* @brief IsDefaultButtonConfigLeft
* @note Only available on [10.0.0+].
* @param[in] config \ref HidcfgButtonConfigLeft
* @param[out] out Output bool flag.
*/
hidsysIsDefaultButtonConfigLeft :: (config: *HidcfgButtonConfigLeft, out: *bool) -> Result #foreign libnx;

/**
* @brief IsDefaultButtonConfigRight
* @note Only available on [10.0.0+].
* @param[in] config \ref HidcfgButtonConfigRight
* @param[out] out Output bool flag.
*/
hidsysIsDefaultButtonConfigRight :: (config: *HidcfgButtonConfigRight, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigStorageEmbeddedEmpty
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigStorageEmbeddedEmpty :: (index: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigStorageFullEmpty
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigStorageFullEmpty :: (index: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigStorageLeftEmpty
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigStorageLeftEmpty :: (index: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief IsButtonConfigStorageRightEmpty
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] out Output bool flag.
*/
hidsysIsButtonConfigStorageRightEmpty :: (index: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageEmbeddedDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigEmbedded
*/
hidsysGetButtonConfigStorageEmbeddedDeprecated :: (index: s32, config: *HidcfgButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageFullDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigFull
*/
hidsysGetButtonConfigStorageFullDeprecated :: (index: s32, config: *HidcfgButtonConfigFull) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageLeftDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigLeft
*/
hidsysGetButtonConfigStorageLeftDeprecated :: (index: s32, config: *HidcfgButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageRightDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigRight
*/
hidsysGetButtonConfigStorageRightDeprecated :: (index: s32, config: *HidcfgButtonConfigRight) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageEmbeddedDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigEmbedded
*/
hidsysSetButtonConfigStorageEmbeddedDeprecated :: (index: s32, config: *HidcfgButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageFullDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigFull
*/
hidsysSetButtonConfigStorageFullDeprecated :: (index: s32, config: *HidcfgButtonConfigFull) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageLeftDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigLeft
*/
hidsysSetButtonConfigStorageLeftDeprecated :: (index: s32, config: *HidcfgButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageRightDeprecated
* @note Only available on [10.0.0-12.1.0].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigRight
*/
hidsysSetButtonConfigStorageRightDeprecated :: (index: s32, config: *HidcfgButtonConfigRight) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfigStorageEmbedded
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
*/
hidsysDeleteButtonConfigStorageEmbedded :: (index: s32) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfigStorageFull
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
*/
hidsysDeleteButtonConfigStorageFull :: (index: s32) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfigStorageLeft
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
*/
hidsysDeleteButtonConfigStorageLeft :: (index: s32) -> Result #foreign libnx;

/**
* @brief DeleteButtonConfigStorageRight
* @note Only available on [10.0.0+].
* @param[in] index Array index, should be 0-4.
*/
hidsysDeleteButtonConfigStorageRight :: (index: s32) -> Result #foreign libnx;

/**
* @brief IsUsingCustomButtonConfig
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Output bool flag.
*/
hidsysIsUsingCustomButtonConfig :: (unique_pad_id: HidsysUniquePadId, out: *bool) -> Result #foreign libnx;

/**
* @brief IsAnyCustomButtonConfigEnabled
* @note Only available on [10.0.0+].
* @param[out] out Output bool flag.
*/
hidsysIsAnyCustomButtonConfigEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief SetAllCustomButtonConfigEnabled
* @note Only available on [10.0.0+].
* @param[in] AppletResourceUserId AppletResourceUserId
* @param[in] flag Input bool flag.
*/
hidsysSetAllCustomButtonConfigEnabled :: (AppletResourceUserId: u64, flag: bool) -> Result #foreign libnx;

/**
* @brief SetAllDefaultButtonConfig
* @note Only available on [10.0.0+].
*/
hidsysSetAllDefaultButtonConfig :: () -> Result #foreign libnx;

/**
* @brief SetHidButtonConfigEmbedded
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidcfgButtonConfigEmbedded
*/
hidsysSetHidButtonConfigEmbedded :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief SetHidButtonConfigFull
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidcfgButtonConfigFull
*/
hidsysSetHidButtonConfigFull :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigFull) -> Result #foreign libnx;

/**
* @brief SetHidButtonConfigLeft
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidcfgButtonConfigLeft
*/
hidsysSetHidButtonConfigLeft :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief SetHidButtonConfigRight
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[in] config \ref HidcfgButtonConfigRight
*/
hidsysSetHidButtonConfigRight :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigRight) -> Result #foreign libnx;

/**
* @brief GetHidButtonConfigEmbedded
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidcfgButtonConfigEmbedded
*/
hidsysGetHidButtonConfigEmbedded :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigEmbedded) -> Result #foreign libnx;

/**
* @brief GetHidButtonConfigFull
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidcfgButtonConfigFull
*/
hidsysGetHidButtonConfigFull :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigFull) -> Result #foreign libnx;

/**
* @brief GetHidButtonConfigLeft
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidcfgButtonConfigLeft
*/
hidsysGetHidButtonConfigLeft :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigLeft) -> Result #foreign libnx;

/**
* @brief GetHidButtonConfigRight
* @note Only available on [10.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] config \ref HidcfgButtonConfigRight
*/
hidsysGetHidButtonConfigRight :: (unique_pad_id: HidsysUniquePadId, config: *HidcfgButtonConfigRight) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageEmbedded
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigEmbedded
* @param[out] name \ref HidcfgStorageName
*/
hidsysGetButtonConfigStorageEmbedded :: (index: s32, config: *HidcfgButtonConfigEmbedded, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageFull
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigFull
* @param[out] name \ref HidcfgStorageName
*/
hidsysGetButtonConfigStorageFull :: (index: s32, config: *HidcfgButtonConfigFull, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageLeft
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigLeft
* @param[out] name \ref HidcfgStorageName
*/
hidsysGetButtonConfigStorageLeft :: (index: s32, config: *HidcfgButtonConfigLeft, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief GetButtonConfigStorageRight
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[out] config \ref HidcfgButtonConfigRight
* @param[out] name \ref HidcfgStorageName
*/
hidsysGetButtonConfigStorageRight :: (index: s32, config: *HidcfgButtonConfigRight, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageEmbedded
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigEmbedded
* @param[in] name \ref HidcfgStorageName
*/
hidsysSetButtonConfigStorageEmbedded :: (index: s32, config: *HidcfgButtonConfigEmbedded, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageFull
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigFull
* @param[in] name \ref HidcfgStorageName
*/
hidsysSetButtonConfigStorageFull :: (index: s32, config: *HidcfgButtonConfigFull, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageLeft
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigLeft
* @param[in] name \ref HidcfgStorageName
*/
hidsysSetButtonConfigStorageLeft :: (index: s32, config: *HidcfgButtonConfigLeft, name: *HidcfgStorageName) -> Result #foreign libnx;

/**
* @brief SetButtonConfigStorageRight
* @note Only available on [11.0.0+].
* @param[in] index Array index, should be 0-4.
* @param[in] config \ref HidcfgButtonConfigRight
* @param[in] name \ref HidcfgStorageName
*/
hidsysSetButtonConfigStorageRight :: (index: s32, config: *HidcfgButtonConfigRight, name: *HidcfgStorageName) -> Result #foreign libnx;

/// HiddbgNpadButton. For the remaining buttons, see \ref HidNpadButton.
HiddbgNpadButton :: enum u32 {
    Home    :: 262144;
    Capture :: 524288;
}

/// HdlsAttribute
HiddbgHdlsAttribute :: enum u32 {
    HasVirtualSixAxisSensorAcceleration :: 1;
    HasVirtualSixAxisSensorAngle        :: 2;
}

/// State for overriding \ref HidDebugPadState.
HiddbgDebugPadAutoPilotState :: struct {
    attributes:     u32; ///< Bitfield of \ref HidDebugPadAttribute.
    buttons:        u32; ///< Bitfield of \ref HidDebugPadButton.
    analog_stick_l: HidAnalogStickState; ///< AnalogStickL
    analog_stick_r: HidAnalogStickState; ///< AnalogStickR
}

/// State for overriding \ref HidMouseState.
HiddbgMouseAutoPilotState :: struct {
    x:           s32; ///< X
    y:           s32; ///< Y
    delta_x:     s32; ///< DeltaX
    delta_y:     s32; ///< DeltaY
    wheel_delta: s32; ///< WheelDelta
    buttons:     u32; ///< Bitfield of \ref HidMouseButton.
    attributes:  u32; ///< Bitfield of \ref HidMouseAttribute.
}

/// State for overriding \ref HidKeyboardState.
HiddbgKeyboardAutoPilotState :: struct {
    modifiers: u64; ///< Bitfield of \ref HidKeyboardModifier.
    keys:      [4] u64;
}

/// State for overriding SleepButtonState.
HiddbgSleepButtonAutoPilotState :: struct {
    buttons: u64; ///< Bitfield of buttons, only bit0 is used.
}

/// HdlsHandle
HiddbgHdlsHandle :: struct {
    handle: u64; ///< Handle
}

/// HdlsSessionId, returned by \ref hiddbgAttachHdlsWorkBuffer.
HiddbgHdlsSessionId :: struct {
    id: u64; ///< Id
}

/// HdlsDeviceInfo, for [7.0.0-8.1.0].
HiddbgHdlsDeviceInfoV7 :: struct {
    deviceTypeInternal: u32; ///< Only one bit can be set. BIT(N*4+0) = Pro-Controller, BIT(N*4+1) = Joy-Con Left, BIT(N*4+2) = Joy-Con Right, BIT(N*4+3) = invalid. Where N is 0-1. BIT(8-10) = Pro-Controller, BIT(11) = Famicom-Controller, BIT(12) = Famicom-Controller II with microphone, BIT(13) = NES-Controller(DeviceType=0x200), BIT(14) = NES-Controller(DeviceType=0x400), BIT(15-16) = invalid, BIT(17) = unknown(DeviceType=0x8000), BIT(18-20) = invalid, BIT(21-23) = unknown(DeviceType=0x80000000).
    singleColorBody:    u32; ///< RGBA Single Body Color.
    singleColorButtons: u32; ///< RGBA Single Buttons Color.
    npadInterfaceType:  u8; ///< \ref HidNpadInterfaceType. Additional type field used with the above type field (only applies to type bit0-bit2 and bit21), if the value doesn't match one of the following a default is used. Type Pro-Controller: value 0x3 indicates that the controller is connected via USB. Type BIT(21): value 0x3 = unknown. When value is 0x2, state is merged with an existing controller (when the type value is compatible with this). Otherwise, it's a dedicated controller.
    pad:                [3] u8; ///< Padding.
}

/// HdlsDeviceInfo, for [9.0.0+]. Converted to/from \ref HiddbgHdlsDeviceInfoV7 on prior sysvers.
HiddbgHdlsDeviceInfo :: struct {
    deviceType:         u8; ///< \ref HidDeviceType
    npadInterfaceType:  u8; ///< \ref HidNpadInterfaceType. Additional type field used with the above type field (only applies to ::HidDeviceType_JoyRight1, ::HidDeviceType_JoyLeft2, ::HidDeviceType_FullKey3, and ::HidDeviceType_System19), if the value doesn't match one of the following a default is used. ::HidDeviceType_FullKey3: ::HidNpadInterfaceType_USB indicates that the controller is connected via USB. :::HidDeviceType_System19: ::HidNpadInterfaceType_USB = unknown. When value is ::HidNpadInterfaceType_Rail, state is merged with an existing controller (with ::HidDeviceType_JoyRight1 / ::HidDeviceType_JoyLeft2). Otherwise, it's a dedicated controller.
    pad:                [2] u8; ///< Padding.
    singleColorBody:    u32; ///< RGBA Single Body Color.
    singleColorButtons: u32; ///< RGBA Single Buttons Color.
    colorLeftGrip:      u32; ///< [9.0.0+] RGBA Left Grip Color.
    colorRightGrip:     u32; ///< [9.0.0+] RGBA Right Grip Color.
}

/// HdlsState, for [7.0.0-8.1.0].
HiddbgHdlsStateV7 :: struct {
    is_powered:     u8; ///< IsPowered for the main PowerInfo, see \ref HidNpadSystemProperties.
    flags:          u8; ///< ORRed with IsPowered to set the value of the first byte for \ref HidNpadSystemProperties. For example, value 1 here will set IsCharging for the main PowerInfo.
    unk_x2:         [6] u8; ///< Unknown
    battery_level:  u32; ///< BatteryLevel for the main PowerInfo, see \ref HidPowerInfo.
    buttons:        u32; ///< See \ref HiddbgNpadButton.
    analog_stick_l: HidAnalogStickState; ///< AnalogStickL
    analog_stick_r: HidAnalogStickState; ///< AnalogStickR
    indicator:      u8; ///< Indicator. Unused for input. Set with output from \ref hiddbgDumpHdlsStates. Not set by \ref hiddbgGetAbstractedPadsState.
    padding:        [3] u8; ///< Padding
}

/// HdlsState, for [9.0.0-11.0.1].
HiddbgHdlsStateV9 :: struct {
    battery_level:  u32; ///< BatteryLevel for the main PowerInfo, see \ref HidPowerInfo.
    flags:          u32; ///< Used to set the main PowerInfo for \ref HidNpadSystemProperties. BIT(0) -> IsPowered, BIT(1) -> IsCharging.
    buttons:        u64; ///< See \ref HiddbgNpadButton. [9.0.0+] Masked with 0xfffffffff00fffff.
    analog_stick_l: HidAnalogStickState; ///< AnalogStickL
    analog_stick_r: HidAnalogStickState; ///< AnalogStickR
    indicator:      u8; ///< Indicator. Unused for input. Set with output from \ref hiddbgDumpHdlsStates.
    padding:        [3] u8; ///< Padding
}

/// HdlsState, for [12.0.0+].
HiddbgHdlsState :: struct {
    battery_level:                u32; ///< BatteryLevel for the main PowerInfo, see \ref HidPowerInfo.
    flags:                        u32; ///< Used to set the main PowerInfo for \ref HidNpadSystemProperties. BIT(0) -> IsPowered, BIT(1) -> IsCharging.
    buttons:                      u64; ///< See \ref HiddbgNpadButton. [9.0.0+] Masked with 0xfffffffff00fffff.
    analog_stick_l:               HidAnalogStickState; ///< AnalogStickL
    analog_stick_r:               HidAnalogStickState; ///< AnalogStickR
    six_axis_sensor_acceleration: HidVector; ///< VirtualSixAxisSensorAcceleration
    six_axis_sensor_angle:        HidVector; ///< VirtualSixAxisSensorAngle
    attribute:                    u32; ///< Bitfield of \ref HiddbgHdlsAttribute.
    indicator:                    u8; ///< Indicator. Unused for input.
    padding:                      [3] u8; ///< Padding
}

/// HdlsNpadAssignmentEntry
HiddbgHdlsNpadAssignmentEntry :: struct {
    handle:  HiddbgHdlsHandle; ///< \ref HiddbgHdlsHandle
    unk_x8:  u32; ///< Unknown
    unk_xc:  u32; ///< Unknown
    unk_x10: u64; ///< Unknown
    unk_x18: u8; ///< Unknown
    pad:     [7] u8; ///< Padding
}

/// HdlsNpadAssignment. Same controllers as \ref HiddbgHdlsStateList, with different entry data.
HiddbgHdlsNpadAssignment :: struct {
    total_entries: s32; ///< Total entries for the below entries.
    pad:           u32; ///< Padding
    entries:       [16] HiddbgHdlsNpadAssignmentEntry; ///< \ref HiddbgHdlsNpadAssignmentEntry
}

/// HdlsStateListEntryV7, for [7.0.0-8.1.0].
HiddbgHdlsStateListEntryV7 :: struct {
    handle: HiddbgHdlsHandle; ///< \ref HiddbgHdlsHandle
    device: HiddbgHdlsDeviceInfoV7; ///< \ref HiddbgHdlsDeviceInfoV7. With \ref hiddbgApplyHdlsStateList this is only used when creating new devices.
    state:  HiddbgHdlsStateV7; ///< \ref HiddbgHdlsStateV7
}

/// HdlsStateListV7, for [7.0.0-8.1.0]. This contains a list of all controllers, including non-virtual controllers.
HiddbgHdlsStateListV7 :: struct {
    total_entries: s32; ///< Total entries for the below entries.
    pad:           u32; ///< Padding
    entries:       [16] HiddbgHdlsStateListEntryV7; ///< \ref HiddbgHdlsStateListEntryV7
}

/// HdlsStateListEntry, for [9.0.0-11.0.1].
HiddbgHdlsStateListEntryV9 :: struct {
    handle: HiddbgHdlsHandle; ///< \ref HiddbgHdlsHandle
    device: HiddbgHdlsDeviceInfo; ///< \ref HiddbgHdlsDeviceInfo. With \ref hiddbgApplyHdlsStateList this is only used when creating new devices.
    state:  HiddbgHdlsStateV9; ///< \ref HiddbgHdlsStateV9
}

/// HdlsStateList, for [9.0.0-11.0.1].
HiddbgHdlsStateListV9 :: struct {
    total_entries: s32; ///< Total entries for the below entries.
    pad:           u32; ///< Padding
    entries:       [16] HiddbgHdlsStateListEntryV9; ///< \ref HiddbgHdlsStateListEntryV9
}

/// HdlsStateListEntry, for [12.0.0+].
HiddbgHdlsStateListEntry :: struct {
    handle: HiddbgHdlsHandle; ///< \ref HiddbgHdlsHandle
    device: HiddbgHdlsDeviceInfo; ///< \ref HiddbgHdlsDeviceInfo. With \ref hiddbgApplyHdlsStateList this is only used when creating new devices.
    state:  HiddbgHdlsState; ///< \ref HiddbgHdlsState
}

/// HdlsStateList, for [12.0.0+].
/// This contains a list of all controllers, including non-virtual controllers.
HiddbgHdlsStateList :: struct {
    total_entries: s32; ///< Total entries for the below entries.
    pad:           u32; ///< Padding
    entries:       [16] HiddbgHdlsStateListEntry; ///< \ref HiddbgHdlsStateListEntry
}

/// AbstractedPadHandle
HiddbgAbstractedPadHandle :: struct {
    handle: u64; ///< Handle
}

/// AbstractedPadState
HiddbgAbstractedPadState :: struct {
    type:               u32; ///< Type. Converted to HiddbgHdlsDeviceInfoV7::type internally by \ref hiddbgSetAutoPilotVirtualPadState. BIT(0) -> BIT(0), BIT(1) -> BIT(15), BIT(2-3) -> BIT(1-2), BIT(4-5) -> BIT(1-2), BIT(6) -> BIT(3). BIT(7-11) -> BIT(11-15), BIT(12-14) -> BIT(12-14), BIT(15) -> BIT(17), BIT(31) -> BIT(21).
    flags:              u8; ///< Flags. Only bit0 is used by \ref hiddbgSetAutoPilotVirtualPadState, when clear it will skip using the rest of the input and run \ref hiddbgUnsetAutoPilotVirtualPadState internally.
    pad:                [3] u8; ///< Padding

    singleColorBody:    u32; ///< RGBA Single Body Color
    singleColorButtons: u32; ///< RGBA Single Buttons Color
    npadInterfaceType:  u8; ///< See HiddbgHdlsDeviceInfo::npadInterfaceType.
    pad2:               [3] u8; ///< Padding

    state:              HiddbgHdlsStateV7; ///< State

    unused:             [96] u8; ///< Unused with \ref hiddbgSetAutoPilotVirtualPadState. Not set by \ref hiddbgGetAbstractedPadsState.
}

/// Initialize hiddbg.
hiddbgInitialize :: () -> Result #foreign libnx;

/// Exit hiddbg.
hiddbgExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual hiddbg service session.
hiddbgGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief SetDebugPadAutoPilotState
* @param[in] state \ref HiddbgDebugPadAutoPilotState
*/
hiddbgSetDebugPadAutoPilotState :: (state: *HiddbgDebugPadAutoPilotState) -> Result #foreign libnx;

/**
* @brief UnsetDebugPadAutoPilotState
*/
hiddbgUnsetDebugPadAutoPilotState :: () -> Result #foreign libnx;

/**
* @brief SetTouchScreenAutoPilotState
* @param[in] states Input array of \ref HiddbgMouseAutoPilotState.
* @param[in] count Total entries in the states array. Max is 16.
*/
hiddbgSetTouchScreenAutoPilotState :: (states: *HidTouchState, count: s32) -> Result #foreign libnx;

/**
* @brief UnsetTouchScreenAutoPilotState
*/
hiddbgUnsetTouchScreenAutoPilotState :: () -> Result #foreign libnx;

/**
* @brief SetMouseAutoPilotState
* @param[in] state \ref HiddbgMouseAutoPilotState
*/
hiddbgSetMouseAutoPilotState :: (state: *HiddbgMouseAutoPilotState) -> Result #foreign libnx;

/**
* @brief UnsetMouseAutoPilotState
*/
hiddbgUnsetMouseAutoPilotState :: () -> Result #foreign libnx;

/**
* @brief SetKeyboardAutoPilotState
* @param[in] state \ref HiddbgKeyboardAutoPilotState
*/
hiddbgSetKeyboardAutoPilotState :: (state: *HiddbgKeyboardAutoPilotState) -> Result #foreign libnx;

/**
* @brief UnsetKeyboardAutoPilotState
*/
hiddbgUnsetKeyboardAutoPilotState :: () -> Result #foreign libnx;

/**
* @brief Deactivates the HomeButton.
*/
hiddbgDeactivateHomeButton :: () -> Result #foreign libnx;

/**
* @brief SetSleepButtonAutoPilotState
* @param[in] state \ref HiddbgSleepButtonAutoPilotState
*/
hiddbgSetSleepButtonAutoPilotState :: (state: *HiddbgSleepButtonAutoPilotState) -> Result #foreign libnx;

/**
* @brief UnsetSleepButtonAutoPilotState
*/
hiddbgUnsetSleepButtonAutoPilotState :: () -> Result #foreign libnx;

/**
* @brief Writes the input RGB colors to the spi-flash for the specified UniquePad (offset 0x6050 size 0x6).
* @note Only available with [3.0.0+].
* @param[in] colorBody RGB body color.
* @param[in] colorButtons RGB buttons color.
* @param[in] unique_pad_id \ref HidsysUniquePadId
*/
hiddbgUpdateControllerColor :: (colorBody: u32, colorButtons: u32, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Writes the input RGB colors followed by inval to the spi-flash for the specified UniquePad (offset 0x6050 size 0xD).
* @note Only available with [5.0.0+].
* @param[in] colorBody RGB body color.
* @param[in] colorButtons RGB buttons color.
* @param[in] colorLeftGrip RGB left grip color.
* @param[in] colorRightGrip RGB right grip color.
* @param[in] inval Input value.
* @param[in] unique_pad_id \ref HidsysUniquePadId
*/
hiddbgUpdateDesignInfo :: (colorBody: u32, colorButtons: u32, colorLeftGrip: u32, colorRightGrip: u32, inval: u8, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Get the OperationEvent for the specified UniquePad.
* @note The Event must be closed by the user once finished with it.
* @note Only available with [6.0.0+].
* @param[out] out_event Output Event.
* @param[in] autoclear The autoclear for the Event.
* @param[in] unique_pad_id \ref HidsysUniquePadId
**/
hiddbgAcquireOperationEventHandle :: (out_event: *Event, autoclear: bool, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Reads spi-flash for the specified UniquePad.
* @note This also uses \ref hiddbgAcquireOperationEventHandle to wait for the operation to finish, then \ref hiddbgGetOperationResult is used.
* @note Only available with [6.0.0+].
* @param[in] offset Offset in spi-flash.
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size.
* @param[in] unique_pad_id \ref HidsysUniquePadId
**/
hiddbgReadSerialFlash :: (offset: u32, buffer: *void, size: u64, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Writes spi-flash for the specified UniquePad.
* @note This also uses \ref hiddbgAcquireOperationEventHandle to wait for the operation to finish, then \ref hiddbgGetOperationResult is used.
* @note Only available with [6.0.0+].
* @param[in] offset Offset in spi-flash.
* @param[in] buffer Input buffer, must be 0x1000-byte aligned.
* @param[in] tmem_size Size of the buffer, must be 0x1000-byte aligned.
* @param[in] size Actual transfer size.
* @param[in] unique_pad_id \ref HidsysUniquePadId
**/
hiddbgWriteSerialFlash :: (offset: u32, buffer: *void, tmem_size: u64, size: u64, unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Get the Result for the Operation and handles cleanup, for the specified UniquePad.
* @note Only available with [6.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
**/
hiddbgGetOperationResult :: (unique_pad_id: HidsysUniquePadId) -> Result #foreign libnx;

/**
* @brief Gets the internal DeviceType for the specified controller.
* @note Only available with [6.0.0+].
* @param[in] unique_pad_id \ref HidsysUniquePadId
* @param[out] out Pre-9.0.0 this is an u32, with [9.0.0+] it's an u8.
**/
hiddbgGetUniquePadDeviceTypeSetInternal :: (unique_pad_id: HidsysUniquePadId, out: *u32) -> Result #foreign libnx;

/**
* @brief Gets a list of \ref HiddbgAbstractedPadHandle.
* @note Only available with [5.0.0-8.1.0].
* @param[out] handles Output array of \ref HiddbgAbstractedPadHandle.
* @param[in] count Max number of entries for the handles array.
* @param[out] total_out Total output entries.
*/
hiddbgGetAbstractedPadHandles :: (handles: *HiddbgAbstractedPadHandle, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets the state for the specified \ref HiddbgAbstractedPadHandle.
* @note Only available with [5.0.0-8.1.0].
* @param[in] handle \ref HiddbgAbstractedPadHandle
* @param[out] state \ref HiddbgAbstractedPadState
*/
hiddbgGetAbstractedPadState :: (handle: HiddbgAbstractedPadHandle, state: *HiddbgAbstractedPadState) -> Result #foreign libnx;

/**
* @brief Similar to \ref hiddbgGetAbstractedPadHandles except this also returns the state for each pad in output array states.
* @note Only available with [5.0.0-8.1.0].
* @param[out] handles Output array of \ref HiddbgAbstractedPadHandle.
* @param[out] states Output array of \ref HiddbgAbstractedPadState.
* @param[in] count Max number of entries for the handles/states arrays.
* @param[out] total_out Total output entries.
*/
hiddbgGetAbstractedPadsState :: (handles: *HiddbgAbstractedPadHandle, states: *HiddbgAbstractedPadState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Sets AutoPilot state for the specified pad.
* @note Only available with [5.0.0-8.1.0].
* @param[in] AbstractedVirtualPadId This can be any unique value as long as it's within bounds. For example, 0-7 is usable.
* @param[in] state \ref HiddbgAbstractedPadState
*/
hiddbgSetAutoPilotVirtualPadState :: (AbstractedVirtualPadId: s8, state: *HiddbgAbstractedPadState) -> Result #foreign libnx;

/**
* @brief Clears AutoPilot state for the specified pad set by \ref hiddbgSetAutoPilotVirtualPadState.
* @note Only available with [5.0.0-8.1.0].
* @param[in] AbstractedVirtualPadId Id from \ref hiddbgSetAutoPilotVirtualPadState.
*/
hiddbgUnsetAutoPilotVirtualPadState :: (AbstractedVirtualPadId: s8) -> Result #foreign libnx;

/**
* @brief Clears AutoPilot state for all pads set by \ref hiddbgSetAutoPilotVirtualPadState.
*/
hiddbgUnsetAllAutoPilotVirtualPadState :: () -> Result #foreign libnx;

/**
* @brief Initialize Hdls.
* @note Only available with [7.0.0+].
* @param[out] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[in] buffer An existing buffer to be used as transfer memory.
* @param[in] size Size of the supplied buffer.
*/
hiddbgAttachHdlsWorkBuffer :: (session_id: *HiddbgHdlsSessionId, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Exit Hdls, must be called at some point prior to \ref hiddbgExit.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
*/
hiddbgReleaseHdlsWorkBuffer :: (session_id: HiddbgHdlsSessionId) -> Result #foreign libnx;

/**
* @brief Checks if the given device is still attached.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[in] handle \ref HiddbgHdlsHandle
* @param[out] out Whether the device is attached.
*/
hiddbgIsHdlsVirtualDeviceAttached :: (session_id: HiddbgHdlsSessionId, handle: HiddbgHdlsHandle, out: *bool) -> Result #foreign libnx;

/**
* @brief Gets state for \ref HiddbgHdlsNpadAssignment.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[out] state \ref HiddbgHdlsNpadAssignment
*/
hiddbgDumpHdlsNpadAssignmentState :: (session_id: HiddbgHdlsSessionId, state: *HiddbgHdlsNpadAssignment) -> Result #foreign libnx;

/**
* @brief Gets state for \ref HiddbgHdlsStateList.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[out] state \ref HiddbgHdlsStateList
*/
hiddbgDumpHdlsStates :: (session_id: HiddbgHdlsSessionId, state: *HiddbgHdlsStateList) -> Result #foreign libnx;

/**
* @brief Sets state for \ref HiddbgHdlsNpadAssignment.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[in] state \ref HiddbgHdlsNpadAssignment
* @param[in] flag Flag
*/
hiddbgApplyHdlsNpadAssignmentState :: (session_id: HiddbgHdlsSessionId, state: *HiddbgHdlsNpadAssignment, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets state for \ref HiddbgHdlsStateList.
* @note The \ref HiddbgHdlsState will be applied for each \ref HiddbgHdlsHandle. If a \ref HiddbgHdlsHandle is not found, code similar to \ref hiddbgAttachHdlsVirtualDevice will run with the \ref HiddbgHdlsDeviceInfo, then it will continue with applying state with the new device.
* @note Only available with [7.0.0+].
* @param[in] session_id [13.0.0+] \ref HiddbgHdlsSessionId
* @param[in] state \ref HiddbgHdlsStateList
*/
hiddbgApplyHdlsStateList :: (session_id: HiddbgHdlsSessionId, state: *HiddbgHdlsStateList) -> Result #foreign libnx;

/**
* @brief Attach a device with the input info.
* @note Only available with [7.0.0+].
* @param[out] handle \ref HiddbgHdlsHandle
* @param[in] info \ref HiddbgHdlsDeviceInfo
*/
hiddbgAttachHdlsVirtualDevice :: (handle: *HiddbgHdlsHandle, info: *HiddbgHdlsDeviceInfo) -> Result #foreign libnx;

/**
* @brief Detach the specified device.
* @note Only available with [7.0.0+].
* @param[in] handle \ref HiddbgHdlsHandle
*/
hiddbgDetachHdlsVirtualDevice :: (handle: HiddbgHdlsHandle) -> Result #foreign libnx;

/**
* @brief Sets state for the specified device.
* @note Only available with [7.0.0+].
* @param[in] handle \ref HiddbgHdlsHandle
* @param[in] state \ref HiddbgHdlsState
*/
hiddbgSetHdlsState :: (handle: HiddbgHdlsHandle, state: *HiddbgHdlsState) -> Result #foreign libnx;

/// IrCameraStatus
IrsIrCameraStatus :: enum u32 {
    Available   :: 0;
    Unsupported :: 1;
    Unconnected :: 2;
}

/// IrCameraInternalStatus
IrsIrCameraInternalStatus :: enum u32 {
    Stopped                  :: 0;
    FirmwareUpdateNeeded     :: 1;
    Unknown2                 :: 2;
    Unknown3                 :: 3;
    Unknown4                 :: 4;
    FirmwareVersionRequested :: 5;
    FirmwareVersionIsInvalid :: 6;
    Ready                    :: 7;
    Setting                  :: 8;
}

/// IrSensorMode
IrsIrSensorMode :: enum u32 {
    None                   :: 0;
    MomentProcessor        :: 1;
    ClusteringProcessor    :: 2;
    ImageTransferProcessor :: 3;
    PointingProcessor      :: 4;
    TeraPluginProcessor    :: 5;
    IrLedProcessor         :: 6;
}

/// ImageProcessorStatus
IrsImageProcessorStatus :: enum u32 {
    Stopped :: 0;
    Running :: 1;
}

/// ImageTransferProcessorFormat. IR Sensor image resolution.
IrsImageTransferProcessorFormat :: enum u32 {
    _320x240 :: 0;
    _160x120 :: 1;
    _80x60   :: 2;
    _40x30   :: 3;
    _20x15   :: 4;
}

/// AdaptiveClusteringMode
IrsAdaptiveClusteringMode :: enum u32 {
    StaticFov  :: 0;
    DynamicFov :: 1;
}

/// AdaptiveClusteringTargetDistance
IrsAdaptiveClusteringTargetDistance :: enum u32 {
    Near   :: 0;
    Middle :: 1;
    Far    :: 2;
}

/// HandAnalysisMode
IrsHandAnalysisMode :: enum u32 {
    Silhouette         :: 1;
    Image              :: 2;
    SilhouetteAndImage :: 3;
    SilhouetteOnly     :: 4;
}

/// Internal validation callblack.
IrsValidationCb :: #type (userdata: *void, arg: *void) -> bool #c_call;

/// IrCameraHandle
IrsIrCameraHandle :: struct {
    player_number: u8; ///< PlayerNumber
    device_type:   u8; ///< DeviceType
    reserved:      [2] u8; ///< Reserved
}

/// PackedMcuVersion
IrsPackedMcuVersion :: struct {
    major_version: u16; ///< MajorVersion
    minor_version: u16; ///< MinorVersion
}

/// PackedFunctionLevel
IrsPackedFunctionLevel :: struct {
    ir_sensor_function_level: u8; ///< IrSensorFunctionLevel
    reserved:                 [3] u8; ///< Reserved
}

/// Rect
IrsRect :: struct {
    x:      s16; ///< X
    y:      s16; ///< Y
    width:  s16; ///< Width
    height: s16; ///< Height
}

/// IrsMomentProcessorConfig
IrsMomentProcessorConfig :: struct {
    exposure_time:                  u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                   u32; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                           u32; ///< IR sensor signal's digital gain.
    is_negative_image_used:         u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                       [7] u8; ///< Reserved.
    window_of_interest:             IrsRect; ///< WindowOfInterest
    preprocess:                     u32; ///< Preprocess
    preprocess_intensity_threshold: u32; ///< PreprocessIntensityThreshold
}

/// PackedMomentProcessorConfig
IrsPackedMomentProcessorConfig :: struct {
    exposure_time:                  u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                   u8; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                           u8; ///< IR sensor signal's digital gain.
    is_negative_image_used:         u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                       [5] u8; ///< Reserved.
    window_of_interest:             IrsRect; ///< WindowOfInterest
    required_mcu_version:           IrsPackedMcuVersion; ///< RequiredMcuVersion
    preprocess:                     u8; ///< Preprocess
    preprocess_intensity_threshold: u8; ///< PreprocessIntensityThreshold
    reserved2:                      [2] u8; ///< Reserved.
}

/// ClusteringProcessorConfig
IrsClusteringProcessorConfig :: struct {
    exposure_time:                    u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                     u32; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                             u32; ///< IR sensor signal's digital gain.
    is_negative_image_used:           u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                         [7] u8; ///< Reserved.
    window_of_interest:               IrsRect; ///< WindowOfInterest
    object_pixel_count_min:           u32; ///< ObjectPixelCountMin
    object_pixel_count_max:           u32; ///< ObjectPixelCountMax
    object_intensity_min:             u32; ///< ObjectIntensityMin
    is_external_light_filter_enabled: u8; ///< IsExternalLightFilterEnabled
}

/// PackedClusteringProcessorConfig
IrsPackedClusteringProcessorConfig :: struct {
    exposure_time:                    u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                     u8; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                             u8; ///< IR sensor signal's digital gain.
    is_negative_image_used:           u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                         [5] u8; ///< Reserved.
    window_of_interest:               IrsRect; ///< WindowOfInterest
    required_mcu_version:             IrsPackedMcuVersion; ///< RequiredMcuVersion
    object_pixel_count_min:           u32; ///< ObjectPixelCountMin
    object_pixel_count_max:           u32; ///< ObjectPixelCountMax
    object_intensity_min:             u8; ///< ObjectIntensityMin
    is_external_light_filter_enabled: u8; ///< IsExternalLightFilterEnabled
    reserved2:                        [2] u8; ///< Reserved.
}

/// ImageTransferProcessorConfig
IrsImageTransferProcessorConfig :: struct {
    exposure_time:          u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:           u32; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                   u32; ///< IR sensor signal's digital gain.
    is_negative_image_used: u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:               [7] u8; ///< Reserved.
    format:                 u32; ///< \ref IrsImageTransferProcessorFormat
}

/// ImageTransferProcessorExConfig
IrsImageTransferProcessorExConfig :: struct {
    exposure_time:                    u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                     u32; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                             u32; ///< IR sensor signal's digital gain.
    is_negative_image_used:           u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                         [7] u8; ///< Reserved.
    orig_format:                      u32; ///< OrigFormat \ref IrsImageTransferProcessorFormat
    trimming_format:                  u32; ///< TrimmingFormat \ref IrsImageTransferProcessorFormat
    trimming_start_x:                 u16; ///< TrimmingStartX
    trimming_start_y:                 u16; ///< TrimmingStartY
    is_external_light_filter_enabled: u8; ///< IsExternalLightFilterEnabled
}

/// PackedImageTransferProcessorConfig
IrsPackedImageTransferProcessorConfig :: struct {
    exposure_time:          u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:           u8; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                   u8; ///< IR sensor signal's digital gain.
    is_negative_image_used: u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:               [5] u8; ///< Reserved.
    required_mcu_version:   IrsPackedMcuVersion; ///< RequiredMcuVersion
    format:                 u8; ///< \ref IrsImageTransferProcessorFormat
    reserved2:              [3] u8; ///< Reserved.
}

/// PackedImageTransferProcessorExConfig
IrsPackedImageTransferProcessorExConfig :: struct {
    exposure_time:                    u64; ///< IR Sensor exposure time in nanoseconds.
    light_target:                     u8; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    gain:                             u8; ///< IR sensor signal's digital gain.
    is_negative_image_used:           u8; ///< Inverts the colors of the captured image. 0: Normal image, 1: Negative image.
    reserved:                         [5] u8; ///< Reserved.
    required_mcu_version:             IrsPackedMcuVersion; ///< RequiredMcuVersion
    orig_format:                      u8; ///< OrigFormat \ref IrsImageTransferProcessorFormat
    trimming_format:                  u8; ///< TrimmingFormat \ref IrsImageTransferProcessorFormat
    trimming_start_x:                 u16; ///< TrimmingStartX
    trimming_start_y:                 u16; ///< TrimmingStartY
    is_external_light_filter_enabled: u8; ///< IsExternalLightFilterEnabled
    reserved2:                        [5] u8; ///< Reserved.
}

/// ImageTransferProcessorState
IrsImageTransferProcessorState :: struct {
    sampling_number:     u64; ///< SamplingNumber
    ambient_noise_level: u32; ///< AmbientNoiseLevel
    reserved:            [4] u8; ///< Reserved
}

/// PackedPointingProcessorConfig
IrsPackedPointingProcessorConfig :: struct {
    window_of_interest:   IrsRect; ///< WindowOfInterest
    required_mcu_version: IrsPackedMcuVersion; ///< RequiredMcuVersion
}

/// TeraPluginProcessorConfig
IrsTeraPluginProcessorConfig :: struct {
    mode:   u8; ///< Mode
    unk_x1: u8; ///< [6.0.0+] Unknown
    unk_x2: u8; ///< [6.0.0+] Unknown
    unk_x3: u8; ///< [6.0.0+] Unknown
}

/// PackedTeraPluginProcessorConfig
IrsPackedTeraPluginProcessorConfig :: struct {
    required_mcu_version: IrsPackedMcuVersion; ///< RequiredMcuVersion
    mode:                 u8; ///< Mode
    unk_x5:               u8; ///< [6.0.0+] This is set to 0x2 | (IrsTeraPluginProcessorConfig::unk_x1 << 7).
    unk_x6:               u8; ///< [6.0.0+] IrsTeraPluginProcessorConfig::unk_x2
    unk_x7:               u8; ///< [6.0.0+] IrsTeraPluginProcessorConfig::unk_x3
}

/// IrLedProcessorConfig
IrsIrLedProcessorConfig :: struct {
    light_target: u32; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
}

/// PackedIrLedProcessorConfig
IrsPackedIrLedProcessorConfig :: struct {
    required_mcu_version: IrsPackedMcuVersion; ///< RequiredMcuVersion
    light_target:         u8; ///< Controls the IR leds. 0: All leds, 1: Bright group, 2: Dim group, 3: None.
    pad:                  [3] u8; ///< Padding
}

/// AdaptiveClusteringProcessorConfig
IrsAdaptiveClusteringProcessorConfig :: struct {
    mode:            u32; ///< \ref IrsAdaptiveClusteringMode
    target_distance: u32; ///< [6.0.0+] \ref IrsAdaptiveClusteringTargetDistance
}

/// HandAnalysisConfig
IrsHandAnalysisConfig :: struct {
    mode: u32; ///< \ref IrsHandAnalysisMode
}

/// MomentStatistic
IrsMomentStatistic :: struct {
    average_intensity: float; ///< AverageIntensity
    centroid_x:        float; ///< CentroidX
    centroid_y:        float; ///< CentroidY
}

/// MomentProcessorState
IrsMomentProcessorState :: struct {
    sampling_number:     s64; ///< SamplingNumber
    timestamp:           u64; ///< TimeStamp

    ambient_noise_level: u32; ///< AmbientNoiseLevel
    reserved:            [4] u8; ///< Reserved
    statistic:           [48] IrsMomentStatistic; ///< \ref IrsMomentStatistic
}

/// ClusteringData
IrsClusteringData :: struct {
    average_intensity: float; ///< AverageIntensity
    centroid_x:        float; ///< CentroidX
    centroid_y:        float; ///< CentroidY
    pixel_count:       u32; ///< PixelCount
    bound_x:           u16; ///< BoundX
    bound_y:           u16; ///< BoundY
    boundt_width:      u16; ///< BoundtWidth
    bound_height:      u16; ///< BoundHeight
}

/// ClusteringProcessorState
IrsClusteringProcessorState :: struct {
    sampling_number:     s64; ///< SamplingNumber
    timestamp:           u64; ///< TimeStamp

    object_count:        u8; ///< ObjectCount
    reserved:            [3] u8; ///< Reserved
    ambient_noise_level: u32; ///< AmbientNoiseLevel
    data:                [16] IrsClusteringData; ///< \ref IrsClusteringData
}

/// PointingProcessorMarkerState
IrsPointingProcessorMarkerState :: struct {
    sampling_number: s64; ///< SamplingNumber
    timestamp:       u64; ///< TimeStamp

    data:            [3] struct {
        pointing_status:    u8; ///< PointingStatus
        reserved:           [3] u8; ///< Reserved
        unk_x4:             [4] u8; ///< Unknown
        unk_x8:             float; ///< Unknown
        position_x:         float; ///< PositionX
        position_y:         float; ///< PositionY
        unk_x14:            float; ///< Unknown
        window_of_interest: IrsRect; ///< WindowOfInterest
    };
}

/// PointingProcessorState
IrsPointingProcessorState :: struct {
    sampling_number: s64; ///< SamplingNumber
    timestamp:       u64; ///< TimeStamp

    pointing_status: u32; ///< PointingStatus
    position_x:      float; ///< PositionX
    position_y:      float; ///< PositionY
    reserved:        [4] u8; ///< Reserved
}

/// TeraPluginProcessorState
IrsTeraPluginProcessorState :: struct {
    sampling_number:     s64; ///< SamplingNumber
    timestamp:           u64; ///< TimeStamp
    ambient_noise_level: u32; ///< AmbientNoiseLevel
    plugin_data:         [300] u8; ///< PluginData
}

/// ProcessorState
IrsProcessorState :: struct {
    start: s64; ///< Start
    count: u32; ///< Count
    pad:   u32; ///< Padding

    data:  [3600] u8; ///< Contains an array of *ProcessorState, depending on IrsDeviceFormat::ir_sensor_mode.
}

/// DeviceFormat
IrsDeviceFormat :: struct {
    ir_camera_status:          u32; ///< \ref IrsIrCameraStatus
    ir_camera_internal_status: u32; ///< \ref IrsIrCameraInternalStatus
    ir_sensor_mode:            u32; ///< \ref IrsIrSensorMode
    pad:                       u32; ///< Padding

    processor_state:           IrsProcessorState; ///< \ref IrsProcessorState
}

/// AruidFormat
IrsAruidFormat :: struct {
    ir_sensor_aruid:        u64; ///< IrSensorAruid
    ir_sensor_aruid_status: u32; ///< IrSensorAruidStatus
    pad:                    u32; ///< Padding
}

/// StatusManager
IrsStatusManager :: struct {
    device_format: [9] IrsDeviceFormat;
    aruid_format:  [5] IrsAruidFormat;
}

/// Initialize irs.
irsInitialize :: () -> Result #foreign libnx;

/// Exit irs.
irsExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual irs service session.
irsGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the address of the SharedMemory (\ref IrsStatusManager).
irsGetSharedmemAddr :: () -> *void #foreign libnx;

/// Gets the \ref IrsIrCameraHandle for the specified controller.
irsGetIrCameraHandle :: (handle: *IrsIrCameraHandle, id: HidNpadIdType) -> Result #foreign libnx;

/// GetIrCameraStatus
irsGetIrCameraStatus :: (handle: IrsIrCameraHandle, out: *IrsIrCameraStatus) -> Result #foreign libnx;

/// CheckFirmwareUpdateNecessity
/// When successful where the output flag is set, the user should use \ref hidLaShowControllerFirmwareUpdate.
/// Only available on [4.0.0+].
irsCheckFirmwareUpdateNecessity :: (handle: IrsIrCameraHandle, out: *bool) -> Result #foreign libnx;

/// GetImageProcessorStatus
/// Only available on [4.0.0+].
irsGetImageProcessorStatus :: (handle: IrsIrCameraHandle, out: *IrsImageProcessorStatus) -> Result #foreign libnx;

/// Stop the current Processor.
/// \ref irsExit calls this with all IrCameraHandles which were not already used with \ref irsStopImageProcessor.
irsStopImageProcessor :: (handle: IrsIrCameraHandle) -> Result #foreign libnx;

/// Stop the current Processor, async.
/// Only available on [4.0.0+].
irsStopImageProcessorAsync :: (handle: IrsIrCameraHandle) -> Result #foreign libnx;

/**
* @brief Run the MomentProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunMomentProcessor :: (handle: IrsIrCameraHandle, config: *IrsMomentProcessorConfig) -> Result #foreign libnx;

/**
* @brief Gets the states for MomentProcessor or IrLedProcessor.
* @note The official GetIrLedProcessorState is essentially the same as this, except it uses hard-coded count=1 with output-array on stack, without returning that data. Hence we don't implement a seperate func for that.
* @param[in] handle \ref IrsIrCameraHandle
* @param[out] states Output array of \ref IrsMomentProcessorState.
* @param[in] count Size of the states array in entries. Must be 1-5.
* @param[out] total_out Total output entries.
*/
irsGetMomentProcessorStates :: (handle: IrsIrCameraHandle, states: *IrsMomentProcessorState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Calculates an \ref IrsMomentStatistic from the specified region in the input \ref IrsMomentProcessorState.
* @param[in] state \ref IrsMomentProcessorState
* @param[in] rect \ref IrsRect, containing the image width and height.
* @param[in] region_x Region x, must be 0-5 (clamped to this range otherwise). region_x = image_x/6.
* @param[in] region_y Region y, must be 0-7 (clamped to this range otherwise). region_y = image_y/8.
* @param[in] region_width Region width. region_x+region_width must be <=6 (clamped to this range otherwise).
* @param[in] region_height Region height.  region_y+region_height must be <=8 (clamped to this range otherwise).
*/
irsCalculateMomentRegionStatistic :: (state: *IrsMomentProcessorState, rect: IrsRect, region_x: s32, region_y: s32, region_width: s32, region_height: s32) -> IrsMomentStatistic #foreign libnx;

/**
* @brief Run the ClusteringProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunClusteringProcessor :: (handle: IrsIrCameraHandle, config: *IrsClusteringProcessorConfig) -> Result #foreign libnx;

/**
* @brief Gets the states for ClusteringProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[out] states Output array of \ref IrsClusteringProcessorState.
* @param[in] count Size of the states array in entries. Must be 1-5.
* @param[out] total_out Total output entries.
*/
irsGetClusteringProcessorStates :: (handle: IrsIrCameraHandle, states: *IrsClusteringProcessorState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Run the ImageTransferProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
* @param[in] size Work-buffer size, must be 0x1000-byte aligned.
*/
irsRunImageTransferProcessor :: (handle: IrsIrCameraHandle, config: *IrsImageTransferProcessorConfig, size: u64) -> Result #foreign libnx;

/**
* @brief Run the ImageTransferExProcessor.
* @note Only available on [4.0.0+].
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
* @param[in] size Work-buffer size, must be 0x1000-byte aligned.
*/
irsRunImageTransferExProcessor :: (handle: IrsIrCameraHandle, config: *IrsImageTransferProcessorExConfig, size: u64) -> Result #foreign libnx;

/// GetImageTransferProcessorState
irsGetImageTransferProcessorState :: (handle: IrsIrCameraHandle, buffer: *void, size: u64, state: *IrsImageTransferProcessorState) -> Result #foreign libnx;

/**
* @brief Run the PointingProcessor.
* @param[in] handle \ref IrsIrCameraHandle
*/
irsRunPointingProcessor :: (handle: IrsIrCameraHandle) -> Result #foreign libnx;

/**
* @brief Gets the states for PointingProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[out] states Output array of \ref IrsPointingProcessorMarkerState.
* @param[in] count Size of the states array in entries. Must be 1-6.
* @param[out] total_out Total output entries.
*/
irsGetPointingProcessorMarkerStates :: (handle: IrsIrCameraHandle, states: *IrsPointingProcessorMarkerState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Gets the states for \ref IrsPointingProcessorState.
* @note This uses \ref irsGetPointingProcessorMarkerStates, then converts the output to \ref IrsPointingProcessorState.
* @param[in] handle \ref IrsIrCameraHandle
* @param[out] states Output array of \ref IrsPointingProcessorState.
* @param[in] count Size of the states array in entries. Must be 1-6.
* @param[out] total_out Total output entries.
*/
irsGetPointingProcessorStates :: (handle: IrsIrCameraHandle, states: *IrsPointingProcessorState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Run the TeraPluginProcessor.
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunTeraPluginProcessor :: (handle: IrsIrCameraHandle, config: *IrsTeraPluginProcessorConfig) -> Result #foreign libnx;

/**
* @brief Gets the states for TeraPluginProcessor, filtered using the input params.
* @param[in] handle \ref IrsIrCameraHandle
* @param[out] states Output array of \ref IrsTeraPluginProcessorState.
* @param[in] count Size of the states array in entries. Must be 1-5.
* @param[in] sampling_number Minimum value for IrsTeraPluginProcessorState::sampling_number.
* @param[in] prefix_data Only used when prefix_bitcount is not 0. The first prefix_bitcount bits from prefix_data must match the first prefix_bitcount bits in IrsTeraPluginProcessorState::plugin_data.
* @param[in] prefix_bitcount Total bits for prefix_data.
* @param[out] total_out Total output entries.
*/
irsGetTeraPluginProcessorStates :: (handle: IrsIrCameraHandle, states: *IrsTeraPluginProcessorState, count: s32, sampling_number: s64, prefix_data: u32, prefix_bitcount: u32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Run the IrLedProcessor.
* @note Only available on [4.0.0+].
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunIrLedProcessor :: (handle: IrsIrCameraHandle, config: *IrsIrLedProcessorConfig) -> Result #foreign libnx;

/**
* @brief Run the AdaptiveClusteringProcessor.
* @note Only available on [5.0.0+].
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunAdaptiveClusteringProcessor :: (handle: IrsIrCameraHandle, config: *IrsAdaptiveClusteringProcessorConfig) -> Result #foreign libnx;

/**
* @brief Run HandAnalysis.
* @param[in] handle \ref IrsIrCameraHandle
* @param[in] config Input config.
*/
irsRunHandAnalysis :: (handle: IrsIrCameraHandle, config: *IrsHandAnalysisConfig) -> Result #foreign libnx;

/**
* Gets the default configuration for MomentProcessor.
*/
irsGetMomentProcessorDefaultConfig :: (config: *IrsMomentProcessorConfig) -> void #foreign libnx;

/**
* Gets the default configuration for ClusteringProcessor.
*/
irsGetClusteringProcessorDefaultConfig :: (config: *IrsClusteringProcessorConfig) -> void #foreign libnx;

/**
* Gets the default configuration for ImageTransferProcessor.
* Defaults are exposure 300us, 8x digital gain, the rest is all-zero. Format is ::IrsImageTransferProcessorFormat_320x240.
*/
irsGetDefaultImageTransferProcessorConfig :: (config: *IrsImageTransferProcessorConfig) -> void #foreign libnx;

/**
* Gets the default configuration for ImageTransferProcessorEx.
* Defaults are exposure 300us, 8x digital gain, the rest is all-zero. OrigFormat/TrimmingFormat are ::IrsImageTransferProcessorFormat_320x240.
*/
irsGetDefaultImageTransferProcessorExConfig :: (config: *IrsImageTransferProcessorExConfig) -> void #foreign libnx;

PlServiceType :: enum u32 {
    User   :: 0;
    System :: 1;
}

/// SharedFontType
PlSharedFontType :: enum u32 {
    Standard             :: 0;
    ChineseSimplified    :: 1;
    ExtChineseSimplified :: 2;
    ChineseTraditional   :: 3;
    KO                   :: 4;
    NintendoExt          :: 5;
    Total                :: 6;
}

/// FontData
PlFontData :: struct {
    type:    u32; ///< \ref PlSharedFontType
    offset:  u32; ///< Offset of the font in sharedmem.
    size:    u32; ///< Size of the font.
    address: *void; ///< Address of the actual font.
}

/// Initialize pl.
plInitialize :: (service_type: PlServiceType) -> Result #foreign libnx;

/// Exit pl.
plExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pl service session.
plGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the address of the SharedMemory.
plGetSharedmemAddr :: () -> *void #foreign libnx;

plGetSharedFontByType :: (font: *PlFontData, SharedFontType: PlSharedFontType) -> Result #foreign libnx;

plGetSharedFont :: (LanguageCode: u64, fonts: *PlFontData, max_fonts: s32, total_fonts: *s32) -> Result #foreign libnx;

ViDisplayName :: struct {
    data: [64] u8;
}

ViDisplay :: struct {
    display_id:   u64;
    display_name: ViDisplayName;
    initialized:  bool;
}

ViServiceType :: enum s32 {
    Default     :: -1;
    Application :: 0;
    System      :: 1;
    Manager     :: 2;
}

/// Used by viCreateLayer when CreateStrayLayer is used internally.
ViLayerFlags :: enum u32 {
    Default :: 1;
}

/// Used with viSetLayerScalingMode.
ViScalingMode :: enum u32 {
    None                :: 0;
    FitToLayer          :: 2;
    PreserveAspectRatio :: 4;

    Default             :: 2;
}

/// Used with viSetDisplayPowerState.
ViPowerState :: enum u32 {
    Off           :: 0;
    NotScanning   :: 1;
    On            :: 2;

    On_Deprecated :: 1;
}

/// Used as argument to many capture functions.
ViLayerStack :: enum u32 {
    Default             :: 0;
    Lcd                 :: 1;
    Screenshot          :: 2;
    Recording           :: 3;
    LastFrame           :: 4;
    Arbitrary           :: 5;
    ApplicationForDebug :: 6;
    Null                :: 10;
}

/// Used as argument for certain drawing commands.
ViColorRgba4444 :: u16;
ViColorRgba8888 :: u32;

viInitialize :: (service_type: ViServiceType) -> Result #foreign libnx;
viExit :: () -> void #foreign libnx;

viGetSession_IApplicationDisplayService :: () -> *Service #foreign libnx;
viGetSession_IHOSBinderDriverRelay :: () -> *Service #foreign libnx;
viGetSession_ISystemDisplayService :: () -> *Service #foreign libnx;
viGetSession_IManagerDisplayService :: () -> *Service #foreign libnx;
viGetSession_IHOSBinderDriverIndirect :: () -> *Service #foreign libnx;

// Misc functions
viSetContentVisibility :: (v: bool) -> Result #foreign libnx;

// Display functions
viOpenDisplay :: (display_name: *u8, display: *ViDisplay) -> Result #foreign libnx;
viCloseDisplay :: (display: *ViDisplay) -> Result #foreign libnx;

viGetDisplayResolution :: (display: *ViDisplay, width: *s32, height: *s32) -> Result #foreign libnx;
viGetDisplayLogicalResolution :: (display: *ViDisplay, width: *s32, height: *s32) -> Result #foreign libnx;

/// Only available on [3.0.0+].
viSetDisplayMagnification :: (display: *ViDisplay, x: s32, y: s32, width: s32, height: s32) -> Result #foreign libnx;
viGetDisplayVsyncEvent :: (display: *ViDisplay, event_out: *Event) -> Result #foreign libnx;
viSetDisplayPowerState :: (display: *ViDisplay, state: ViPowerState) -> Result #foreign libnx;
viSetDisplayAlpha :: (display: *ViDisplay, alpha: float) -> Result #foreign libnx;
viGetZOrderCountMin :: (display: *ViDisplay, z: *s32) -> Result #foreign libnx;
viGetZOrderCountMax :: (display: *ViDisplay, z: *s32) -> Result #foreign libnx;

// Layer functions
viCreateLayer :: (display: *ViDisplay, layer: *ViLayer) -> Result #foreign libnx;
viCreateManagedLayer :: (display: *ViDisplay, layer_flags: ViLayerFlags, aruid: u64, layer_id: *u64) -> Result #foreign libnx;
viSetLayerSize :: (layer: *ViLayer, width: s32, height: s32) -> Result #foreign libnx;
viSetLayerZ :: (layer: *ViLayer, z: s32) -> Result #foreign libnx;
viSetLayerPosition :: (layer: *ViLayer, x: float, y: float) -> Result #foreign libnx;
viCloseLayer :: (layer: *ViLayer) -> Result #foreign libnx;
viDestroyManagedLayer :: (layer: *ViLayer) -> Result #foreign libnx;

viSetLayerScalingMode :: (layer: *ViLayer, scaling_mode: ViScalingMode) -> Result #foreign libnx;

// IndirectLayer functions
viGetIndirectLayerImageMap :: (buffer: *void, size: u64, width: s32, height: s32, IndirectLayerConsumerHandle: u64, out_size: *u64, out_stride: *u64) -> Result #foreign libnx;
viGetIndirectLayerImageRequiredMemoryInfo :: (width: s32, height: s32, out_size: *u64, out_alignment: *u64) -> Result #foreign libnx;

// Manager functions
viManagerPrepareFatal :: () -> Result #foreign libnx;
viManagerShowFatal :: () -> Result #foreign libnx;
viManagerDrawFatalRectangle :: (x: s32, y: s32, end_x: s32, end_y: s32, color: ViColorRgba4444) -> Result #foreign libnx;
viManagerDrawFatalText32 :: (out_advance: *s32, x: s32, y: s32, utf32_codepoints: *u32, num_codepoints: u64, scale_x: float, scale_y: float, font_type: PlSharedFontType, bg_color: ViColorRgba8888, fg_color: ViColorRgba8888, initial_advance: s32) -> Result #foreign libnx;

/// NvServiceType, for __nx_nv_service_type.
NvServiceType :: enum s32 {
    Auto        :: -1;
    Application :: 0;
    Applet      :: 1;
    System      :: 2;
    Factory     :: 3;
}

/// Initialize nvdrv*.
nvInitialize :: () -> Result #foreign libnx;

/// Exit nvdrv*.
nvExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual nvdrv* service session.
nvGetServiceSession :: () -> *Service #foreign libnx;

NvEventId :: enum u32 {
    Gpu_SmException_BptIntReport   :: 1;
    Gpu_SmException_BptPauseReport :: 2;
    Gpu_ErrorNotifier              :: 3;

    CtrlGpu_ErrorEventHandle       :: 1;
    CtrlGpu_Unknown                :: 2;
}

nvOpen :: (fd: *u32, devicepath: *u8) -> Result #foreign libnx;
nvIoctl :: (fd: u32, request: u32, argp: *void) -> Result #foreign libnx;
nvIoctl2 :: (fd: u32, request: u32, argp: *void, inbuf: *void, inbuf_size: u64) -> Result #foreign libnx;
nvIoctl3 :: (fd: u32, request: u32, argp: *void, outbuf: *void, outbuf_size: u64) -> Result #foreign libnx;
nvClose :: (fd: u32) -> Result #foreign libnx;
nvQueryEvent :: (fd: u32, event_id: u32, event_out: *Event) -> Result #foreign libnx;

nvConvertError :: (rc: s32) -> Result #foreign libnx;

NifmServiceType :: enum u32 {
    User   :: 0;
    System :: 1;
    Admin  :: 2;
}

NifmInternetConnectionType :: enum u32 {
    WiFi     :: 1;
    Ethernet :: 2;
}

NifmInternetConnectionStatus :: enum u32 {
    ConnectingUnknown1 :: 0;
    ConnectingUnknown2 :: 1;
    ConnectingUnknown3 :: 2;
    ConnectingUnknown4 :: 3;
    Connected          :: 4;
}

NifmRequestState :: enum u32 {
    Invalid   :: 0;
    Unknown1  :: 1;
    OnHold    :: 2;
    Available :: 3;
    Unknown4  :: 4;
    Unknown5  :: 5;
}

/// Request
NifmRequest :: struct {
    s:                   Service; ///< IRequest
    event_request_state: Event; ///< First Event from cmd GetSystemEventReadableHandles, autoclear=true. Signaled when the RequestState changes.
    event1:              Event; ///< Second Event from cmd GetSystemEventReadableHandles.

    request_state:       NifmRequestState; ///< \ref NifmRequestState from the GetRequestState cmd.
    res:                 Result; ///< Result from the GetResult cmd.
}

/// ClientId
NifmClientId :: struct {
    id: u32; ///< ClientId
}

/// IpV4Address
NifmIpV4Address :: struct {
    addr: [4] u8; ///< IPv4 address, aka struct in_addr.
}

/// IpAddressSetting
NifmIpAddressSetting :: struct {
    is_automatic: u8; ///< Whether this setting is automatic. Ignored by \ref nifmGetCurrentIpConfigInfo.

    current_addr: NifmIpV4Address; ///< Current address.
    subnet_mask:  NifmIpV4Address; ///< Subnet Mask.
    gateway:      NifmIpV4Address; ///< Gateway.
}

/// DnsSetting
NifmDnsSetting :: struct {
    is_automatic:         u8; ///< Whether this setting is automatic. Ignored by \ref nifmGetCurrentIpConfigInfo.

    primary_dns_server:   NifmIpV4Address; ///< Primary DNS server.
    secondary_dns_server: NifmIpV4Address; ///< Secondary DNS server.
}

/// ProxySetting
NifmProxySetting :: struct {
    enabled:           u8; ///< Enables using the proxy when set.
    pad:               u8; ///< Padding
    port:              u16; ///< Port
    server:            [100] u8; ///< Server string, NUL-terminated.
    auto_auth_enabled: u8; ///< Enables auto-authentication when set, which uses the following two strings.
    user:              [32] u8; ///< User string, NUL-terminated.
    password:          [32] u8; ///< Password string, NUL-terminated.
    pad2:              u8; ///< Padding
}

/// IpSettingData
NifmIpSettingData :: struct {
    ip_address_setting: NifmIpAddressSetting; ///< \ref NifmIpAddressSetting
    dns_setting:        NifmDnsSetting; ///< \ref NifmDnsSetting
    proxy_setting:      NifmProxySetting; ///< \ref NifmProxySetting
    mtu:                u16; ///< MTU
}

/// WirelessSettingData
NifmWirelessSettingData :: struct {
    ssid_len:   u8; ///< NifmSfWirelessSettingData::ssid_len
    ssid:       [33] u8; ///< NifmSfWirelessSettingData::ssid
    unk_x22:    u8; ///< NifmSfWirelessSettingData::unk_x21
    pad:        u8; ///< Padding
    unk_x24:    u32; ///< NifmSfWirelessSettingData::unk_x22
    unk_x28:    u32; ///< NifmSfWirelessSettingData::unk_x23
    passphrase: [65] u8; ///< NifmSfWirelessSettingData::passphrase
    pad2:       [3] u8; ///< Padding
}

/// SfWirelessSettingData
NifmSfWirelessSettingData :: struct {
    ssid_len:   u8; ///< SSID length.
    ssid:       [32] u8; ///< SSID string.
    unk_x21:    u8; ///< Unknown
    unk_x22:    u8; ///< Unknown
    unk_x23:    u8; ///< Unknown
    passphrase: [65] u8; ///< Passphrase
}

/// SfNetworkProfileData. Converted to/from \ref NifmNetworkProfileData.
NifmSfNetworkProfileData :: struct {
    ip_setting_data:       NifmIpSettingData; ///< \ref NifmIpSettingData
    uuid:                  Uuid; ///< Uuid
    network_name:          [64] u8; ///< NUL-terminated Network Name string.
    unk_x112:              u8; ///< Unknown
    unk_x113:              u8; ///< Unknown
    unk_x114:              u8; ///< Unknown
    unk_x115:              u8; ///< Unknown
    wireless_setting_data: NifmSfWirelessSettingData; ///< \ref NifmSfWirelessSettingData
    pad:                   u8; ///< Padding
}

/// NetworkProfileData. Converted from/to \ref NifmSfNetworkProfileData.
NifmNetworkProfileData :: struct {
    uuid:                  Uuid; ///< NifmSfNetworkProfileData::uuid
    network_name:          [64] u8; ///< NifmSfNetworkProfileData::network_name
    unk_x50:               u32; ///< NifmSfNetworkProfileData::unk_x112
    unk_x54:               u32; ///< NifmSfNetworkProfileData::unk_x113
    unk_x58:               u8; ///< NifmSfNetworkProfileData::unk_x114
    unk_x59:               u8; ///< NifmSfNetworkProfileData::unk_x115
    pad:                   [2] u8; ///< Padding
    wireless_setting_data: NifmWirelessSettingData; ///< \ref NifmWirelessSettingData
    ip_setting_data:       NifmIpSettingData; ///< \ref NifmIpSettingData
}

/// Initialize nifm. This is used automatically by gethostid().
nifmInitialize :: (service_type: NifmServiceType) -> Result #foreign libnx;

/// Exit nifm. This is used automatically by gethostid().
nifmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual nifm:* service session.
nifmGetServiceSession_StaticService :: () -> *Service #foreign libnx;

/// Gets the Service object for IGeneralService.
nifmGetServiceSession_GeneralService :: () -> *Service #foreign libnx;

/**
* @brief GetClientId
*/
nifmGetClientId :: () -> NifmClientId #foreign libnx;

/**
* @brief CreateRequest
* @param[out] r \ref NifmRequest
* @param[in] autoclear Event autoclear to use for NifmRequest::event1, a default of true can be used for this.
*/
nifmCreateRequest :: (r: *NifmRequest, autoclear: bool) -> Result #foreign libnx;

/**
* @brief GetCurrentNetworkProfile
* @param[out] profile \ref NifmNetworkProfileData
*/
nifmGetCurrentNetworkProfile :: (profile: *NifmNetworkProfileData) -> Result #foreign libnx;

/**
* @brief GetNetworkProfile
* @param[in] uuid Uuid
* @param[out] profile \ref NifmNetworkProfileData
*/
nifmGetNetworkProfile :: (uuid: Uuid, profile: *NifmNetworkProfileData) -> Result #foreign libnx;

/**
* @brief SetNetworkProfile
* @note Only available with ::NifmServiceType_Admin.
* @param[in] profile \ref NifmNetworkProfileData
* @param[out] uuid Uuid
*/
nifmSetNetworkProfile :: (profile: *NifmNetworkProfileData, uuid: *Uuid) -> Result #foreign libnx;

/**
* @brief GetCurrentIpAddress
* @param[out] out IPv4 address (struct in_addr).
*/
nifmGetCurrentIpAddress :: (out: *u32) -> Result #foreign libnx;

/**
* @brief GetCurrentIpConfigInfo
* @param[out] current_addr Same as \ref nifmGetCurrentIpAddress output.
* @param[out] subnet_mask Subnet Mask (struct in_addr).
* @param[out] gateway Gateway (struct in_addr).
* @param[out] primary_dns_server Primary DNS server IPv4 address (struct in_addr).
* @param[out] secondary_dns_server Secondary DNS server IPv4 address (struct in_addr).
*/
nifmGetCurrentIpConfigInfo :: (current_addr: *u32, subnet_mask: *u32, gateway: *u32, primary_dns_server: *u32, secondary_dns_server: *u32) -> Result #foreign libnx;

/**
* @note Works only if called from nifm:a or nifm:s.
*/
nifmSetWirelessCommunicationEnabled :: (enable: bool) -> Result #foreign libnx;

nifmIsWirelessCommunicationEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @note Will fail with 0xd46ed if Internet is neither connecting or connected (airplane mode or no known network in reach).
* @param wifiStrength Strength of the Wi-Fi signal in number of bars from 0 to 3.
*/
nifmGetInternetConnectionStatus :: (connectionType: *NifmInternetConnectionType, wifiStrength: *u32, connectionStatus: *NifmInternetConnectionStatus) -> Result #foreign libnx;

nifmIsEthernetCommunicationEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief IsAnyInternetRequestAccepted
* @param[in] id \ref NifmClientId
*/
nifmIsAnyInternetRequestAccepted :: (id: NifmClientId) -> bool #foreign libnx;

nifmIsAnyForegroundRequestAccepted :: (out: *bool) -> Result #foreign libnx;
nifmPutToSleep :: () -> Result #foreign libnx;
nifmWakeUp :: () -> Result #foreign libnx;

/**
* @brief SetWowlDelayedWakeTime
* @note Only available with ::NifmServiceType_System or ::NifmServiceType_Admin.
* @note Only available on [9.0.0+].
* @param[in] val Input value.
*/
nifmSetWowlDelayedWakeTime :: (val: s32) -> Result #foreign libnx;

/**
* @brief Close a \ref NifmRequest.
* @param r \ref NifmRequest
*/
nifmRequestClose :: (r: *NifmRequest) -> void #foreign libnx;

/**
* @brief GetRequestState
* @param r \ref NifmRequest
* @param[out] out \ref NifmRequestState
*/
nifmGetRequestState :: (r: *NifmRequest, out: *NifmRequestState) -> Result #foreign libnx;

/**
* @brief GetResult
* @param r \ref NifmRequest
*/
nifmGetResult :: (r: *NifmRequest) -> Result #foreign libnx;

/**
* @brief Cancel
* @param r \ref NifmRequest
*/
nifmRequestCancel :: (r: *NifmRequest) -> Result #foreign libnx;

/**
* @brief Submit
* @param r \ref NifmRequest
*/
nifmRequestSubmit :: (r: *NifmRequest) -> Result #foreign libnx;

/**
* @brief SubmitAndWait
* @param r \ref NifmRequest
*/
nifmRequestSubmitAndWait :: (r: *NifmRequest) -> Result #foreign libnx;

/**
* @brief GetAppletInfo
* @note This is used by \ref nifmLaHandleNetworkRequestResult.
* @param r \ref NifmRequest
* @param[in] theme_color ThemeColor
* @param[out] buffer Output buffer for storage data.
* @param[in] size Output buffer size.
* @param[out] applet_id \ref AppletId
* @param[out] mode \ref LibAppletMode
* @param[out] out_size Total data size written to the output buffer.
*/
nifmRequestGetAppletInfo :: (r: *NifmRequest, theme_color: u32, buffer: *void, size: u64, applet_id: *u32, mode: *u32, out_size: *u32) -> Result #foreign libnx;

/**
* @brief SetKeptInSleep
* @note Only available on [3.0.0+].
* @note ::NifmRequestState must be ::NifmRequestState_Unknown1.
* @param r \ref NifmRequest
* @param[in] flag Flag
*/
nifmRequestSetKeptInSleep :: (r: *NifmRequest, flag: bool) -> Result #foreign libnx;

/**
* @brief RegisterSocketDescriptor. Only 1 socket can be registered at a time with a NifmRequest. Do not use directly, use \ref socketNifmRequestRegisterSocketDescriptor instead.
* @note Only available on [3.0.0+].
* @note ::NifmRequestState must be ::NifmRequestState_Available.
* @param r \ref NifmRequest
* @param[in] sockfd Socket fd
*/
nifmRequestRegisterSocketDescriptor :: (r: *NifmRequest, sockfd: s32) -> Result #foreign libnx;

/**
* @brief UnregisterSocketDescriptor. Do not use directly, use \ref socketNifmRequestUnregisterSocketDescriptor instead.
* @note Only available on [3.0.0+].
* @note ::NifmRequestState must be ::NifmRequestState_Available.
* @param r \ref NifmRequest
* @param[in] sockfd Socket fd, must match the fd previously registered with \ref nifmRequestRegisterSocketDescriptor.
*/
nifmRequestUnregisterSocketDescriptor :: (r: *NifmRequest, sockfd: s32) -> Result #foreign libnx;

/// SystemUpdateTaskId
NimSystemUpdateTaskId :: struct {
    uuid: Uuid; ///< UUID
}

/// Initialize nim.
nimInitialize :: () -> Result #foreign libnx;

/// Exit nim.
nimExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual nim service session.
nimGetServiceSession :: () -> *Service #foreign libnx;

nimListSystemUpdateTask :: (out_count: *s32, out_task_ids: *NimSystemUpdateTaskId, max_task_ids: u64) -> Result #foreign libnx;
nimDestroySystemUpdateTask :: (task_id: *NimSystemUpdateTaskId) -> Result #foreign libnx;

/// ShellEvent
NsShellEvent :: enum u32 {
    None  :: 0;
    Exit  :: 1;
    Start :: 2;
    Crash :: 3;
    Debug :: 4;
}

/// ApplicationControlSource
NsApplicationControlSource :: enum u32 {
    CacheOnly   :: 0;
    Storage     :: 1;
    StorageOnly :: 2;
}

/// BackgroundNetworkUpdateState
NsBackgroundNetworkUpdateState :: enum u32 {
    None        :: 0;
    Downloading :: 1;
    Ready       :: 2;
}

/// LatestSystemUpdate
NsLatestSystemUpdate :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
    Unknown2 :: 2;
}

/// RequestServerStopper
NsRequestServerStopper :: struct {
    s: Service; ///< IRequestServerStopper
}

/// ProgressMonitorForDeleteUserSaveDataAll
NsProgressMonitorForDeleteUserSaveDataAll :: struct {
    s: Service; ///< IProgressMonitorForDeleteUserSaveDataAll
}

/// ProgressAsyncResult
NsProgressAsyncResult :: struct {
    s:     Service; ///< IProgressAsyncResult
    event: Event; ///< Event with autoclear=false.
}

/// SystemUpdateControl
NsSystemUpdateControl :: struct {
    s:    Service; ///< ISystemUpdateControl
    tmem: TransferMemory; ///< TransferMemory for SetupCardUpdate/SetupCardUpdateViaSystemUpdater.
}

/// ApplicationControlData
NsApplicationControlData :: struct {
    nacp: NacpStruct; ///< \ref NacpStruct
    icon: [131072] u8; ///< JPEG
}

/// ApplicationOccupiedSize
NsApplicationOccupiedSize :: struct {
    unk_x0: [128] u8; ///< Unknown.
}

/// NsApplicationContentMetaStatus
NsApplicationContentMetaStatus :: struct {
    meta_type:      u8; ///< \ref NcmContentMetaType
    storageID:      u8; ///< \ref NcmStorageId
    unk_x02:        u8; ///< Unknown.
    padding:        u8; ///< Padding.
    version:        u32; ///< Application version.
    application_id: u64; ///< ApplicationId.
}

/// ApplicationRecord
NsApplicationRecord :: struct {
    application_id: u64; ///< ApplicationId.
    type:           u8; ///< Type.
    unk_x09:        u8; ///< Unknown.
    unk_x0a:        [6] u8; ///< Unknown.
    unk_x10:        u8; ///< Unknown.
    unk_x11:        [7] u8; ///< Unknown.
}

/// ProgressForDeleteUserSaveDataAll
NsProgressForDeleteUserSaveDataAll :: struct {
    unk_x0: [40] u8; ///< Unknown.
}

/// ApplicationViewDeprecated. The below comments are for the \ref NsApplicationView to NsApplicationViewDeprecated conversion done by \ref nsGetApplicationViewDeprecated on newer system-versions.
NsApplicationViewDeprecated :: struct {
    application_id: u64; ///< Same as NsApplicationView::application_id.
    unk_x8:         [4] u8; ///< Same as NsApplicationView::unk_x8.
    flags:          u32; ///< Same as NsApplicationView::flags.
    unk_x10:        [16] u8; ///< Same as NsApplicationView::unk_x10.
    unk_x20:        u32; ///< Same as NsApplicationView::unk_x20.
    unk_x24:        u16; ///< Same as NsApplicationView::unk_x24.
    unk_x26:        [2] u8; ///< Cleared to zero.
    unk_x28:        [16] u8; ///< Same as NsApplicationView::unk_x30.
    unk_x38:        u32; ///< Same as NsApplicationView::unk_x40.
    unk_x3c:        u8; ///< Same as NsApplicationView::unk_x44.
    unk_x3d:        [3] u8; ///< Cleared to zero.
}

/// ApplicationView
NsApplicationView :: struct {
    application_id: u64; ///< ApplicationId.
    unk_x8:         [4] u8; ///< Unknown.
    flags:          u32; ///< Flags.
    unk_x10:        [16] u8; ///< Unknown.
    unk_x20:        u32; ///< Unknown.
    unk_x24:        u16; ///< Unknown.
    unk_x26:        [2] u8; ///< Unknown.
    unk_x28:        [8] u8; ///< Unknown.
    unk_x30:        [16] u8; ///< Unknown.
    unk_x40:        u32; ///< Unknown.
    unk_x44:        u8; ///< Unknown.
    unk_x45:        [11] u8; ///< Unknown.
}

/// NsPromotionInfo
NsPromotionInfo :: struct {
    start_timestamp: u64; ///< POSIX timestamp for the promotion start.
    end_timestamp:   u64; ///< POSIX timestamp for the promotion end.
    remaining_time:  s64; ///< Remaining time until the promotion ends, in nanoseconds ({end_timestamp - current_time} converted to nanoseconds).
    unk_x18:         [4] u8; ///< Not set, left at zero.
    flags:           u8; ///< Flags. Bit0: whether the PromotionInfo is valid (including bit1). Bit1 clear: remaining_time is set.
    pad:             [3] u8; ///< Padding.
}

/// NsApplicationViewWithPromotionInfo
NsApplicationViewWithPromotionInfo :: struct {
    view:      NsApplicationView; ///< \ref NsApplicationView
    promotion: NsPromotionInfo; ///< \ref NsPromotionInfo
}

/// LaunchProperties
NsLaunchProperties :: struct {
    program_id:     u64; ///< program_id.
    version:        u32; ///< Program version.
    storageID:      u8; ///< \ref NcmStorageId
    index:          u8; ///< Index.
    is_application: u8; ///< Whether this is an Application.
}

/// ShellEventInfo
NsShellEventInfo :: struct {
    event:      NsShellEvent; ///< \ref NsShellEvent
    process_id: u64; ///< processID.
}

/// SystemUpdateProgress. Commands which have this as output will return 0 with the output cleared, when no task is available.
NsSystemUpdateProgress :: struct {
    current_size: s64; ///< Current size. This value can be larger than total_size when the async operation is finishing. When total_size is <=0, this current_size field may contain a progress value for when the total_size is not yet determined.
    total_size:   s64; ///< Total size, this field is only valid when >0.
}

/// ReceiveApplicationProgress. Same as \ref NsSystemUpdateProgress, except cmds which return this will return actual errors on failure, instead of returning 0 with a cleared struct.
NsReceiveApplicationProgress :: NsSystemUpdateProgress;

/// SendApplicationProgress. Same as \ref NsSystemUpdateProgress, except cmds which return this will return actual errors on failure, instead of returning 0 with a cleared struct.
NsSendApplicationProgress :: NsSystemUpdateProgress;

/// EulaDataPath
NsEulaDataPath :: struct {
    path: [256] u8; ///< Path.
}

/// SystemDeliveryInfo
NsSystemDeliveryInfo :: struct {
    data: struct {
        system_delivery_protocol_version:      u32; ///< Must match a system-setting.
        application_delivery_protocol_version: u32; ///< Loaded from a system-setting. Unused by \ref nssuRequestSendSystemUpdate / \ref nssuControlRequestReceiveSystemUpdate, besides HMAC validation.
        includes_exfat:                        u32; ///< Whether ExFat is included. Unused by \ref nssuRequestSendSystemUpdate / \ref nssuControlRequestReceiveSystemUpdate, besides HMAC validation.
        system_update_meta_version:            u32; ///< SystemUpdate meta version.
        system_update_meta_id:                 u64; ///< SystemUpdate meta Id.
        unk_x18:                               u8; ///< Copied into state by \ref nssuRequestSendSystemUpdate.
        unk_x19:                               u8; ///< Unused by \ref nssuRequestSendSystemUpdate / \ref nssuControlRequestReceiveSystemUpdate, besides HMAC validation.
        unk_x1a:                               u8; ///< Unknown.
        unk_x1b:                               [197] u8; ///< Unused by \ref nssuRequestSendSystemUpdate / \ref nssuControlRequestReceiveSystemUpdate, besides HMAC validation.
    }; ///< Data used with the below hmac.

    hmac: [32] u8; ///< HMAC-SHA256 over the above data.
}

/// ApplicationDeliveryInfo
NsApplicationDeliveryInfo :: struct {
    data: struct {
        unk_x0:                  [16] u8; ///< Unknown.
        application_version:     u32; ///< Application version.
        unk_x14:                 u32; ///< Unknown.
        required_system_version: u32; ///< Required system version, see NsSystemDeliveryInfo::system_update_meta_version.
        unk_x1c:                 u32; ///< Unknown.
        unk_x20:                 [192] u8; ///< Unknown.
    }; ///< Data used with the below hmac.

    hmac: [32] u8; ///< HMAC-SHA256 over the above data.
}

/// NsApplicationRightsOnClient
NsApplicationRightsOnClient :: struct {
    application_id: u64; ///< ApplicationId.
    uid:            AccountUid; ///< \ref AccountUid
    flags_x18:      u8; ///< qlaunch uses bit0-bit4 and bit7 from here.
    flags_x19:      u8; ///< qlaunch uses bit0 from here.
    unk_x1a:        [6] u8; ///< Unknown.
}

/// DownloadTaskStatus
NsDownloadTaskStatus :: struct {
    unk_x0: [32] u8; ///< Unknown.
}

/// Initialize ns services. Uses ns:am on pre-3.0.0, ns:am2 on [3.0.0+].
nsInitialize :: () -> Result #foreign libnx;

/// Exit ns services.
nsExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ns:* service session. Only initialized on [3.0.0+], on pre-3.0.0 see \ref nsGetServiceSession_ApplicationManagerInterface.
nsGetServiceSession_GetterInterface :: () -> *Service #foreign libnx;

/// Gets the Service object for IApplicationManagerInterface. Only initialized on pre-3.0.0, on [3.0.0+] use \ref nsGetApplicationManagerInterface.
nsGetServiceSession_ApplicationManagerInterface :: () -> *Service #foreign libnx;

/// Gets the Service object for IDynamicRightsInterface via the cmd for that.
/// Only available on [6.0.0+].
nsGetDynamicRightsInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IReadOnlyApplicationControlDataInterface via the cmd for that.
/// Only available on [5.1.0+].
nsGetReadOnlyApplicationControlDataInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IReadOnlyApplicationRecordInterface via the cmd for that.
/// Only available on [5.0.0+].
nsGetReadOnlyApplicationRecordInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IECommerceInterface via the cmd for that.
/// Only available on [4.0.0+].
nsGetECommerceInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IApplicationVersionInterface via the cmd for that.
/// Only available on [4.0.0+].
nsGetApplicationVersionInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IFactoryResetInterface via the cmd for that.
/// Only available on [3.0.0+].
nsGetFactoryResetInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IAccountProxyInterface via the cmd for that.
/// Only available on [3.0.0+].
nsGetAccountProxyInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IApplicationManagerInterface via the cmd for that.
/// Only available on [3.0.0+], on prior sysvers use \ref nsGetServiceSession_ApplicationManagerInterface.
nsGetApplicationManagerInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IDownloadTaskInterface via the cmd for that.
/// Only available on [3.0.0+].
nsGetDownloadTaskInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IContentManagementInterface via the cmd for that.
/// Only available on [3.0.0+].
nsGetContentManagementInterface :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IDocumentInterface via the cmd for that.
/// Only available on [3.0.0+].
nsGetDocumentInterface :: (srv_out: *Service) -> Result #foreign libnx;

/**
* @brief Gets the \ref NsApplicationControlData for the specified application.
* @note Uses \ref nsGetReadOnlyApplicationControlDataInterface on [5.1.0+], otherwise IApplicationManagerInterface is used.
* @param[in] source Source, official sw uses ::NsApplicationControlSource_Storage.
* @param[in] application_id ApplicationId.
* @param[out] buffer \ref NsApplicationControlData
* @param[in] size Size of the buffer.
* @param[out] actual_size Actual output size.
*/
nsGetApplicationControlData :: (source: NsApplicationControlSource, application_id: u64, buffer: *NsApplicationControlData, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief GetApplicationDesiredLanguage. Selects a \ref NacpLanguageEntry to use from the specified \ref NacpStruct.
* @note Uses \ref nsGetReadOnlyApplicationControlDataInterface on [5.1.0+], otherwise IApplicationManagerInterface is used.
* @param[in] nacp \ref NacpStruct
* @param[out] langentry \ref NacpLanguageEntry
*/
nsGetApplicationDesiredLanguage :: (nacp: *NacpStruct, langentry: **NacpLanguageEntry) -> Result #foreign libnx;

/**
* @brief RequestLinkDevice
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] uid \ref AccountUid
*/
nsRequestLinkDevice :: (a: *AsyncResult, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief RequestSyncRights
* @note Only available on [6.0.0+].
* @param[out] a \ref AsyncResult
*/
nsRequestSyncRights :: (a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief RequestUnlinkDevice
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [6.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] uid \ref AccountUid
*/
nsRequestUnlinkDevice :: (a: *AsyncResult, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief ResetToFactorySettings
* @note Uses \ref nsGetFactoryResetInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
*/
nsResetToFactorySettings :: () -> Result #foreign libnx;

/**
* @brief ResetToFactorySettingsWithoutUserSaveData
* @note Uses \ref nsGetFactoryResetInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
*/
nsResetToFactorySettingsWithoutUserSaveData :: () -> Result #foreign libnx;

/**
* @brief ResetToFactorySettingsForRefurbishment
* @note Uses \ref nsGetFactoryResetInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
*/
nsResetToFactorySettingsForRefurbishment :: () -> Result #foreign libnx;

/**
* @brief ResetToFactorySettingsWithPlatformRegion
* @note Only available on [9.1.0+].
*/
nsResetToFactorySettingsWithPlatformRegion :: () -> Result #foreign libnx;

/**
* @brief ResetToFactorySettingsWithPlatformRegionAuthentication
* @note Only available on [9.1.0+].
*/
nsResetToFactorySettingsWithPlatformRegionAuthentication :: () -> Result #foreign libnx;

/**
* @brief Gets an listing of \ref NsApplicationRecord.
* @param[out] records Output array of \ref NsApplicationRecord.
* @param[in] count Size of the records array in entries.
* @param[in] entry_offset Starting entry offset.
* @param[out] out_entrycount Total output entries.
*/
nsListApplicationRecord :: (records: *NsApplicationRecord, count: s32, entry_offset: s32, out_entrycount: *s32) -> Result #foreign libnx;

/**
* @brief GetApplicationRecordUpdateSystemEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
nsGetApplicationRecordUpdateSystemEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetApplicationViewDeprecated
* @note On [3.0.0+] you should generally use \ref nsGetApplicationView instead.
* @param[out] out Output array of \ref NsApplicationViewDeprecated.
* @param[in] application_ids Input array of ApplicationIds.
* @param[in] count Size of the input/output arrays in entries.
*/
nsGetApplicationViewDeprecated :: (views: *NsApplicationViewDeprecated, application_ids: *u64, count: s32) -> Result #foreign libnx;

/**
* @brief DeleteApplicationEntity
* @param[in] application_id ApplicationId.
*/
nsDeleteApplicationEntity :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief DeleteApplicationCompletely
* @param[in] application_id ApplicationId.
*/
nsDeleteApplicationCompletely :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief DeleteRedundantApplicationEntity
*/
nsDeleteRedundantApplicationEntity :: () -> Result #foreign libnx;

/**
* @brief IsApplicationEntityMovable
* @param[in] application_id ApplicationId.
* @param[in] storage_id \ref NcmStorageId
* @param[out] out Output flag.
*/
nsIsApplicationEntityMovable :: (application_id: u64, storage_id: NcmStorageId, out: *bool) -> Result #foreign libnx;

/**
* @brief MoveApplicationEntity
* @note Only available on [1.0.0-9.2.0].
* @param[in] application_id ApplicationId.
* @param[in] storage_id \ref NcmStorageId
*/
nsMoveApplicationEntity :: (application_id: u64, storage_id: NcmStorageId) -> Result #foreign libnx;

/**
* @brief RequestApplicationUpdateInfo
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @param[out] a \ref AsyncValue. The data that can be read from this is u8 ApplicationUpdateInfo. qlaunch just checks whether this is 0.
* @param application_id ApplicationId.
*/
nsRequestApplicationUpdateInfo :: (a: *AsyncValue, application_id: u64) -> Result #foreign libnx;

/**
* @brief CancelApplicationDownload
* @param[in] application_id ApplicationId.
*/
nsCancelApplicationDownload :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief ResumeApplicationDownload
* @param[in] application_id ApplicationId.
*/
nsResumeApplicationDownload :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief CheckApplicationLaunchVersion
* @param[in] application_id ApplicationId.
*/
nsCheckApplicationLaunchVersion :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief CalculateApplicationApplyDeltaRequiredSize
* @param[in] application_id ApplicationId.
* @param[out] storage_id Output \ref NcmStorageId.
* @param[out] size Output size.
*/
nsCalculateApplicationDownloadRequiredSize :: (application_id: u64, storage_id: *NcmStorageId, size: *s64) -> Result #foreign libnx;

/**
* @brief CleanupSdCard
*/
nsCleanupSdCard :: () -> Result #foreign libnx;

/**
* @brief GetSdCardMountStatusChangedEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
nsGetSdCardMountStatusChangedEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetGameCardUpdateDetectionEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
nsGetGameCardUpdateDetectionEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief DisableApplicationAutoDelete
* @param[in] application_id ApplicationId.
*/
nsDisableApplicationAutoDelete :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief EnableApplicationAutoDelete
* @param[in] application_id ApplicationId.
*/
nsEnableApplicationAutoDelete :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief SetApplicationTerminateResult
* @param[in] application_id ApplicationId.
* @param[in] res Result.
*/
nsSetApplicationTerminateResult :: (application_id: u64, res: Result) -> Result #foreign libnx;

/**
* @brief ClearApplicationTerminateResult
* @param[in] application_id ApplicationId.
*/
nsClearApplicationTerminateResult :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief GetLastSdCardMountUnexpectedResult
*/
nsGetLastSdCardMountUnexpectedResult :: () -> Result #foreign libnx;

/**
* @brief Opens a \ref NsRequestServerStopper.
* @note Only available on [2.0.0+].
* @param[out] r \ref NsRequestServerStopper
*/
nsGetRequestServerStopper :: (r: *NsRequestServerStopper) -> Result #foreign libnx;

/**
* @brief CancelApplicationApplyDelta
* @note Only available on [3.0.0+].
* @param[in] application_id ApplicationId.
*/
nsCancelApplicationApplyDelta :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief ResumeApplicationApplyDelta
* @note Only available on [3.0.0+].
* @param[in] application_id ApplicationId.
*/
nsResumeApplicationApplyDelta :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief CalculateApplicationApplyDeltaRequiredSize
* @note Only available on [3.0.0+].
* @param[in] application_id ApplicationId.
* @param[out] storage_id Output \ref NcmStorageId.
* @param[out] size Output size.
*/
nsCalculateApplicationApplyDeltaRequiredSize :: (application_id: u64, storage_id: *NcmStorageId, size: *s64) -> Result #foreign libnx;

/**
* @brief ResumeAll
* @note Only available on [3.0.0+].
*/
nsResumeAll :: () -> Result #foreign libnx;

/**
* @brief Temporarily mounts the specified fs ContentStorage, then uses fs GetTotalSpaceSize/GetFreeSpaceSize with that mounted ContentStorage.
* @note Only available on [3.0.0+].
* @param[in] storage_id \ref NcmStorageId, must be ::NcmStorageId_BuiltInUser or ::NcmStorageId_SdCard.
* @param[out] total_space_size Output from GetTotalSpaceSize.
* @param[out] free_space_size Output from GetFreeSpaceSize.
*/
nsGetStorageSize :: (storage_id: NcmStorageId, total_space_size: *s64, free_space_size: *s64) -> Result #foreign libnx;

/**
* @brief RequestUpdateApplication2
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] application_id ApplicationId.
*/
nsRequestUpdateApplication2 :: (a: *AsyncResult, application_id: u64) -> Result #foreign libnx;

/**
* @brief DeleteUserSaveDataAll
* @param[in] p \ref NsProgressMonitorForDeleteUserSaveDataAll
* @param[in] uid \ref AccountUid
*/
nsDeleteUserSaveDataAll :: (p: *NsProgressMonitorForDeleteUserSaveDataAll, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief DeleteUserSystemSaveData
* @param[in] uid \ref AccountUid
* @param[in] system_save_data_id SystemSaveDataId
*/
nsDeleteUserSystemSaveData :: (uid: AccountUid, system_save_data_id: u64) -> Result #foreign libnx;

/**
* @brief DeleteSaveData
* @note Only available on [6.0.0+].
* @param[in] save_data_space_id \ref FsSaveDataSpaceId
* @param[in] save_data_id SaveDataId
*/
nsDeleteSaveData :: (save_data_space_id: FsSaveDataSpaceId, save_data_id: u64) -> Result #foreign libnx;

/**
* @brief UnregisterNetworkServiceAccount
* @param[in] uid \ref AccountUid
*/
nsUnregisterNetworkServiceAccount :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief UnregisterNetworkServiceAccountWithUserSaveDataDeletion
* @note Only available on [6.0.0+].
* @param[in] uid \ref AccountUid
*/
nsUnregisterNetworkServiceAccountWithUserSaveDataDeletion :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief RequestDownloadApplicationControlData
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @param[out] a \ref AsyncResult
* @param[in] application_id ApplicationId.
*/
nsRequestDownloadApplicationControlData :: (a: *AsyncResult, application_id: u64) -> Result #foreign libnx;

/**
* @brief ListApplicationTitle
* @note The data available with \ref asyncValueGet is a s32 for the offset within the buffer where the output data is located, \ref asyncValueGetSize returns the total byte-size of the data located here. The data located here is the \ref NacpLanguageEntry for each specified ApplicationId.
* @note Only available on [8.0.0+].
* @param[out] a \ref AsyncValue
* @param[in] source Source, qlaunch uses ::NsApplicationControlSource_Storage.
* @param[in] application_ids Input array of ApplicationIds.
* @param[in] count Size of the application_ids array in entries.
* @param buffer 0x1000-byte aligned buffer for TransferMemory. This buffer must not be accessed until the async operation finishes.
* @param[in] size 0x1000-byte aligned buffer size for TransferMemory. This must be at least: count*sizeof(\ref NacpLanguageEntry) + count*sizeof(u64) + count*sizeof(\ref NsApplicationControlData).
*/
nsListApplicationTitle :: (a: *AsyncValue, source: NsApplicationControlSource, application_ids: *u64, count: s32, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief ListApplicationIcon
* @note The data available with \ref asyncValueGet is a s32 for the offset within the buffer where the output data is located, \ref asyncValueGetSize returns the total byte-size of the data located here. This data is: an u64 for total entries, an array of u64s for each icon size, then the icon JPEGs for the specified ApplicationIds.
* @note Only available on [8.0.0+].
* @param[out] a \ref AsyncValue
* @param[in] source Source.
* @param[in] application_ids Input array of ApplicationIds.
* @param[in] count Size of the application_ids array in entries.
* @param buffer 0x1000-byte aligned buffer for TransferMemory. This buffer must not be accessed until the async operation finishes.
* @param[in] size 0x1000-byte aligned buffer size for TransferMemory. This must be at least: 0x4 + count*sizeof(u64) + count*sizeof(\ref NsApplicationControlData::icon) + count*sizeof(u64) + sizeof(\ref NsApplicationControlData).
*/
nsListApplicationIcon :: (a: *AsyncValue, source: NsApplicationControlSource, application_ids: *u64, count: s32, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief RequestCheckGameCardRegistration
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [2.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] application_id ApplicationId.
*/
nsRequestCheckGameCardRegistration :: (a: *AsyncResult, application_id: u64) -> Result #foreign libnx;

/**
* @brief RequestGameCardRegistrationGoldPoint
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [2.0.0+].
* @param[out] a \ref AsyncValue. The data that can be read from this is 4-bytes.
* @param[in] uid \ref AccountUid
* @param[in] application_id ApplicationId.
*/
nsRequestGameCardRegistrationGoldPoint :: (a: *AsyncValue, uid: AccountUid, application_id: u64) -> Result #foreign libnx;

/**
* @brief RequestRegisterGameCard
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [2.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] uid \ref AccountUid
* @param[in] application_id ApplicationId.
* @param[in] inval Input value.
*/
nsRequestRegisterGameCard :: (a: *AsyncResult, uid: AccountUid, application_id: u64, inval: s32) -> Result #foreign libnx;

/**
* @brief GetGameCardMountFailureEvent
* @note The Event must be closed by the user once finished with it.
* @note Only available on [3.0.0+].
* @param[out] out_event Output Event with autoclear=false.
*/
nsGetGameCardMountFailureEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief IsGameCardInserted
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
nsIsGameCardInserted :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EnsureGameCardAccess
* @note Only available on [3.0.0+].
*/
nsEnsureGameCardAccess :: () -> Result #foreign libnx;

/**
* @brief GetLastGameCardMountFailureResult
* @note Only available on [3.0.0+].
*/
nsGetLastGameCardMountFailureResult :: () -> Result #foreign libnx;

/**
* @brief ListApplicationIdOnGameCard
* @note Only available on [5.0.0+].
* @param[out] application_ids Output array of ApplicationIds.
* @param[in] count Size of the application_ids array in entries.
* @param[out] total_out Total output entries.
*/
nsListApplicationIdOnGameCard :: (application_ids: *u64, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief TouchApplication
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
*/
nsTouchApplication :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief IsApplicationUpdateRequested
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
* @param[out] flag Output flag, indicating whether out is valid.
* @param[out] out Output value.
*/
nsIsApplicationUpdateRequested :: (application_id: u64, flag: *bool, out: *u32) -> Result #foreign libnx;

/**
* @brief WithdrawApplicationUpdateRequest
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
*/
nsWithdrawApplicationUpdateRequest :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief RequestVerifyAddOnContentsRights
* @note Only available on [3.0.0-9.2.0].
* @param[out] a \ref NsProgressAsyncResult
* @param[in] application_id ApplicationId.
*/
nsRequestVerifyAddOnContentsRights :: (a: *NsProgressAsyncResult, application_id: u64) -> Result #foreign libnx;

/**
* @brief RequestVerifyApplication
* @note On pre-5.0.0 this uses cmd RequestVerifyApplicationDeprecated, otherwise cmd RequestVerifyApplication is used.
* @param[out] a \ref NsProgressAsyncResult. The data available with \ref nsProgressAsyncResultGetProgress is basically the same as \ref NsSystemUpdateProgress.
* @param[in] application_id ApplicationId.
* @param[in] unk Unknown. A default value of 0x7 can be used (which is what qlaunch uses). Only used on [5.0.0+].
* @param buffer 0x1000-byte aligned buffer for TransferMemory. This buffer must not be accessed until the async operation finishes.
* @param[in] size 0x1000-byte aligned buffer size for TransferMemory. qlaunch uses size 0x100000.
*/
nsRequestVerifyApplication :: (a: *NsProgressAsyncResult, application_id: u64, unk: u32, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief IsAnyApplicationEntityInstalled
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
* @param[out] out Output flag.
*/
nsIsAnyApplicationEntityInstalled :: (application_id: u64, out: *bool) -> Result #foreign libnx;

/**
* @brief CleanupUnavailableAddOnContents
* @note Only available on [6.0.0+].
* @param[in] application_id ApplicationId.
* @param[in] uid \ref AccountUid
*/
nsCleanupUnavailableAddOnContents :: (application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief EstimateSizeToMove
* @note Only available on [10.0.0+].
* @param[in] storage_ids Array of u8 \ref NcmStorageId.
* @param[in] count Size of the storage_ids array in entries.
* @param[in] storage_id storage_id \ref NcmStorageId
* @param[in] flags Flags
* @param[in] application_id ApplicationId.
* @param[out] Out Output value.
*/
nsEstimateSizeToMove :: (storage_ids: *u8, count: s32, storage_id: NcmStorageId, flags: u32, application_id: u64, out: *s64) -> Result #foreign libnx;

/**
* @brief FormatSdCard
* @note Only available on [2.0.0+].
*/
nsFormatSdCard :: () -> Result #foreign libnx;

/**
* @brief NeedsSystemUpdateToFormatSdCard
* @note Only available on [2.0.0+].
* @param[out] out Output flag.
*/
nsNeedsSystemUpdateToFormatSdCard :: (out: *bool) -> Result #foreign libnx;

/**
* @brief GetLastSdCardFormatUnexpectedResult
* @note Only available on [2.0.0+].
*/
nsGetLastSdCardFormatUnexpectedResult :: () -> Result #foreign libnx;

/**
* @brief GetApplicationView
* @note Only available on [3.0.0+], on prior system-versions use \ref nsGetApplicationViewDeprecated instead.
* @param[out] out Output array of \ref NsApplicationView.
* @param[in] application_ids Input array of ApplicationIds.
* @param[in] count Size of the input/output arrays in entries.
*/
nsGetApplicationView :: (views: *NsApplicationView, application_ids: *u64, count: s32) -> Result #foreign libnx;

/**
* @brief GetApplicationViewDownloadErrorContext
* @note Only available on [4.0.0+].
* @param[in] application_id ApplicationId
* @param[out] context \ref ErrorContext
*/
nsGetApplicationViewDownloadErrorContext :: (application_id: u64, _context: *ErrorContext) -> Result #foreign libnx;

/**
* @brief GetApplicationViewWithPromotionInfo
* @note Only available on [8.0.0+].
* @param[out] out Output array of \ref NsApplicationViewWithPromotionInfo.
* @param[in] application_ids Input array of ApplicationIds.
* @param[in] count Size of the input/output arrays in entries.
*/
nsGetApplicationViewWithPromotionInfo :: (out: *NsApplicationViewWithPromotionInfo, application_ids: *u64, count: s32) -> Result #foreign libnx;

/**
* @brief RequestDownloadApplicationPrepurchasedRights
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] application_id ApplicationId.
*/
nsRequestDownloadApplicationPrepurchasedRights :: (a: *AsyncResult, application_id: u64) -> Result #foreign libnx;

/**
* @brief Generates a \ref NsSystemDeliveryInfo using the currently installed SystemUpdate meta.
* @note Only available on [4.0.0+].
* @param[out] info \ref NsSystemDeliveryInfo
*/
nsGetSystemDeliveryInfo :: (info: *NsSystemDeliveryInfo) -> Result #foreign libnx;

/**
* @brief SelectLatestSystemDeliveryInfo
* @note This selects the \ref NsSystemDeliveryInfo with the latest version from sys_list, using minimum versions determined from app_list/state and base_info. This also does various validation, etc.
* @note Only available on [4.0.0+].
* @param[in] sys_list Input array of \ref NsSystemDeliveryInfo.
* @param[in] sys_count Size of the sys_list array in entries.
* @param[in] base_info \ref NsSystemDeliveryInfo
* @param[in] app_list Input array of \ref NsApplicationDeliveryInfo. This can be NULL.
* @param[in] app_count Size of the app_list array in entries. This can be 0.
* @param[out] index Output index for the selected entry in sys_list, -1 if none found.
*/
nsSelectLatestSystemDeliveryInfo :: (sys_list: *NsSystemDeliveryInfo, sys_count: s32, base_info: *NsSystemDeliveryInfo, app_list: *NsApplicationDeliveryInfo, app_count: s32, index: *s32) -> Result #foreign libnx;

/**
* @brief VerifyDeliveryProtocolVersion
* @note Only available on [4.0.0+].
* @param[in] info \ref NsSystemDeliveryInfo
*/
nsVerifyDeliveryProtocolVersion :: (info: *NsSystemDeliveryInfo) -> Result #foreign libnx;

/**
* @brief Generates \ref NsApplicationDeliveryInfo for the specified ApplicationId.
* @note Only available on [4.0.0+].
* @param[out] info Output array of \ref NsApplicationDeliveryInfo.
* @param[in] count Size of the array in entries.
* @param[in] application_id ApplicationId
* @param[in] attr ApplicationDeliveryAttributeTag bitmask.
* @param[out] total_out Total output entries.
*/
nsGetApplicationDeliveryInfo :: (info: *NsApplicationDeliveryInfo, count: s32, application_id: u64, attr: u32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief HasAllContentsToDeliver
* @note Only available on [4.0.0+].
* @param[in] info Input array of \ref NsApplicationDeliveryInfo.
* @param[in] count Size of the array in entries. Must be value 1.
* @param[out] out Output flag.
*/
nsHasAllContentsToDeliver :: (info: *NsApplicationDeliveryInfo, count: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief Both \ref NsApplicationDeliveryInfo are validated, then the application_version in the first/second \ref NsApplicationDeliveryInfo are compared.
* @note Only available on [4.0.0+].
* @param[in] info0 First input array of \ref NsApplicationDeliveryInfo.
* @param[in] count0 Size of the info0 array in entries. Must be value 1.
* @param[in] info1 Second input array of \ref NsApplicationDeliveryInfo.
* @param[in] count1 Size of the info1 array in entries. Must be value 1.
* @param[out] out Comparison result: -1 for less than, 0 for equal, and 1 for higher than.
*/
nsCompareApplicationDeliveryInfo :: (info0: *NsApplicationDeliveryInfo, count0: s32, info1: *NsApplicationDeliveryInfo, count1: s32, out: *s32) -> Result #foreign libnx;

/**
* @brief CanDeliverApplication
* @note Only available on [4.0.0+].
* @param[in] info0 First input array of \ref NsApplicationDeliveryInfo.
* @param[in] count0 Size of the info0 array in entries. Must be value <=1, when 0 this will return 0 with out set to 0.
* @param[in] info1 Second input array of \ref NsApplicationDeliveryInfo.
* @param[in] count1 Size of the info1 array in entries. Must be value 1.
* @param[out] out Output flag.
*/
nsCanDeliverApplication :: (info0: *NsApplicationDeliveryInfo, count0: s32, info1: *NsApplicationDeliveryInfo, count1: s32, out: *bool) -> Result #foreign libnx;

/**
* @brief ListContentMetaKeyToDeliverApplication
* @note Only available on [4.0.0+].
* @param[out] meta Output array of \ref NcmContentMetaKey.
* @param[in] meta_count Size of the meta array in entries. Must be at least 1, only 1 entry will be returned.
* @param[in] meta_index Meta entry index. An output \ref NcmContentMetaKey will not be returned when this value is larger than 0.
* @param[in] info Input array of \ref NsApplicationDeliveryInfo.
* @param[in] info_count Size of the info array in entries. Must be value 1.
* @param[out] total_out Total output entries.
*/
nsListContentMetaKeyToDeliverApplication :: (meta: *NcmContentMetaKey, meta_count: s32, meta_index: s32, info: *NsApplicationDeliveryInfo, info_count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief After validation etc, this sets the output bool by comparing system-version fields in the \ref NsSystemDeliveryInfo / info-array and with a state field.
* @note Only available on [4.0.0+].
* @param[in] info Input array of \ref NsApplicationDeliveryInfo.
* @param[in] count Size of the info array in entries. Must be value 1.
* @param[in] sys_info \ref NsSystemDeliveryInfo
* @param[out] out Output flag.
*/
nsNeedsSystemUpdateToDeliverApplication :: (info: *NsApplicationDeliveryInfo, count: s32, sys_info: *NsSystemDeliveryInfo, out: *bool) -> Result #foreign libnx;

/**
* @brief EstimateRequiredSize
* @note Only available on [4.0.0+].
* @param[in] meta Input array of \ref NcmContentMetaKey.
* @param[in] count Size of the meta array in entries. When less than 1, this will return 0 with out set to 0.
* @param[out] out Output size.
*/
nsEstimateRequiredSize :: (meta: *NcmContentMetaKey, count: s32, out: *s64) -> Result #foreign libnx;

/**
* @brief RequestReceiveApplication
* @note This is the Application version of \ref nssuControlRequestReceiveSystemUpdate, see the notes for that.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] addr Server IPv4 address.
* @param[in] port Socket port. qlaunch uses value 55556.
* @param[in] application_id ApplicationId
* @param[in] meta Input array of \ref NcmContentMetaKey. The ::NcmContentMetaType must match ::NcmContentMetaType_Patch.
* @param[in] count Size of the meta array in entries.
* @param[in] storage_id \ref NcmStorageId. qlaunch uses ::NcmStorageId_Any.
*/
nsRequestReceiveApplication :: (a: *AsyncResult, addr: u32, port: u16, application_id: u64, meta: *NcmContentMetaKey, count: s32, storage_id: NcmStorageId) -> Result #foreign libnx;

/**
* @brief CommitReceiveApplication
* @note Only available on [4.0.0+].
* @param[in] application_id ApplicationId
*/
nsCommitReceiveApplication :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief GetReceiveApplicationProgress
* @note Only available on [4.0.0+].
* @param[in] application_id ApplicationId
* @param[out] out \ref NsReceiveApplicationProgress
*/
nsGetReceiveApplicationProgress :: (application_id: u64, out: *NsReceiveApplicationProgress) -> Result #foreign libnx;

/**
* @brief RequestSendApplication
* @note This is the Application version of \ref nssuRequestSendSystemUpdate, see the notes for that.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] addr Client IPv4 address.
* @param[in] port Socket port. qlaunch uses value 55556.
* @param[in] application_id ApplicationId
* @param[in] meta Input array of \ref NcmContentMetaKey. The ::NcmContentMetaType must match ::NcmContentMetaType_Patch.
* @param[in] count Size of the meta array in entries.
*/
nsRequestSendApplication :: (a: *AsyncResult, addr: u32, port: u16, application_id: u64, meta: *NcmContentMetaKey, count: s32) -> Result #foreign libnx;

/**
* @brief GetSendApplicationProgress
* @note Only available on [4.0.0+].
* @param[in] application_id ApplicationId
* @param[out] out \ref NsSendApplicationProgress
*/
nsGetSendApplicationProgress :: (application_id: u64, out: *NsSendApplicationProgress) -> Result #foreign libnx;

/**
* @brief Both \ref NsSystemDeliveryInfo are validated, then the system_update_meta_version in the first/second \ref NsSystemDeliveryInfo are compared.
* @note Only available on [4.0.0+].
* @param[in] info0 First \ref NsSystemDeliveryInfo.
* @param[in] info1 Second \ref NsSystemDeliveryInfo.
* @param[out] out Comparison result: -1 for less than, 0 for equal, and 1 for higher than.
*/
nsCompareSystemDeliveryInfo :: (info0: *NsSystemDeliveryInfo, info1: *NsSystemDeliveryInfo, out: *s32) -> Result #foreign libnx;

/**
* @brief ListNotCommittedContentMeta
* @note Only available on [4.0.0+].
* @param[out] meta Output array of \ref NcmContentMetaKey.
* @param[in] count Size of the meta array in entries.
* @param[in] application_id ApplicationId
* @param[in] unk Unknown.
* @param[out] total_out Total output entries.
*/
nsListNotCommittedContentMeta :: (meta: *NcmContentMetaKey, count: s32, application_id: u64, unk: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief This extracts data from the input array for hashing with SHA256, with validation being done when handling each entry.
* @note Only available on [5.0.0+].
* @param[in] info Input array of \ref NsApplicationDeliveryInfo.
* @param[in] count Size of the array in entries.
* @param[out] out_hash Output 0x20-byte SHA256 hash.
*/
nsGetApplicationDeliveryInfoHash :: (info: *NsApplicationDeliveryInfo, count: s32, out_hash: *u8) -> Result #foreign libnx;

/**
* @brief GetApplicationTerminateResult
* @note Only available on [6.0.0+].
* @param[in] application_id ApplicationId.
* @param[out] res Output Result.
*/
nsGetApplicationTerminateResult :: (application_id: u64, res: *Result) -> Result #foreign libnx;

/**
* @brief GetApplicationRightsOnClient
* @note Only available on [6.0.0+].
* @param[out] rights Output array of \ref NsApplicationRightsOnClient.
* @param[in] count Size of the rights array in entries. qlaunch uses value 3 for this.
* @param[in] application_id ApplicationId
* @param[in] uid \ref AccountUid, can optionally be all-zero.
* @param[in] flags Flags. Official sw hard-codes this to value 0x3.
* @param[out] total_out Total output entries.
*/
nsGetApplicationRightsOnClient :: (rights: *NsApplicationRightsOnClient, count: s32, application_id: u64, uid: AccountUid, flags: u32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief RequestNoDownloadRightsErrorResolution
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [9.0.0+].
* @param[out] a \ref AsyncValue. The data that can be read from this is u8 NoDownloadRightsErrorResolution.
* @param application_id ApplicationId.
*/
nsRequestNoDownloadRightsErrorResolution :: (a: *AsyncValue, application_id: u64) -> Result #foreign libnx;

/**
* @brief RequestResolveNoDownloadRightsError
* @note \ref nifmInitialize must be used prior to this. Before using the cmd, this calls \ref nifmIsAnyInternetRequestAccepted with the output from \ref nifmGetClientId, an error is returned when that returns false.
* @note Only available on [9.0.0+].
* @param[out] a \ref AsyncValue. The data that can be read from this is u8 NoDownloadRightsErrorResolution.
* @param application_id ApplicationId.
*/
nsRequestResolveNoDownloadRightsError :: (a: *AsyncValue, application_id: u64) -> Result #foreign libnx;

/**
* @brief GetPromotionInfo
* @note Only available on [8.0.0+].
* @param[out] promotion \ref NsPromotionInfo
* @param application_id ApplicationId.
* @param[in] uid \ref AccountUid
*/
nsGetPromotionInfo :: (promotion: *NsPromotionInfo, application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief ClearTaskStatusList
* @note Uses \ref nsGetDownloadTaskInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
*/
nsClearTaskStatusList :: () -> Result #foreign libnx;

/**
* @brief RequestDownloadTaskList
* @note Uses \ref nsGetDownloadTaskInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
*/
nsRequestDownloadTaskList :: () -> Result #foreign libnx;

/**
* @brief RequestEnsureDownloadTask
* @note Uses \ref nsGetDownloadTaskInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
* @param[out] a \ref AsyncResult
*/
nsRequestEnsureDownloadTask :: (a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief ListDownloadTaskStatus
* @note Uses \ref nsGetDownloadTaskInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
* @param[out] tasks Output array of \ref NsDownloadTaskStatus.
* @param[in] count Size of the tasks array in entries. A maximum of 0x100 tasks can be stored in state.
* @param[out] total_out Total output entries.
*/
nsListDownloadTaskStatus :: (tasks: *NsDownloadTaskStatus, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief RequestDownloadTaskListData
* @note Uses \ref nsGetDownloadTaskInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
* @param[out] a \ref AsyncValue
*/
nsRequestDownloadTaskListData :: (a: *AsyncValue) -> Result #foreign libnx;

/**
* @brief TryCommitCurrentApplicationDownloadTask
* @note Only available on [4.0.0+].
*/
nsTryCommitCurrentApplicationDownloadTask :: () -> Result #foreign libnx;

/**
* @brief EnableAutoCommit
* @note Only available on [4.0.0+].
*/
nsEnableAutoCommit :: () -> Result #foreign libnx;

/**
* @brief DisableAutoCommit
* @note Only available on [4.0.0+].
*/
nsDisableAutoCommit :: () -> Result #foreign libnx;

/**
* @brief TriggerDynamicCommitEvent
* @note Only available on [4.0.0+].
*/
nsTriggerDynamicCommitEvent :: () -> Result #foreign libnx;

/**
* @brief CalculateApplicationOccupiedSize
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @param[in] application_id ApplicationId.
* @param[out] out \ref NsApplicationOccupiedSize
*/
nsCalculateApplicationOccupiedSize :: (application_id: u64, out: *NsApplicationOccupiedSize) -> Result #foreign libnx;

/**
* @brief CheckSdCardMountStatus
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
*/
nsCheckSdCardMountStatus :: () -> Result #foreign libnx;

/**
* @brief Returns the total storage capacity (used + free) from content manager services.
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @param[in] storage_id \ref NcmStorageId. Must be ::NcmStorageId_SdCard.
* @param[out] size Pointer to output the total storage size to.
*/
nsGetTotalSpaceSize :: (storage_id: NcmStorageId, size: *s64) -> Result #foreign libnx;

/**
* @brief Returns the available storage capacity from content manager services.
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @param[in] storage_id \ref NcmStorageId. Must be ::NcmStorageId_SdCard.
* @param[out] size Pointer to output the free storage size to.
*/
nsGetFreeSpaceSize :: (storage_id: NcmStorageId, size: *s64) -> Result #foreign libnx;

/**
* @brief CountApplicationContentMeta
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
* @param[out] out Output count.
*/
nsCountApplicationContentMeta :: (application_id: u64, out: *s32) -> Result #foreign libnx;

/**
* @brief Gets an listing of \ref NsApplicationContentMetaStatus.
* @note Uses \ref nsGetContentManagementInterface on [3.0.0+], otherwise IApplicationManagerInterface is used.
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
* @param[in] index Starting entry index.
* @param[out] list Output array of \ref NsApplicationContentMetaStatus.
* @param[in] count Size of the list array in entries.
* @param[out] out_entrycount Total output entries.
*/
nsListApplicationContentMetaStatus :: (application_id: u64, index: s32, list: *NsApplicationContentMetaStatus, count: s32, out_entrycount: *s32) -> Result #foreign libnx;

/**
* @brief IsAnyApplicationRunning
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
nsIsAnyApplicationRunning :: (out: *bool) -> Result #foreign libnx;

/**
* @brief Close a \ref NsRequestServerStopper.
* @param r \ref NsRequestServerStopper
*/
nsRequestServerStopperClose :: (r: *NsRequestServerStopper) -> void #foreign libnx;

/**
* @brief Close a \ref NsProgressMonitorForDeleteUserSaveDataAll. When initialized this will use \ref nsProgressMonitorForDeleteUserSaveDataAllIsFinished, throwing errors on failure / when the operation isn't finished (without closing the object).
* @note Cancelling the operation before it's finished is not supported by \ref NsProgressMonitorForDeleteUserSaveDataAll.
* @param p \ref NsProgressMonitorForDeleteUserSaveDataAll
*/
nsProgressMonitorForDeleteUserSaveDataAllClose :: (p: *NsProgressMonitorForDeleteUserSaveDataAll) -> Result #foreign libnx;

/**
* @brief GetSystemEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
nsProgressMonitorForDeleteUserSaveDataAllGetSystemEvent :: (p: *NsProgressMonitorForDeleteUserSaveDataAll, out_event: *Event) -> Result #foreign libnx;

/**
* @brief IsFinished
* @param p \ref NsProgressMonitorForDeleteUserSaveDataAll
* @param[out] out Whether the operation finished.
*/
nsProgressMonitorForDeleteUserSaveDataAllIsFinished :: (p: *NsProgressMonitorForDeleteUserSaveDataAll, out: *bool) -> Result #foreign libnx;

/**
* @brief GetResult
* @param p \ref NsProgressMonitorForDeleteUserSaveDataAll
*/
nsProgressMonitorForDeleteUserSaveDataAllGetResult :: (p: *NsProgressMonitorForDeleteUserSaveDataAll) -> Result #foreign libnx;

/**
* @brief GetProgress
* @param p \ref NsProgressMonitorForDeleteUserSaveDataAll
* @param[out] progress Output \ref NsProgressForDeleteUserSaveDataAll.
*/
nsProgressMonitorForDeleteUserSaveDataAllGetProgress :: (p: *NsProgressMonitorForDeleteUserSaveDataAll, progress: *NsProgressForDeleteUserSaveDataAll) -> Result #foreign libnx;

/**
* @brief Close a \ref NsProgressAsyncResult.
* @note When the object is initialized, this uses \ref nsProgressAsyncResultCancel then \ref nsProgressAsyncResultWait with timeout=UINT64_MAX.
* @param a \ref NsProgressAsyncResult
*/
nsProgressAsyncResultClose :: (a: *NsProgressAsyncResult) -> void #foreign libnx;

/**
* @brief Waits for the async operation to finish using the specified timeout.
* @param a \ref NsProgressAsyncResult
* @param[in] timeout Timeout in nanoseconds. UINT64_MAX for no timeout.
*/
nsProgressAsyncResultWait :: (a: *NsProgressAsyncResult, timeout: u64) -> Result #foreign libnx;

/**
* @brief Gets the Result.
* @note Prior to using the cmd, this uses \ref nsProgressAsyncResultWait with timeout=UINT64_MAX.
* @param a \ref NsProgressAsyncResult
*/
nsProgressAsyncResultGet :: (a: *NsProgressAsyncResult) -> Result #foreign libnx;

/**
* @brief Cancels the async operation.
* @note Used automatically by \ref nsProgressAsyncResultClose.
* @param a \ref NsProgressAsyncResult
*/
nsProgressAsyncResultCancel :: (a: *NsProgressAsyncResult) -> Result #foreign libnx;

/**
* @brief Gets the progress.
* @param a \ref NsProgressAsyncResult
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size.
*/
nsProgressAsyncResultGetProgress :: (a: *NsProgressAsyncResult, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief GetDetailResult
* @param a \ref NsProgressAsyncResult
*/
nsProgressAsyncResultGetDetailResult :: (a: *NsProgressAsyncResult) -> Result #foreign libnx;

/**
* @brief Gets the \ref ErrorContext.
* @note Only available on [4.0.0+].
* @param a \ref NsProgressAsyncResult
* @param[out] context \ref ErrorContext
*/
nsProgressAsyncResultGetErrorContext :: (a: *NsProgressAsyncResult, _context: *ErrorContext) -> Result #foreign libnx;

/// Initialize ns:vm. On pre-3.0.0 this must be used with \ref nsInitialize.
nsvmInitialize :: () -> Result #foreign libnx;

/// Exit ns:vm.
nsvmExit :: () -> void #foreign libnx;

/// Gets the Service object for ns:vm. This is only initialized on [3.0.0+].
nsvmGetServiceSession :: () -> *Service #foreign libnx;

nsvmNeedsUpdateVulnerability :: (out: *bool) -> Result #foreign libnx;
nsvmGetSafeSystemVersion :: (out: *NcmContentMetaKey) -> Result #foreign libnx;

/// Initialize ns:dev.
nsdevInitialize :: () -> Result #foreign libnx;

/// Initialize ns:dev.
nsdevExit :: () -> void #foreign libnx;

/// Gets the Service object for ns:dev.
nsdevGetServiceSession :: () -> *Service #foreign libnx;

nsdevLaunchProgram :: (out_pid: *u64, properties: *NsLaunchProperties, flags: u32) -> Result #foreign libnx;
nsdevTerminateProcess :: (pid: u64) -> Result #foreign libnx;
nsdevTerminateProgram :: (tid: u64) -> Result #foreign libnx;
nsdevGetShellEvent :: (out_event: *Event) -> Result #foreign libnx;
nsdevGetShellEventInfo :: (out: *NsShellEventInfo) -> Result #foreign libnx;
nsdevTerminateApplication :: () -> Result #foreign libnx;
nsdevPrepareLaunchProgramFromHost :: (out: *NsLaunchProperties, path: *u8, path_len: u64) -> Result #foreign libnx;
nsdevLaunchApplicationForDevelop :: (out_pid: *u64, application_id: u64, flags: u32) -> Result #foreign libnx;
nsdevLaunchApplicationFromHost :: (out_pid: *u64, path: *u8, path_len: u64, flags: u32) -> Result #foreign libnx;
nsdevLaunchApplicationWithStorageIdForDevelop :: (out_pid: *u64, application_id: u64, flags: u32, app_storage_id: u8, patch_storage_id: u8) -> Result #foreign libnx;
nsdevIsSystemMemoryResourceLimitBoosted :: (out: *bool) -> Result #foreign libnx;
nsdevGetRunningApplicationProcessIdForDevelop :: (out_pid: *u64) -> Result #foreign libnx;
nsdevSetCurrentApplicationRightsEnvironmentCanBeActiveForDevelop :: (can_be_active: bool) -> Result #foreign libnx;

/// Initialize ns:su.
nssuInitialize :: () -> Result #foreign libnx;

/// Exit ns:su.
nssuExit :: () -> void #foreign libnx;

/// Gets the Service object for ns:su.
nssuGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets the \ref NsBackgroundNetworkUpdateState.
* @note Internally this uses nim commands ListSystemUpdateTask and GetSystemUpdateTaskInfo to determine the output state.
* @param[out] out \ref NsBackgroundNetworkUpdateState
*/
nssuGetBackgroundNetworkUpdateState :: (out: *NsBackgroundNetworkUpdateState) -> Result #foreign libnx;

/**
* @brief Opens a \ref NsSystemUpdateControl.
* @note Only 1 \ref NsSystemUpdateControl can be open at a time.
* @param[out] c \ref NsSystemUpdateControl
*/
nssuOpenSystemUpdateControl :: (c: *NsSystemUpdateControl) -> Result #foreign libnx;

/**
* @brief Uses nim ListSystemUpdateTask, then uses the task with DestroySystemUpdateTask if it exists. Then this runs ExFat handling, updates state, and sets the same state flag as \ref nssuRequestBackgroundNetworkUpdate.
* @note Only usable when a \ref NsSystemUpdateControl isn't open.
*/
nssuNotifyExFatDriverRequired :: () -> Result #foreign libnx;

/**
* @brief ClearExFatDriverStatusForDebug
*/
nssuClearExFatDriverStatusForDebug :: () -> Result #foreign libnx;

/**
* @brief RequestBackgroundNetworkUpdate
* @note Only usable when a \ref NsSystemUpdateControl isn't open.
*/
nssuRequestBackgroundNetworkUpdate :: () -> Result #foreign libnx;

/**
* @brief This checks whether a sysupdate is needed with the input \ref NcmContentMetaKey using NCM commands, if not this will just return 0. Otherwise, this will then run code which is identical to \ref nssuRequestBackgroundNetworkUpdate.
* @note Only usable when a \ref NsSystemUpdateControl isn't open.
* @param[in] key \ref NcmContentMetaKey
*/
nssuNotifyBackgroundNetworkUpdate :: (key: *NcmContentMetaKey) -> Result #foreign libnx;

/**
* @brief NotifyExFatDriverDownloadedForDebug
*/
nssuNotifyExFatDriverDownloadedForDebug :: () -> Result #foreign libnx;

/**
* @brief Gets an Event which can be signaled by \ref nssuNotifySystemUpdateForContentDelivery.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
nssuGetSystemUpdateNotificationEventForContentDelivery :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Signals the event returned by \ref nssuGetSystemUpdateNotificationEventForContentDelivery.
*/
nssuNotifySystemUpdateForContentDelivery :: () -> Result #foreign libnx;

/**
* @brief This does shutdown preparation.
* @note This is used by am-sysmodule, so generally there's no need to use this.
* @note Only available on [3.0.0+].
*/
nssuPrepareShutdown :: () -> Result #foreign libnx;

/**
* @brief This uses nim ListSystemUpdateTask, then when a task is returned uses it with DestroySystemUpdateTask.
* @note Only available on [4.0.0+].
*/
nssuDestroySystemUpdateTask :: () -> Result #foreign libnx;

/**
* @brief RequestSendSystemUpdate
* @note The system will use the input addr/port with bind(), the input addr will eventually be validated with the addr from accept(). addr/port are little-endian.
* @note After the system accepts a connection etc, an error will be thrown if the system is Internet-connected.
* @note Only available on [4.0.0+].
* @param[out] a \ref AsyncResult
* @param[in] addr Client IPv4 address. qlaunch uses a local-WLAN addr.
* @param[in] port Socket port. qlaunch uses value 55556.
* @param[in] info \ref NsSystemDeliveryInfo
*/
nssuRequestSendSystemUpdate :: (a: *AsyncResult, addr: u32, port: u16, info: *NsSystemDeliveryInfo) -> Result #foreign libnx;

/**
* @brief GetSendSystemUpdateProgress
* @note Only available on [4.0.0+].
* @param[out] out \ref NsSystemUpdateProgress
*/
nssuGetSendSystemUpdateProgress :: (out: *NsSystemUpdateProgress) -> Result #foreign libnx;

/**
* @brief Close a \ref NsSystemUpdateControl.
* @param c \ref NsSystemUpdateControl
*/
nssuControlClose :: (c: *NsSystemUpdateControl) -> void #foreign libnx;

/**
* @brief Gets whether a network sysupdate was downloaded, with install pending.
* @param c \ref NsSystemUpdateControl
* @param[out] out Output flag.
*/
nssuControlHasDownloaded :: (c: *NsSystemUpdateControl, out: *bool) -> Result #foreign libnx;

/**
* @brief RequestCheckLatestUpdate
* @param c \ref NsSystemUpdateControl
* @param[out] a \ref AsyncValue. The data that can be read from this is u8 \ref NsLatestSystemUpdate.
*/
nssuControlRequestCheckLatestUpdate :: (c: *NsSystemUpdateControl, a: *AsyncValue) -> Result #foreign libnx;

/**
* @brief RequestDownloadLatestUpdate
* @param c \ref NsSystemUpdateControl
* @param[out] a \ref AsyncResult
*/
nssuControlRequestDownloadLatestUpdate :: (c: *NsSystemUpdateControl, a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief GetDownloadProgress
* @param c \ref NsSystemUpdateControl
* @param[out] out \ref NsSystemUpdateProgress
*/
nssuControlGetDownloadProgress :: (c: *NsSystemUpdateControl, out: *NsSystemUpdateProgress) -> Result #foreign libnx;

/**
* @brief ApplyDownloadedUpdate
* @param c \ref NsSystemUpdateControl
*/
nssuControlApplyDownloadedUpdate :: (c: *NsSystemUpdateControl) -> Result #foreign libnx;

/**
* @brief RequestPrepareCardUpdate
* @param c \ref NsSystemUpdateControl
* @param[out] a \ref AsyncResult
*/
nssuControlRequestPrepareCardUpdate :: (c: *NsSystemUpdateControl, a: *AsyncResult) -> Result #foreign libnx;

/**
* @brief GetPrepareCardUpdateProgress
* @note \ref nssuControlSetupCardUpdate / \ref nssuControlSetupCardUpdateViaSystemUpdater must have been used at some point prior to using this.
* @param c \ref NsSystemUpdateControl
* @param[out] out \ref NsSystemUpdateProgress
*/
nssuControlGetPrepareCardUpdateProgress :: (c: *NsSystemUpdateControl, out: *NsSystemUpdateProgress) -> Result #foreign libnx;

/**
* @brief HasPreparedCardUpdate
* @note \ref nssuControlSetupCardUpdate / \ref nssuControlSetupCardUpdateViaSystemUpdater must have been used at some point prior to using this.
* @param c \ref NsSystemUpdateControl
* @param[out] out Output flag.
*/
nssuControlHasPreparedCardUpdate :: (c: *NsSystemUpdateControl, out: *bool) -> Result #foreign libnx;

/**
* @brief ApplyCardUpdate
* @note \ref nssuControlSetupCardUpdate / \ref nssuControlSetupCardUpdateViaSystemUpdater must have been used at some point prior to using this.
* @param c \ref NsSystemUpdateControl
*/
nssuControlApplyCardUpdate :: (c: *NsSystemUpdateControl) -> Result #foreign libnx;

/**
* @brief Gets the filesize for the specified DownloadedEulaData.
* @note This mounts the Eula SystemData, then uses the file "<mountname>:/<input path>".
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] filesize Output filesize.
*/
nssuControlGetDownloadedEulaDataSize :: (c: *NsSystemUpdateControl, path: *u8, filesize: *u64) -> Result #foreign libnx;

/**
* @brief Gets the specified DownloadedEulaData.
* @note See the note for \ref nssuControlGetDownloadedEulaDataSize.
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] buffer Output buffer.
* @param[in] size Size of the output buffer, must be at least the output size from \ref nssuControlGetDownloadedEulaDataSize.
* @param[out] filesize Output filesize.
*/
nssuControlGetDownloadedEulaData :: (c: *NsSystemUpdateControl, path: *u8, buffer: *void, size: u64, filesize: *u64) -> Result #foreign libnx;

/**
* @brief SetupCardUpdate
* @param c \ref NsSystemUpdateControl
* @param[in] buffer TransferMemory buffer, when NULL this is automatically allocated.
* @param[in] size TransferMemory buffer size, see \ref NSSU_CARDUPDATE_TMEM_SIZE_DEFAULT.
*/
nssuControlSetupCardUpdate :: (c: *NsSystemUpdateControl, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets the filesize for the specified PreparedCardUpdateEulaData.
* @note See the note for \ref nssuControlGetDownloadedEulaDataSize.
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] filesize Output filesize.
*/
nssuControlGetPreparedCardUpdateEulaDataSize :: (c: *NsSystemUpdateControl, path: *u8, filesize: *u64) -> Result #foreign libnx;

/**
* @brief Gets the specified PreparedCardUpdateEulaData.
* @note See the note for \ref nssuControlGetDownloadedEulaDataSize.
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] buffer Output buffer.
* @param[in] size Size of the output buffer, must be at least the output size from \ref nssuControlGetPreparedCardUpdateEulaDataSize.
* @param[out] filesize Output filesize.
*/
nssuControlGetPreparedCardUpdateEulaData :: (c: *NsSystemUpdateControl, path: *u8, buffer: *void, size: u64, filesize: *u64) -> Result #foreign libnx;

/**
* @brief SetupCardUpdateViaSystemUpdater
* @note Same as \ref nssuControlSetupCardUpdate, except this doesn't run the code for fs cmds GetGameCardHandle/GetGameCardUpdatePartitionInfo, and uses fs OpenRegisteredUpdatePartition instead of OpenGameCardFileSystem.
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[in] buffer TransferMemory buffer, when NULL this is automatically allocated.
* @param[in] size TransferMemory buffer size, see \ref NSSU_CARDUPDATE_TMEM_SIZE_DEFAULT.
*/
nssuControlSetupCardUpdateViaSystemUpdater :: (c: *NsSystemUpdateControl, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief HasReceived
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[out] out Output flag.
*/
nssuControlHasReceived :: (c: *NsSystemUpdateControl, out: *bool) -> Result #foreign libnx;

/**
* @brief RequestReceiveSystemUpdate
* @note The system will use the input addr/port with connect(). addr/port are little-endian.
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[out] a \ref AsyncResult
* @param[in] addr Server IPv4 address. qlaunch uses a local-WLAN addr, however this can be any addr.
* @param[in] port Socket port. qlaunch uses value 55556.
* @param[in] info \ref NsSystemDeliveryInfo
*/
nssuControlRequestReceiveSystemUpdate :: (c: *NsSystemUpdateControl, a: *AsyncResult, addr: u32, port: u16, info: *NsSystemDeliveryInfo) -> Result #foreign libnx;

/**
* @brief GetReceiveProgress
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[out] out \ref NsSystemUpdateProgress
*/
nssuControlGetReceiveProgress :: (c: *NsSystemUpdateControl, out: *NsSystemUpdateProgress) -> Result #foreign libnx;

/**
* @brief ApplyReceivedUpdate
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
*/
nssuControlApplyReceivedUpdate :: (c: *NsSystemUpdateControl) -> Result #foreign libnx;

/**
* @brief Gets the filesize for the specified ReceivedEulaData.
* @note See the note for \ref nssuControlGetDownloadedEulaDataSize.
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] filesize Output filesize.
*/
nssuControlGetReceivedEulaDataSize :: (c: *NsSystemUpdateControl, path: *u8, filesize: *u64) -> Result #foreign libnx;

/**
* @brief Gets the specified ReceivedEulaData.
* @note See the note for \ref nssuControlGetDownloadedEulaDataSize.
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[in] path EulaData path.
* @param[out] buffer Output buffer.
* @param[in] size Size of the output buffer, must be at least the output size from \ref nssuControlGetReceivedEulaDataSize.
* @param[out] filesize Output filesize.
*/
nssuControlGetReceivedEulaData :: (c: *NsSystemUpdateControl, path: *u8, buffer: *void, size: u64, filesize: *u64) -> Result #foreign libnx;

/**
* @brief Does setup for ReceiveSystemUpdate by using the same nim cmds as \ref nssuDestroySystemUpdateTask.
* @note qlaunch uses this before \ref nssuControlRequestReceiveSystemUpdate.
* @note Only available on [4.0.0+].
* @param c \ref NsSystemUpdateControl
*/
nssuControlSetupToReceiveSystemUpdate :: (c: *NsSystemUpdateControl) -> Result #foreign libnx;

/**
* @brief RequestCheckLatestUpdateIncludesRebootlessUpdate
* @note Only available on [6.0.0+].
* @param c \ref NsSystemUpdateControl
* @param[out] a \ref AsyncValue
*/
nssuControlRequestCheckLatestUpdateIncludesRebootlessUpdate :: (c: *NsSystemUpdateControl, a: *AsyncValue) -> Result #foreign libnx;

LoaderProgramInfo :: struct {
    main_thread_priority:   u8;
    default_cpu_id:         u8;
    application_type:       u16;
    main_thread_stack_size: u32;
    program_id:             u64;
    acid_sac_size:          u32;
    aci0_sac_size:          u32;
    acid_fac_size:          u32;
    aci0_fah_size:          u32;
    ac_buffer:              [992] u8;
}

LoaderModuleInfo :: struct {
    build_id:     [32] u8;
    base_address: u64;
    size:         u64;
}

/// Initialize ldr:shel.
ldrShellInitialize :: () -> Result #foreign libnx;

/// Exit ldr:shel.
ldrShellExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ldr:shel service session.
ldrShellGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize ldr:dmnt.
ldrDmntInitialize :: () -> Result #foreign libnx;

/// Exit ldr:dmnt.
ldrDmntExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ldr:dmnt service session.
ldrDmntGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize ldr:pm.
ldrPmInitialize :: () -> Result #foreign libnx;

/// Exit ldr:pm.
ldrPmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ldr:pm service session.
ldrPmGetServiceSession :: () -> *Service #foreign libnx;

ldrShellSetProgramArguments :: (program_id: u64, args: *void, args_size: u64) -> Result #foreign libnx;
ldrShellFlushArguments :: () -> Result #foreign libnx;

ldrDmntSetProgramArguments :: (program_id: u64, args: *void, args_size: u64) -> Result #foreign libnx;
ldrDmntFlushArguments :: () -> Result #foreign libnx;
ldrDmntGetProcessModuleInfo :: (pid: u64, out_module_infos: *LoaderModuleInfo, max_out_modules: u64, num_out: *s32) -> Result #foreign libnx;

ldrPmCreateProcess :: (pin_id: u64, flags: u32, reslimit_h: Handle, out_process_h: *Handle) -> Result #foreign libnx;
ldrPmGetProgramInfo :: (loc: *NcmProgramLocation, out_program_info: *LoaderProgramInfo) -> Result #foreign libnx;
ldrPmPinProgram :: (loc: *NcmProgramLocation, out_pin_id: *u64) -> Result #foreign libnx;
ldrPmUnpinProgram :: (pin_id: u64) -> Result #foreign libnx;
ldrPmSetEnabledProgramVerification :: (enabled: bool) -> Result #foreign libnx;

/// Initialize ldr:ro.
ldrRoInitialize :: () -> Result #foreign libnx;

/// Exit ldr:ro.
ldrRoExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ldr:ro service session.
ldrRoGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize ro:1. Only available with [7.0.0+].
ro1Initialize :: () -> Result #foreign libnx;

/// Exit ro:1.
ro1Exit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ro:1 service session.
ro1GetServiceSession :: () -> *Service #foreign libnx;

/// Initialize ro:dmnt. Only available with [3.0.0+].
roDmntInitialize :: () -> Result #foreign libnx;

/// Exit ro:dmnt.
roDmntExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ro:dmnt service session.
roDmntGetServiceSession :: () -> *Service #foreign libnx;

ldrRoLoadNro :: (out_address: *u64, nro_address: u64, nro_size: u64, bss_address: u64, bss_size: u64) -> Result #foreign libnx;
ldrRoUnloadNro :: (nro_address: u64) -> Result #foreign libnx;
ldrRoLoadNrr :: (nrr_address: u64, nrr_size: u64) -> Result #foreign libnx;
ldrRoUnloadNrr :: (nrr_address: u64) -> Result #foreign libnx;
ldrRoLoadNrrEx :: (nrr_address: u64, nrr_size: u64) -> Result #foreign libnx;

ro1LoadNro :: (out_address: *u64, nro_address: u64, nro_size: u64, bss_address: u64, bss_size: u64) -> Result #foreign libnx;
ro1UnloadNro :: (nro_address: u64) -> Result #foreign libnx;
ro1LoadNrr :: (nrr_address: u64, nrr_size: u64) -> Result #foreign libnx;
ro1UnloadNrr :: (nrr_address: u64) -> Result #foreign libnx;
ro1LoadNrrEx :: (nrr_address: u64, nrr_size: u64) -> Result #foreign libnx;

roDmntGetProcessModuleInfo :: (pid: u64, out_module_infos: *LoaderModuleInfo, max_out_modules: u64, num_out: *s32) -> Result #foreign libnx;

/// Initialize tc.
tcInitialize :: () -> Result #foreign libnx;

/// Exit tc.
tcExit :: () -> void #foreign libnx;

/// Gets the Service for tc.
tcGetServiceSession :: () -> *Service #foreign libnx;

tcEnableFanControl :: () -> Result #foreign libnx;

/// @warning Disabling your fan can damage your system.
tcDisableFanControl :: () -> Result #foreign libnx;
tcIsFanControlEnabled :: (status: *bool) -> Result #foreign libnx;

/// Only available on [5.0.0+].
tcGetSkinTemperatureMilliC :: (skinTemp: *s32) -> Result #foreign libnx;

/// Location
TsLocation :: enum u32 {
    Internal :: 0;
    External :: 1;
}

TsDeviceCode :: enum u32 {
    LocationInternal :: 1090519041;
    LocationExternal :: 1090519042;
}

TsSession :: struct {
    s: Service;
}

/// Initialize ts.
tsInitialize :: () -> Result #foreign libnx;

/// Exit ts.
tsExit :: () -> void #foreign libnx;

/// Gets the Service for ts.
tsGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Gets the min/max temperature for the specified \ref TsLocation.
* @param[in] location \ref TsLocation
* @param[out] min_temperature Output minimum temperature in Celsius.
* @param[out] max_temperature Output maximum temperature in Celsius.
*/
tsGetTemperatureRange :: (location: TsLocation, min_temperature: *s32, max_temperature: *s32) -> Result #foreign libnx;

/**
* @brief Gets the temperature for the specified \ref TsLocation.
* @param[in] location \ref TsLocation
* @param[out] temperature Output temperature in Celsius.
*/
tsGetTemperature :: (location: TsLocation, temperature: *s32) -> Result #foreign libnx;

/**
* @brief Gets the temperature for the specified \ref TsLocation, in MilliC. [1.0.0-13.2.1]
* @param[in] location \ref TsLocation
* @param[out] temperature Output temperature in MilliC.
*/
tsGetTemperatureMilliC :: (location: TsLocation, temperature: *s32) -> Result #foreign libnx;

tsOpenSession :: (s: *TsSession, device_code: u32) -> Result #foreign libnx;

tsSessionGetTemperature :: (s: *TsSession, temperature: *float) -> Result #foreign libnx;
tsSessionClose :: (s: *TsSession) -> void #foreign libnx;

/// Values for __nx_ssl_service_type, controls which ssl service to initialize.
SslServiceType :: enum u32 {
    Default :: 0;
    System  :: 1;
}

/// CaCertificateId
SslCaCertificateId :: enum s32 {
    All                                                 :: -1;

    NintendoCAG3                                        :: 1;
    NintendoClass2CAG3                                  :: 2;
    NintendoRootCAG4                                    :: 3;

    AmazonRootCA1                                       :: 1000;
    StarfieldServicesRootCertificateAuthorityG2         :: 1001;
    AddTrustExternalCARoot                              :: 1002;
    COMODOCertificationAuthority                        :: 1003;
    UTNDATACorpSGC                                      :: 1004;
    UTNUSERFirstHardware                                :: 1005;
    BaltimoreCyberTrustRoot                             :: 1006;
    CybertrustGlobalRoot                                :: 1007;
    VerizonGlobalRootCA                                 :: 1008;
    DigiCertAssuredIDRootCA                             :: 1009;
    DigiCertAssuredIDRootG2                             :: 1010;
    DigiCertGlobalRootCA                                :: 1011;
    DigiCertGlobalRootG2                                :: 1012;
    DigiCertHighAssuranceEVRootCA                       :: 1013;
    EntrustnetCertificationAuthority2048                :: 1014;
    EntrustRootCertificationAuthority                   :: 1015;
    EntrustRootCertificationAuthorityG2                 :: 1016;
    GeoTrustGlobalCA2                                   :: 1017;
    GeoTrustGlobalCA                                    :: 1018;
    GeoTrustPrimaryCertificationAuthorityG3             :: 1019;
    GeoTrustPrimaryCertificationAuthority               :: 1020;
    GlobalSignRootCA                                    :: 1021;
    GlobalSignRootCAR2                                  :: 1022;
    GlobalSignRootCAR3                                  :: 1023;
    GoDaddyClass2CertificationAuthority                 :: 1024;
    GoDaddyRootCertificateAuthorityG2                   :: 1025;
    StarfieldClass2CertificationAuthority               :: 1026;
    StarfieldRootCertificateAuthorityG2                 :: 1027;
    thawtePrimaryRootCAG3                               :: 1028;
    thawtePrimaryRootCA                                 :: 1029;
    VeriSignClass3PublicPrimaryCertificationAuthorityG3 :: 1030;
    VeriSignClass3PublicPrimaryCertificationAuthorityG5 :: 1031;
    VeriSignUniversalRootCertificationAuthority         :: 1032;
    DSTRootCAX3                                         :: 1033;
    USERTrustRsaCertificationAuthority                  :: 1034;
    ISRGRootX10                                         :: 1035;
    USERTrustEccCertificationAuthority                  :: 1036;
    COMODORsaCertificationAuthority                     :: 1037;
    COMODOEccCertificationAuthority                     :: 1038;
    AmazonRootCA2                                       :: 1039;
    AmazonRootCA3                                       :: 1040;
    AmazonRootCA4                                       :: 1041;
    DigiCertAssuredIDRootG3                             :: 1042;
    DigiCertGlobalRootG3                                :: 1043;
    DigiCertTrustedRootG4                               :: 1044;
    EntrustRootCertificationAuthorityEC1                :: 1045;
    EntrustRootCertificationAuthorityG4                 :: 1046;
    GlobalSignECCRootCAR4                               :: 1047;
    GlobalSignECCRootCAR5                               :: 1048;
    GlobalSignECCRootCAR6                               :: 1049;
    GTSRootR1                                           :: 1050;
    GTSRootR2                                           :: 1051;
    GTSRootR3                                           :: 1052;
    GTSRootR4                                           :: 1053;
    SecurityCommunicationRootCA                         :: 1054;
    GlobalSignRootE4                                    :: 1055;
    GlobalSignRootR4                                    :: 1056;
    TTeleSecGlobalRootClass2                            :: 1057;
    DigiCertTLSECCP384RootG5                            :: 1058;
    DigiCertTLSRSA4096RootG5                            :: 1059;
}

/// TrustedCertStatus
SslTrustedCertStatus :: enum s32 {
    Invalid           :: -1;
    Removed           :: 0;
    EnabledTrusted    :: 1;
    EnabledNotTrusted :: 2;
    Revoked           :: 3;
}

/// FlushSessionCacheOptionType
SslFlushSessionCacheOptionType :: enum u32 {
    SingleHost :: 0;
    AllHosts   :: 1;
}

/// DebugOptionType
SslDebugOptionType :: enum u32 {
    AllowDisableVerifyOption :: 0;
}

/// SslVersion. This is a bitmask which controls the min/max TLS versions to use, depending on which lowest/highest bits are set (if Auto* isn't set).
SslVersion :: enum u32 {
    Auto   :: 1;
    TlsV10 :: 8;
    TlsV11 :: 16;
    TlsV12 :: 32;
    TlsV13 :: 64;
    Auto24 :: 16777216;
}

/// CertificateFormat
SslCertificateFormat :: enum u32 {
    Pem :: 1;
    Der :: 2;
}

/// InternalPki
SslInternalPki :: enum u32 {
    DeviceClientCertDefault :: 1;
}

/// ContextOption
SslContextOption :: enum u32 {
    CrlImportDateCheckEnable :: 1;
}

/// VerifyOption. The default bitmask value at the time of \ref sslContextCreateConnection is ::SslVerifyOption_PeerCa | ::SslVerifyOption_HostName.
/// [5.0.0+] \ref sslConnectionSetVerifyOption: (::SslVerifyOption_PeerCa | ::SslVerifyOption_HostName) must be set, unless: ::SslOptionType_SkipDefaultVerify is set, or [9.0.0+] ::SslDebugOptionType_AllowDisableVerifyOption is set.
/// [6.0.0+] \ref sslConnectionSetVerifyOption: Following that, if ::SslVerifyOption_EvPolicyOid is set, then the following options must be set (besides the previously mentioned one): ::SslVerifyOption_PeerCa and ::SslVerifyOption_DateCheck.
SslVerifyOption :: enum u32 {
    PeerCa            :: 1;
    HostName          :: 2;
    DateCheck         :: 4;
    EvCertPartial     :: 8;
    EvPolicyOid       :: 16;
    EvCertFingerprint :: 32;
}

/// IoMode. The default value at the time of \ref sslContextCreateConnection is ::SslIoMode_Blocking.
/// The socket non-blocking flag is always set regardless of this field, this is only used internally for calculating the timeout used by various cmds.
SslIoMode :: enum u32 {
    Blocking    :: 1;
    NonBlocking :: 2;
}

/// PollEvent
SslPollEvent :: enum u32 {
    Read   :: 1;
    Write  :: 2;
    Except :: 4;
}

/// SessionCacheMode
SslSessionCacheMode :: enum u32 {
    None          :: 0;
    SessionId     :: 1;
    SessionTicket :: 2;
}

/// RenegotiationMode
SslRenegotiationMode :: enum u32 {
    None   :: 0;
    Secure :: 1;
}

/// OptionType. The default bool flags value for these at the time of \ref sslContextCreateConnection is cleared.
SslOptionType :: enum u32 {
    DoNotCloseSocket   :: 0;
    GetServerCertChain :: 1;
    SkipDefaultVerify  :: 2;
    EnableAlpn         :: 3;
}

/// PrivateOptionType
SslPrivateOptionType :: enum u32 {
    DtlsSession :: 1;
    SetCipher   :: 2;
}

/// AlpnProtoState
SslAlpnProtoState :: enum u32 {
    NoSupport  :: 0;
    Negotiated :: 1;
    NoOverlap  :: 2;
    Selected   :: 3;
    EarlyValue :: 4;
}

/// SslContext
SslContext :: struct {
    s: Service; ///< ISslContext
}

/// SslConnection
SslConnection :: struct {
    s: Service; ///< ISslConnection
}

/// BuiltInCertificateInfo
SslBuiltInCertificateInfo :: struct {
    cert_id:   u32; ///< \ref SslCaCertificateId
    status:    u32; ///< \ref SslTrustedCertStatus
    cert_size: u64; ///< CertificateSize
    cert_data: *u8; ///< CertificateData (converted from an offset to a ptr), in DER format.
}

/// SslServerCertDetailHeader
SslServerCertDetailHeader :: struct {
    magicnum:   u64; ///< Magicnum.
    cert_total: u32; ///< Total certs.
    pad:        u32; ///< Padding.
}

/// SslServerCertDetailEntry
SslServerCertDetailEntry :: struct {
    size:   u32; ///< Size.
    offset: u32; ///< Offset.
}

/// CipherInfo
SslCipherInfo :: struct {
    cipher:           [64] u8; ///< Cipher string.
    protocol_version: [8] u8; ///< Protocol version string.
}

/// KeyAndCertParams
SslKeyAndCertParams :: struct {
    unk_x0:          u32; ///< Must be value 1.
    key_size:        s32; ///< Key size in bits.
    public_exponent: u64; ///< Public exponent, must be non-zero. Only the low 4-bytes are used.
    common_name:     [64] u8; ///< CN (Common Name) NUL-terminated string.
    common_name_len: u32; ///< Length of common_name excluding NUL-terminator. Must be 0x1-0x3F.
}

/// Initialize ssl. A default value of 0x3 can be used for num_sessions. This must be 0x1-0x4.
sslInitialize :: (num_sessions: u32) -> Result #foreign libnx;

/// Exit ssl.
sslExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ssl service session.
sslGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief CreateContext
* @note The CertStore is used automatically, regardless of what cmds are used.
* @param[out] c \ref SslContext
* @param[in] ssl_version \ref SslVersion
*/
sslCreateContext :: (c: *SslContext, ssl_version: u32) -> Result #foreign libnx;

/**
* @brief GetContextCount
* @note Not used by official sw.
* @param[out] out Output value.
*/
sslGetContextCount :: (out: *u32) -> Result #foreign libnx;

/**
* @brief GetCertificates
* @param[in] buffer Output buffer. The start of this buffer is an array of \ref SslBuiltInCertificateInfo, with the specified count. The cert data (SslBuiltInCertificateInfo::data) is located after this array.
* @param[in] size Output buffer size, this should be the size from \ref sslGetCertificateBufSize.
* @param[in] ca_cert_ids Input array of \ref SslCaCertificateId.
* @param[in] count Size of the ca_cert_ids array in entries.
* @param[out] total_out [3.0.0+] Total output entries. Will always match count on pre-3.0.0. This will differ from count when ::SslCaCertificateId_All is used.
*/
sslGetCertificates :: (buffer: *void, size: u32, ca_cert_ids: *u32, count: u32, total_out: *u32) -> Result #foreign libnx;

/**
* @brief GetCertificateBufSize
* @param[in] ca_cert_ids Input array of \ref SslCaCertificateId.
* @param[in] count Size of the ca_cert_ids array in entries.
* @param[out] out Output size.
*/
sslGetCertificateBufSize :: (ca_cert_ids: *u32, count: u32, out: *u32) -> Result #foreign libnx;

/**
* @brief FlushSessionCache
* @note Only available on [5.0.0+].
* @param[in] str Input string. Must be NULL with ::SslFlushSessionCacheOptionType_AllHosts.
* @param[in] str_bufsize String buffer size, excluding NUL-terminator. Hence, this should be actual_bufsize-1. This must be 0 with ::SslFlushSessionCacheOptionType_AllHosts.
* @param[in] type \ref SslFlushSessionCacheOptionType
* @param[out] out Output value.
*/
sslFlushSessionCache :: (str: *u8, str_bufsize: u64, type: SslFlushSessionCacheOptionType, out: *u32) -> Result #foreign libnx;

/**
* @brief SetDebugOption
* @note Only available on [6.0.0+].
* @note The official impl of this doesn't actually use the cmd.
* @param[in] buffer Input buffer, must not be NULL. The u8 from here is copied to state.
* @param[in] size Buffer size, must not be 0.
* @param[in] type \ref SslDebugOptionType
*/
sslSetDebugOption :: (buffer: *void, size: u64, type: SslDebugOptionType) -> Result #foreign libnx;

/**
* @brief GetDebugOption
* @note Only available on [6.0.0+].
* @param[out] buffer Output buffer, must not be NULL. An u8 is written here loaded from state.
* @param[in] size Buffer size, must not be 0.
* @param[in] type \ref SslDebugOptionType
*/
sslGetDebugOption :: (buffer: *void, size: u64, type: SslDebugOptionType) -> Result #foreign libnx;

/**
* @brief ClearTls12FallbackFlag
* @note Only available on [14.0.0+].
*/
sslClearTls12FallbackFlag :: () -> Result #foreign libnx;

/**
* @brief SetThreadCoreMask
* @param[in] mask CoreMask
* @note Only available on [15.0.0+] with ::SslServiceType_System.
*/
sslSetThreadCoreMask :: (mask: u64) -> Result #foreign libnx;

/**
* @brief GetThreadCoreMask
* @param[out] out Output CoreMask.
* @note Only available on [15.0.0+] with ::SslServiceType_System.
*/
sslGetThreadCoreMask :: (out: *u64) -> Result #foreign libnx;

/**
* @brief Closes a Context object.
* @param c \ref SslContext
*/
sslContextClose :: (c: *SslContext) -> void #foreign libnx;

/**
* @brief SetOption
* @note Prior to 4.x this is stubbed.
* @param c \ref SslContext
* @param[in] option \ref SslContextOption
* @param[in] value Value to set. With ::SslContextOption_CrlImportDateCheckEnable, this must be 0 or 1.
*/
sslContextSetOption :: (c: *SslContext, option: SslContextOption, value: s32) -> Result #foreign libnx;

/**
* @brief GetOption
* @note Prior to 4.x this is stubbed.
* @param c \ref SslContext
* @param[in] option \ref SslContextOption
* @param[out] out Output value.
*/
sslContextGetOption :: (c: *SslContext, option: SslContextOption, out: *s32) -> Result #foreign libnx;

/**
* @brief CreateConnection
* @param c \ref SslContext
* @param[out] conn Output \ref SslConnection.
*/
sslContextCreateConnection :: (c: *SslContext, conn: *SslConnection) -> Result #foreign libnx;

/**
* @brief GetConnectionCount
* @note Not exposed by official sw.
* @param c \ref SslContext
* @param[out] out Output value.
*/
sslContextGetConnectionCount :: (c: *SslContext, out: *u32) -> Result #foreign libnx;

/**
* @brief ImportServerPki
* @note A maximum of 71 ServerPki objects (associated with the output Id) can be imported.
* @param c \ref SslContext
* @param[in] buffer Input buffer containing the cert data, must not be NULL. This can contain multiple certs. The certs can be CAs or server certs (no pubkeys).
* @param[in] size Input buffer size.
* @param[in] format \ref SslCertificateFormat
* @param[out] id Output Id. Optional, can be NULL.
*/
sslContextImportServerPki :: (c: *SslContext, buffer: *void, size: u32, format: SslCertificateFormat, id: *u64) -> Result #foreign libnx;

/**
* @brief ImportClientPki
* @note An error is thrown internally if this cmd or \ref sslContextRegisterInternalPki was already used previously.
* @param c \ref SslContext
* @param[in] pkcs12 PKCS#12 input buffer, must not be NULL.
* @param[in] pkcs12_size pkcs12 buffer size.
* @param[in] pw ASCII password string buffer, this can only be NULL if pw_size is 0. This will be internally copied to another buffer which was allocated with size=pw_size+1, for NUL-termination.
* @param[in] pw_size Password buffer size, this can only be 0 if pw is NULL.
* @param[out] id Output Id. Optional, can be NULL.
*/
sslContextImportClientPki :: (c: *SslContext, pkcs12: *void, pkcs12_size: u32, pw: *u8, pw_size: u32, id: *u64) -> Result #foreign libnx;

/**
* @brief Remove the specified *Pki, or on [3.0.0+] Crl.
* @param c \ref SslContext
* @param[in] id Id
*/
sslContextRemovePki :: (c: *SslContext, id: u64) -> Result #foreign libnx;

/**
* @brief RegisterInternalPki
* @note An error is thrown internally if this cmd or \ref sslContextImportClientPki was already used previously.
* @param c \ref SslContext
* @param[in] internal_pki \ref SslInternalPki
* @param[out] id Output Id. Optional, can be NULL.
*/
sslContextRegisterInternalPki :: (c: *SslContext, internal_pki: SslInternalPki, id: *u64) -> Result #foreign libnx;

/**
* @brief AddPolicyOid
* @param c \ref SslContext
* @param[in] str Input string.
* @param[in] str_bufsize String buffer size, excluding NUL-terminator (must not match the string length). Hence, this should be actual_bufsize-1. This must not be >0xff.
*/
sslContextAddPolicyOid :: (c: *SslContext, str: *u8, str_bufsize: u32) -> Result #foreign libnx;

/**
* @brief ImportCrl
* @note Only available on [3.0.0+].
* @param c \ref SslContext
* @param[in] buffer Input buffer, must not be NULL. This contains the DER CRL.
* @param[in] size Input buffer size.
* @param[out] id Output Id. Optional, can be NULL.
*/
sslContextImportCrl :: (c: *SslContext, buffer: *void, size: u32, id: *u64) -> Result #foreign libnx;

/**
* @brief ImportClientCertKeyPki
* @note Only available on [16.0.0+].
* @param c \ref SslContext
* @param[in] cert Input cert buffer,
* @param[in] cert_size Size of the cert buffer.
* @param[in] key Input key buffer.
* @param[in] key_size Size of the key buffer.
* @param[in] format \ref SslCertificateFormat for the cert and key.
* @param[out] id Output Id. Optional, can be NULL.
*/
sslContextImportClientCertKeyPki :: (c: *SslContext, cert: *void, cert_size: u32, key: *void, key_size: u32, format: SslCertificateFormat, id: *u64) -> Result #foreign libnx;

/**
* @brief GeneratePrivateKeyAndCert
* @note Only available on [16.0.0+].
* @param c \ref SslContext
* @param[out] cert Output cert buffer,
* @param[in] cert_size Size of the cert buffer.
* @param[out] key Output key buffer.
* @param[in] key_size Size of the key buffer.
* @param[in] val Must be value 1.
* @param[in] params \ref SslKeyAndCertParams
* @param[out] out_certsize Actual size of the generated cert data.
* @param[out] out_keysize Actual size of the generated key data.
*/
sslContextGeneratePrivateKeyAndCert :: (c: *SslContext, cert: *void, cert_size: u32, key: *void, key_size: u32, val: u32, params: *SslKeyAndCertParams, out_certsize: *u32, out_keysize: *u32) -> Result #foreign libnx;

/**
* @brief CreateConnectionForSystem
* @note Only available on [15.0.0+] with ::SslServiceType_System.
* @param c \ref SslContext
* @param[out] conn Output \ref SslConnection.
*/
sslContextCreateConnectionForSystem :: (c: *SslContext, conn: *SslConnection) -> Result #foreign libnx;

/**
* @brief Closes a Connection object.
* @param c \ref SslConnection
*/
sslConnectionClose :: (c: *SslConnection) -> void #foreign libnx;

/**
* @brief SetSocketDescriptor. Do not use directly, use \ref socketSslConnectionSetSocketDescriptor instead.
* @note An error is thrown if this was used previously.
* @param c \ref SslConnection
* @param[in] sockfd sockfd
* @param[out] out_sockfd sockfd. Prior to using \ref sslConnectionClose, this must be closed if it's not negative (it will be -1 if ::SslOptionType_DoNotCloseSocket is set).
*/
sslConnectionSetSocketDescriptor :: (c: *SslConnection, sockfd: s32, out_sockfd: *s32) -> Result #foreign libnx;

/**
* @brief SetHostName
* @param c \ref SslConnection
* @param[in] str Input string.
* @param[in] str_bufsize String buffer size. This must not be >0xff.
*/
sslConnectionSetHostName :: (c: *SslConnection, str: *u8, str_bufsize: u32) -> Result #foreign libnx;

/**
* @brief SetVerifyOption
* @param c \ref SslConnection
* @param[in] verify_option Input bitmask of \ref SslVerifyOption.
*/
sslConnectionSetVerifyOption :: (c: *SslConnection, verify_option: u32) -> Result #foreign libnx;

/**
* @brief SetIoMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[in] mode \ref SslIoMode
*/
sslConnectionSetIoMode :: (c: *SslConnection, mode: SslIoMode) -> Result #foreign libnx;

/**
* @brief GetSocketDescriptor. Do not use directly, use \ref socketSslConnectionGetSocketDescriptor instead.
* @note This gets the input sockfd which was previously saved in state by \ref sslConnectionSetSocketDescriptor.
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] sockfd Output sockfd.
*/
sslConnectionGetSocketDescriptor :: (c: *SslConnection, sockfd: *s32) -> Result #foreign libnx;

/**
* @brief GetHostName
* @param c \ref SslConnection
* @param[out] str Output string buffer.
* @param[in] str_bufsize String buffer size, must be large enough for the entire output string.
* @param[out] out Output string length.
*/
sslConnectionGetHostName :: (c: *SslConnection, str: *u8, str_bufsize: u32, out: *u32) -> Result #foreign libnx;

/**
* @brief GetVerifyOption
* @param c \ref SslConnection
* @param[out] out Output bitmask of \ref SslVerifyOption.
*/
sslConnectionGetVerifyOption :: (c: *SslConnection, out: *u32) -> Result #foreign libnx;

/**
* @brief GetIoMode
* @param c \ref SslConnection
* @param[out] out \ref SslIoMode
*/
sslConnectionGetIoMode :: (c: *SslConnection, out: *SslIoMode) -> Result #foreign libnx;

/**
* @brief DoHandshake
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @note \ref sslConnectionSetHostName must have been used previously with a non-empty string when ::SslVerifyOption_HostName is set.
* @note The DoHandshakeGetServerCert cmd is only used if both server_certbuf/server_certbuf_size are set, otherwise the DoHandshake cmd is used (in which case out_size/total_certs will be left at value 0).
* @note No certs are returned when ::SslVerifyOption_PeerCa is not set.
* @param c \ref SslConnection
* @param[out] out_size Total data size which was written to server_certbuf. Optional, can be NULL.
* @param[out] total_certs Total certs which were written to server_certbuf, can be NULL.
* @param[out] server_certbuf Optional output server cert buffer, can be NULL. Normally this just contains the server cert DER, however with ::SslOptionType_GetServerCertChain set this will contain the full chain (\ref sslConnectionGetServerCertDetail can be used to parse that). With ::SslIoMode_NonBlocking this buffer will be only filled in once - when this cmd returns successfully the buffer will generally be empty.
* @param[in] server_certbuf_size Optional output server cert buffer size, can be 0.
*/
sslConnectionDoHandshake :: (c: *SslConnection, out_size: *u32, total_certs: *u32, server_certbuf: *void, server_certbuf_size: u32) -> Result #foreign libnx;

/**
* @brief Parses the output server_certbuf from \ref sslConnectionDoHandshake where ::SslOptionType_GetServerCertChain is set.
* @param[in] certbuf server_certbuf from \ref sslConnectionDoHandshake, must not be NULL.
* @param[in] certbuf_size out_size from \ref sslConnectionDoHandshake.
* @param[in] cert_index Cert index, must be within the range of certs stored in certbuf.
* @param[out] cert Ptr for the ouput DER cert, must not be NULL.
* @param[out] cert_size Size for the ouput cert, must not be NULL.
*/
sslConnectionGetServerCertDetail :: (certbuf: *void, certbuf_size: u32, cert_index: u32, cert: **void, cert_size: *u32) -> Result #foreign libnx;

/**
* @brief Read
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] buffer Output buffer, must not be NULL.
* @param[in] size Output buffer size, must not be 0.
* @param[out] out_size Actual transferred size.
*/
sslConnectionRead :: (c: *SslConnection, buffer: *void, size: u32, out_size: *u32) -> Result #foreign libnx;

/**
* @brief Write
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[in] buffer Input buffer, must not be NULL.
* @param[in] size Input buffer size, must not be 0.
* @param[out] out_size Actual transferred size.
*/
sslConnectionWrite :: (c: *SslConnection, buffer: *void, size: u32, out_size: *u32) -> Result #foreign libnx;

/**
* @brief Pending
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] out Output value.
*/
sslConnectionPending :: (c: *SslConnection, out: *s32) -> Result #foreign libnx;

/**
* @brief Peek
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] buffer Output buffer, must not be NULL.
* @param[in] size Output buffer size, must not be 0.
* @param[out] out_size Output size.
*/
sslConnectionPeek :: (c: *SslConnection, buffer: *void, size: u32, out_size: *u32) -> Result #foreign libnx;

/**
* @brief Poll
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[in] in_pollevent Input bitmask of \ref SslPollEvent.
* @param[out] out_pollevent Output bitmask of \ref SslPollEvent.
* @param[in] timeout Timeout in milliseconds.
*/
sslConnectionPoll :: (c: *SslConnection, in_pollevent: u32, out_pollevent: *u32, timeout: u32) -> Result #foreign libnx;

/**
* @brief GetVerifyCertError
* @note The value in state is cleared after loading it.
* @param c \ref SslConnection
*/
sslConnectionGetVerifyCertError :: (c: *SslConnection) -> Result #foreign libnx;

/**
* @brief GetNeededServerCertBufferSize
* @param c \ref SslConnection
* @param[out] out Output value.
*/
sslConnectionGetNeededServerCertBufferSize :: (c: *SslConnection, out: *u32) -> Result #foreign libnx;

/**
* @brief SetSessionCacheMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[in] mode \ref SslSessionCacheMode
*/
sslConnectionSetSessionCacheMode :: (c: *SslConnection, mode: SslSessionCacheMode) -> Result #foreign libnx;

/**
* @brief GetSessionCacheMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] out \ref SslSessionCacheMode
*/
sslConnectionGetSessionCacheMode :: (c: *SslConnection, out: *SslSessionCacheMode) -> Result #foreign libnx;

/**
* @brief GetSessionCacheMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
*/
sslConnectionFlushSessionCache :: (c: *SslConnection) -> Result #foreign libnx;

/**
* @brief SetRenegotiationMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[in] mode \ref SslRenegotiationMode
*/
sslConnectionSetRenegotiationMode :: (c: *SslConnection, mode: SslRenegotiationMode) -> Result #foreign libnx;

/**
* @brief GetRenegotiationMode
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] out \ref SslRenegotiationMode
*/
sslConnectionGetRenegotiationMode :: (c: *SslConnection, out: *SslRenegotiationMode) -> Result #foreign libnx;

/**
* @brief SetOption
* @param c \ref SslConnection
* @param[in] option \ref SslOptionType
* @param[in] flag Input flag value.
*/
sslConnectionSetOption :: (c: *SslConnection, option: SslOptionType, flag: bool) -> Result #foreign libnx;

/**
* @brief GetOption
* @param c \ref SslConnection
* @param[in] option \ref SslOptionType
* @param[out] out Output flag value.
*/
sslConnectionGetOption :: (c: *SslConnection, option: SslOptionType, out: *bool) -> Result #foreign libnx;

/**
* @brief GetVerifyCertErrors
* @note An error is thrown when the cmd is successful, if the two output u32s match.
* @param[out] out0 First output value, must not be NULL.
* @param[out] out1 Second output value.
* @param[out] errors Output array of Result, must not be NULL.
* @param[in] count Size of the errors array in entries.
*/
sslConnectionGetVerifyCertErrors :: (c: *SslConnection, out0: *u32, out1: *u32, errors: *Result, count: u32) -> Result #foreign libnx;

/**
* @brief GetCipherInfo
* @note Only available on [4.0.0+].
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @param c \ref SslConnection
* @param[out] out \ref SslCipherInfo
*/
sslConnectionGetCipherInfo :: (c: *SslConnection, out: *SslCipherInfo) -> Result #foreign libnx;

/**
* @brief SetNextAlpnProto
* @note Only available on [9.0.0+].
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @note ::SslOptionType_EnableAlpn should be set at the time of using \ref sslConnectionDoHandshake, otherwise using this cmd will have no affect.
* @param c \ref SslConnection
* @param[in] buffer Input buffer, must not be NULL. This contains an array of {u8 size, {data with the specified size}}, which must be within the buffer-size bounds.
* @param[in] size Input buffer size, must not be 0. Must be at least 0x2.
*/
sslConnectionSetNextAlpnProto :: (c: *SslConnection, buffer: *u8, size: u32) -> Result #foreign libnx;

/**
* @brief GetNextAlpnProto
* @note Only available on [9.0.0+].
* @note \ref sslConnectionSetSocketDescriptor must have been used prior to this successfully.
* @note The output will be all-zero/empty if not available - such as when this was used before \ref sslConnectionDoHandshake.
* @param c \ref SslConnection
* @param[out] state \ref SslAlpnProtoState
* @param[out] out Output string length.
* @param[out] buffer Output string buffer, must not be NULL.
* @param[in] size Output buffer size, must not be 0.
*/
sslConnectionGetNextAlpnProto :: (c: *SslConnection, state: *SslAlpnProtoState, out: *u32, buffer: *u8, size: u32) -> Result #foreign libnx;

/**
* @brief SetDtlsSocketDescriptor. Do not use directly, use \ref socketSslConnectionSetDtlsSocketDescriptor instead.
* @note Only available on [16.0.0+].
* @note An error is thrown if this was used previously.
* @param c \ref SslConnection
* @param[in] sockfd sockfd
* @param[in] Input sockaddr.
* @param[in] size Input sockaddr size.
* @param[out] out_sockfd sockfd. Prior to using \ref sslConnectionClose, this must be closed if it's not negative (it will be -1 if ::SslOptionType_DoNotCloseSocket is set).
*/
sslConnectionSetDtlsSocketDescriptor :: (c: *SslConnection, sockfd: s32, buf: *void, size: u64, out_sockfd: *s32) -> Result #foreign libnx;

/**
* @brief GetDtlsHandshakeTimeout
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[out] out Output nanoseconds value.
*/
sslConnectionGetDtlsHandshakeTimeout :: (c: *SslConnection, out: *u64) -> Result #foreign libnx;

/**
* @brief SetPrivateOption
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[in] option \ref SslPrivateOptionType
* @param[in] value Input value.
*/
sslConnectionSetPrivateOption :: (c: *SslConnection, option: SslPrivateOptionType, value: u32) -> Result #foreign libnx;

/**
* @brief SetSrtpCiphers
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[in] ciphers Input array of u16s. Each entry must be value 1-2, otherwise the entry is ignored.
* @param[in] count Total entries in the ciphers array, the maximum is 4.
*/
sslConnectionSetSrtpCiphers :: (c: *SslConnection, ciphers: *u16, count: u32) -> Result #foreign libnx;

/**
* @brief GetSrtpCipher
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[out] out Output value.
*/
sslConnectionGetSrtpCipher :: (c: *SslConnection, out: *u16) -> Result #foreign libnx;

/**
* @brief ExportKeyingMaterial
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[out] outbuf Output buffer.
* @param[in] outbuf_size Output buffer size.
* @param[in] label Input label string.
* @param[in] label_size Size of the label buffer excluding NUL-terminator.
* @param[in] context Optional input context buffer, can be NULL.
* @param[in] context_size Size of context, if specified this must be <0xFFFF.
*/
sslConnectionExportKeyingMaterial :: (c: *SslConnection, outbuf: *u8, outbuf_size: u32, label: *u8, label_size: u32, _context: *void, context_size: u32) -> Result #foreign libnx;

/**
* @brief SetIoTimeout
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[in] timeout Input timeout value.
*/
sslConnectionSetIoTimeout :: (c: *SslConnection, timeout: u32) -> Result #foreign libnx;

/**
* @brief GetIoTimeout
* @note Only available on [16.0.0+].
* @param c \ref SslConnection
* @param[out] out Output timeout value.
*/
sslConnectionGetIoTimeout :: (c: *SslConnection, out: *u32) -> Result #foreign libnx;

LrLocationResolver :: struct {
    s: Service;
}

LrRegisteredLocationResolver :: struct {
    s: Service;
}

/// Initialize lr.
lrInitialize :: () -> Result #foreign libnx;

/// Exit lr.
lrExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual lr service session.
lrGetServiceSession :: () -> *Service #foreign libnx;

lrOpenLocationResolver :: (storage: NcmStorageId, out: *LrLocationResolver) -> Result #foreign libnx;
lrOpenRegisteredLocationResolver :: (out: *LrRegisteredLocationResolver) -> Result #foreign libnx;

// ILocationResolver
lrLrResolveProgramPath :: (lr: *LrLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;
lrLrRedirectProgramPath :: (lr: *LrLocationResolver, tid: u64, path: *u8) -> Result #foreign libnx;
lrLrResolveApplicationControlPath :: (lr: *LrLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;
lrLrResolveApplicationHtmlDocumentPath :: (lr: *LrLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;
lrLrResolveDataPath :: (lr: *LrLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;
lrLrRedirectApplicationControlPath :: (lr: *LrLocationResolver, tid: u64, tid2: u64, path: *u8) -> Result #foreign libnx;
lrLrRedirectApplicationHtmlDocumentPath :: (lr: *LrLocationResolver, tid: u64, tid2: u64, path: *u8) -> Result #foreign libnx;
lrLrResolveApplicationLegalInformationPath :: (lr: *LrLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;
lrLrRedirectApplicationLegalInformationPath :: (lr: *LrLocationResolver, tid: u64, tid2: u64, path: *u8) -> Result #foreign libnx;
lrLrRefresh :: (lr: *LrLocationResolver) -> Result #foreign libnx;

/// Only available on [5.0.0+].
lrLrEraseProgramRedirection :: (lr: *LrLocationResolver, tid: u64) -> Result #foreign libnx;

// IRegisteredLocationResolver
lrRegLrResolveProgramPath :: (reg: *LrRegisteredLocationResolver, tid: u64, out: *u8) -> Result #foreign libnx;

/// Data for \ref btdrvGetEventInfo. The data stored here depends on the \ref BtdrvEventType.
BtdrvEventInfo :: struct {
    union {
        data:                      [1024] u8; ///< Raw data.

        type0:                     struct {
            val: u32; ///< Value
        }; ///< ::BtdrvEventTypeOld_Unknown0

        inquiry_device:            struct {
            union {
                v1:  struct {
                    name:            [249] u8; ///< Device name, NUL-terminated string.
                    addr:            BtdrvAddress; ///< Device address.
                    reserved_xFF:    [16] u8; ///< Reserved
                    class_of_device: BtdrvClassOfDevice; ///< Class of Device.
                    unk_x112:        [4] u8; ///< Set to fixed value u32 0x1.
                    reserved_x116:   [250] u8; ///< Reserved
                    reserved_x210:   [92] u8; ///< Reserved
                    name2:           [249] u8; ///< Device name, NUL-terminated string. Same as name above, except starting at index 1.
                    rssi:            [4] u8; ///< s32 RSSI
                    name3:           [4] u8; ///< Two bytes which are the same as name[11-12].
                    reserved_x36D:   [16] u8; ///< Reserved
                }; ///< [1.0.0-11.0.1]

                v12: struct {
                    addr:            BtdrvAddress; ///< Device address.
                    name:            [249] u8; ///< Device name, NUL-terminated string.
                    class_of_device: BtdrvClassOfDevice; ///< Class of Device.
                    reserved:        [6] u8; ///< Reserved
                }; ///< [12.0.0+]
            }
        }; ///< ::BtdrvEventType_InquiryDevice

        inquiry_status:            struct {
            union {
                v1:  struct {
                    status: BtdrvInquiryStatus; ///< \ref BtdrvInquiryStatus
                }; ///< [1.0.0-11.0.1]

                v12: struct {
                    status:       u8; ///< \ref BtdrvInquiryStatus
                    pad:          [3] u8; ///< Padding
                    service_mask: u32; ///< Services value from \ref btdrvStartInquiry when starting, otherwise this is value 0.
                }; ///< [12.0.0+]
            }
        }; ///< ::BtdrvEventType_InquiryStatus

        pairing_pin_code_request:  struct {
            addr:            BtdrvAddress; ///< Device address.
            name:            [249] u8; ///< Device name, NUL-terminated string.
            class_of_device: BtdrvClassOfDevice; ///< Class of Device.
        }; ///< ::BtdrvEventType_PairingPinCodeRequest

        ssp_request:               struct {
            union {
                v1:  struct {
                    addr:            BtdrvAddress; ///< Device address.
                    name:            [249] u8; ///< Device name, NUL-terminated string.
                    class_of_device: BtdrvClassOfDevice; ///< Class of Device.
                    pad:             [2] u8; ///< Padding
                    type:            u32; ///< 0 = SSP confirm request, 3 = SSP passkey notification.
                    passkey:         s32; ///< Passkey, only set when the above field is value 3.
                }; ///< [1.0.0-11.0.1]

                v12: struct {
                    addr:            BtdrvAddress; ///< Device address.
                    name:            [249] u8; ///< Device name, NUL-terminated string.
                    class_of_device: BtdrvClassOfDevice; ///< Class of Device.
                    flag:            u8; ///< bool flag for Just Works. With SSP passkey notification this is always 0.
                    pad:             u8; ///< Padding
                    passkey:         s32; ///< Passkey
                }; ///< [12.0.0+]
            }
        }; ///< ::BtdrvEventType_SspRequest

        connection:                struct {
            union {
                v1:  struct {
                    addr:   BtdrvAddress; ///< Device address.
                    pad:    [2] u8; ///< Padding
                    status: u32; ///< Status, always 0 except with ::BtdrvConnectionEventType_Status: 2 = ACL Link is now Resumed, 9 = connection failed (pairing/authentication failed, or opening the hid connection failed).
                    type:   u32; ///< \ref BtdrvConnectionEventType
                }; ///< [1.0.0-8.1.1]

                v9:  struct {
                    status: u32; ///< Status, always 0 except with ::BtdrvConnectionEventType_Status: 2 = ACL Link is now Resumed, 9 = connection failed (pairing/authentication failed, or opening the hid connection failed).
                    addr:   BtdrvAddress; ///< Device address.
                    pad:    [2] u8; ///< Padding
                    type:   u32; ///< \ref BtdrvConnectionEventType
                }; ///< [9.0.0-11.0.1]

                v12: struct {
                    type:     u32; ///< \ref BtdrvConnectionEventType
                    addr:     BtdrvAddress; ///< Device address.
                    reserved: [254] u8; ///< Reserved
                }; ///< [12.0.0+]
            }
        }; ///< ::BtdrvEventType_Connection

        tsi:                       struct {
            addr:   BtdrvAddress; ///< Device address.
            status: u8; ///< Status flag: 1 = success, 0 = failure.
            value:  u8; ///< Tsi value, when the above indicates success.
        }; ///< ::BtdrvEventType_Tsi

        burst_mode:                struct {
            addr:   BtdrvAddress; ///< Device address.
            status: u8; ///< Status flag: 1 = success, 0 = failure.
            value:  u8; ///< Input bool value from \ref btdrvEnableBurstMode, when the above indicates success.
        }; ///< ::BtdrvEventType_BurstMode

        set_zero_retransmission:   struct {
            addr:   BtdrvAddress; ///< Device address.
            status: u8; ///< Status flag: 1 = success, 0 = failure.
            flag:   u8; ///< Bool flag, when the above indicates success.
        }; ///< ::BtdrvEventType_SetZeroRetransmission

        pending_connections:       struct {
            status: u8; ///< Status flag: 1 = success, 0 = failure.
            pad:    [3] u8; ///< Padding
            count:  u32; ///< Count value.
        }; ///< ::BtdrvEventType_PendingConnections

        move_to_secondary_piconet: struct {
            addr:   BtdrvAddress; ///< Device address.
            status: u8; ///< Status flag: 1 = success, 0 = failure.
        }; ///< ::BtdrvEventType_MoveToSecondaryPiconet

        bluetooth_crash:           struct {
            reason: u16; ///< \ref BtdrvFatalReason
        }; ///< ::BtdrvEventType_BluetoothCrash
    }
}

/// Data for \ref btdrvGetHidEventInfo. The data stored here depends on the \ref BtdrvHidEventType.
BtdrvHidEventInfo :: struct {
    union {
        data:       [1152] u8; ///< Raw data.

        connection: struct {
            union {
                v1:  struct {
                    addr:   BtdrvAddress; ///< Device address.
                    pad:    [2] u8; ///< Padding
                    status: BtdrvHidConnectionStatus; ///< \ref BtdrvHidConnectionStatus
                }; ///< [1.0.0-11.0.1]

                v12: struct {
                    status: BtdrvHidConnectionStatus; ///< \ref BtdrvHidConnectionStatus
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< [12.0.0+]
            }
        }; ///< ::BtdrvHidEventType_Connection

        ext:        struct {
            type: u32; ///< \ref BtdrvExtEventType, controls which data is stored below.

            union {
                set_tsi:                   struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< ::BtdrvExtEventType_SetTsi

                exit_tsi:                  struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< ::BtdrvExtEventType_ExitTsi

                set_burst_mode:            struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< ::BtdrvExtEventType_SetBurstMode

                exit_burst_mode:           struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< ::BtdrvExtEventType_ExitBurstMode

                set_zero_retransmission:   struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                    pad:    [2] u8; ///< Padding
                    flag:   u8; ///< Flag
                }; ///< ::BtdrvExtEventType_SetZeroRetransmission

                pending_connections:       struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Unused
                    pad:    [2] u8; ///< Padding
                    count:  u32; ///< Count value.
                }; ///< ::BtdrvExtEventType_PendingConnections

                move_to_secondary_piconet: struct {
                    status: u32; ///< 0 for success, non-zero for error.
                    addr:   BtdrvAddress; ///< Device address.
                }; ///< ::BtdrvExtEventType_MoveToSecondaryPiconet
            }
        }; ///< ::BtdrvHidEventType_Ext [1.0.0-11.0.1]
    }
}

/// Data for \ref btdrvGetHidReportEventInfo. The data stored here depends on the \ref BtdrvHidEventType.
BtdrvHidReportEventInfo :: struct {
    union {
        data:        [1152] u8; ///< Raw data.

        data_report: struct {
            union {
                v1: struct {
                    hdr:     struct {
                        addr: BtdrvAddress;
                        pad:  [2] u8;
                        res:  u32;
                        size: u32;
                    };

                    unused:  [3] u8; ///< Unused
                    addr:    BtdrvAddress; ///< \ref BtdrvAddress
                    unused2: [3] u8; ///< Unused
                    report:  BtdrvHidData;
                }; ///< [1.0.0-6.2.0]

                v7: struct {
                    unused:  [3] u8; ///< Unused
                    addr:    BtdrvAddress; ///< \ref BtdrvAddress
                    unused2: [3] u8; ///< Unused
                    report:  BtdrvHidData;
                }; ///< [7.0.0-8.1.1]

                v9: struct {
                    res:    u32; ///< Always 0.
                    unk_x4: u8; ///< Always 0.
                    addr:   BtdrvAddress; ///< \ref BtdrvAddress
                    pad:    u8; ///< Padding
                    report: BtdrvHidReport;
                }; ///< [9.0.0+]
            }
        }; ///< ::BtdrvHidEventType_DataReport

        set_report:  struct {
            union {
                rawdata: [12] u8; ///< Raw data.

                struct {
                    res:  u32; ///< 0 = success, non-zero = error.
                    addr: BtdrvAddress; ///< \ref BtdrvAddress
                    pad:  [2] u8; ///< Padding
                }
            }
        }; ///< ::BtdrvHidEventType_SetReport

        get_report:  struct {
            union {
                v1: union {
                    rawdata: [656] u8; ///< Raw data.

                    struct {
                        addr:   BtdrvAddress; ///< \ref BtdrvAddress
                        pad:    [2] u8; ///< Padding
                        res:    u32; ///< Unknown. hid-sysmodule only uses the below data when this field is 0.
                        report: BtdrvHidData; ///< \ref BtdrvHidData
                        pad2:   [2] u8; ///< Padding
                    }
                }; ///< [1.0.0-8.1.1]

                v9: union {
                    rawdata: [712] u8; ///< Raw data.

                    struct {
                        res:    u32; ///< Unknown. hid-sysmodule only uses the below report when this field is 0.
                        addr:   BtdrvAddress; ///< \ref BtdrvAddress
                        report: BtdrvHidReport; ///< \ref BtdrvHidReport
                    }
                }; ///< [9.0.0+]
            }
        }; ///< ::BtdrvHidEventType_GetReport
    }
}

/// The raw sharedmem data for HidReportEventInfo.
BtdrvHidReportEventInfoBufferData :: struct {
    hdr:  struct {
        type: u8; ///< \ref BtdrvHidEventType
        pad:  [7] u8;
        tick: u64;
        size: u64;
    };

    data: BtdrvHidReportEventInfo;
}

/// Data for \ref btdrvGetAudioEventInfo. The data stored here depends on the \ref BtdrvAudioEventType.
BtdrvAudioEventInfo :: union {
    connection: struct {
        status: u32; ///< Status: 0 = AV connection closed, 1 = AV connection opened, 2 = failed to open AV connection.
        addr:   BtdrvAddress; ///< Device address.
        pad:    [2] u8; ///< Padding
    }; ///< ::BtdrvAudioEventType_Connection
}

/// CircularBuffer
BtdrvCircularBuffer :: struct {
    mutex:        Mutex;
    event_type:   *void; ///< Not set with sharedmem.
    data:         [10000] u8;
    write_offset: s32;
    read_offset:  s32;
    utilization:  u64;
    name:         [17] u8;
    initialized:  u8;
}

/// Data for \ref btdrvGetBleManagedEventInfo and \ref btdrvGetLeHidEventInfo. The data stored here depends on the \ref BtdrvBleEventType.
BtdrvBleEventInfo :: struct {
    union {
        data:                            [1024] u8;

        client_registration:             struct {
            result:    u32; ///< 0 for success, non-zero for error.
            client_if: u8; ///< Client interface handle
            status:    u8; ///< Registration status. 0 = Unregistered, 1 = Registered
            pad:       [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ClientRegistration

        server_registration:             struct {
            result:    u32; ///< 0 for success, non-zero for error.
            server_if: u8; ///< Server interface handle. Unused
            status:    u8; ///< Registration status. 0 = Unregistered, 1 = Registered
            pad:       [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ServerRegistration

        connection_update:               struct {
            result:           u32; ///< 0 for success, non-zero for error.
            conn_id:          u32; ///< Connection ID
            conn_interval:    u16; ///< Connection interval
            conn_latency:     u16; ///< Connection latency
            supervision_tout: u16; ///< Connection supervision timeout multiplier
            pad:              [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ConnectionUpdate

        preferred_connection_parameters: struct {
            conn_id:           u32; ///< Connection ID
            min_conn_interval: u16; ///< Minimum connection interval
            max_conn_interval: u16; ///< Maximum connection interval
            slave_latency:     u16; ///< Slave latency
            supervision_tout:  u16; ///< Connection supervision timeout multiplier
        }; ///< ::BtdrvBleEventType_PreferredConnectionParameters

        client_connection:               struct {
            result:    u32; ///< 0 for success, non-zero for error.
            status:    u8; ///< Connection status. 0 = Connected, 2 = Disconnected
            client_if: u8; ///< Client interface handle
            pad:       [2] u8; ///< Padding
            conn_id:   u32; ///< Connection ID
            address:   BtdrvAddress; ///< Device address
            reason:    u16; ///< Disconnection reason
        }; ///< ::BtdrvBleEventType_ClientConnection

        server_connection:               struct {
            result:    u32; ///< 0 for success, non-zero for error.
            status:    u8; ///< Connection status. 0 = Connected, 2 = Disconnected
            server_if: u16; ///< Server interface handle
            pad:       u8; ///< Padding
            conn_id:   u32; ///< Connection ID
            address:   BtdrvAddress; ///< Device address
            reason:    u16; ///< Disconnection reason
        }; ///< ::BtdrvBleEventType_ServerConnection

        scan_result:                     struct {
            result:        u32; ///< 0 for success, non-zero for error.
            status:        u8; ///< BLE scan status. 1 = Scan complete, 2 = New device found, 0xFF = Scan started
            device_type:   u8; ///< Device type. 0 = BD/EDR, 1 = BLE, 2 = Dual Mode
            ble_addr_type: u8; ///< BLE address type. 0 = Public, 1 = Random, 2 = Public ID, 3 = Random ID
            address:       BtdrvAddress; ///< Device address
            ad_list:       [10] BtdrvBleAdvertisement; ///< BLE Advertisement list \ref BtdrvBleAdvertisement
            count:         u8; ///< Number of entries above
            rssi:          s32; ///< RSSI value
        }; ///< ::BtdrvBleEventType_ScanResult

        scan_filter:                     struct {
            result: u32; ///< 0 for success, non-zero for error.
            action: u32; ///< Scan filter action. 0 = Add, 1 = Delete, 2 = Clear, 3 = Enable, 4 = Disable
        }; ///< ::BtdrvBleEventType_ScanFilter

        client_notify:                   struct {
            result:    u32; ///< 0 for success, non-zero for error.
            conn_id:   u32; ///< Connection ID
            type:      u8; ///< Notification type. 4 = Notification, 5 = Indication.
            pad:       [3] u8; ///< Padding
            serv_uuid: BtdrvGattAttributeUuid; ///< GATT Service UUID \ref BtdrvGattAttributeUuid
            char_uuid: BtdrvGattAttributeUuid; ///< GATT Characteristic UUID \ref BtdrvGattAttributeUuid
            desc_uuid: BtdrvGattAttributeUuid; ///< GATT Descriptor UUID \ref BtdrvGattAttributeUuid
            size:      u16; ///< Size of the below data
            data:      [512] u8; ///< Notification data.
            pad2:      [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ClientNotify

        client_cache_save:               struct {
            result:    u32; ///< 0 for success, non-zero for error.
            conn_id:   u32; ///< Connection ID
            count:     u32; ///< Number of attributes below.
            attr_list: [10] BtdrvGattAttribute; ///< List of Gatt attributes \ref BtdrvGattAttribute
        }; ///< ::BtdrvBleEventType_ClientCacheSave

        client_cache_load:               struct {
            result:  u32; ///< 0 for success, non-zero for error.
            conn_id: u32; ///< Connection ID
            unk_x8:  u16; ///< Unknown. Always 0
            unused:  [322] u8; ///< Unused
        }; ///< ::BtdrvBleEventType_ClientCacheLoad

        client_configure_mtu:            struct {
            result:  u32; ///< 0 for success, non-zero for error.
            conn_id: u32; ///< Connection ID
            mtu:     u16; ///< MTU value
            pad:     [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ClientConfigureMtu

        server_add_characteristic:       struct {
            result:     u32; ///< 0 for success, non-zero for error.
            server_if:  u32; ///< Server interface handle
            uuid:       BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
            service_id: u16; ///< Service ID
            attr_id:    u16; ///< Attribute ID
            attr_type:  u8; ///< Attribute type \ref BtdrvGattAttributeType
            property:   u8; ///< Characteristic properties. Only set if attr_type is 1 \ref BtdrvGattCharacteristicProperty
            is_primary: u8; ///< Is a primary service or not
            pad:        u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ServerAddCharacteristic

        server_write:                    struct {
            result:     u32; ///< 0 for success, non-zero for error.
            conn_id:    u16; ///< Connection ID
            unk_x6:     u8; ///< Unknown. Always 1
            pad:        u8; ///< Padding
            service_id: u16; ///< Service ID
            attr_id:    u16; ///< Attribute ID
            attr_type:  u8; ///< Attribute type \ref BtdrvGattAttributeType
            data:       [512] u8; ///< Data
            size:       u16; ///< Size of the above data
            offset:     u16; ///< Offset
            pad2:       [2] u8; ///< Padding
        }; ///< ::BtdrvBleEventType_ServerWrite
    }
}

/// Initialize btdrv.
btdrvInitialize :: () -> Result #foreign libnx;

/// Exit btdrv.
btdrvExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual btdrv service session.
btdrvGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief InitializeBluetooth
* @note This is used by btm-sysmodule, this should not be used by other processes.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btdrvInitializeBluetooth :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief EnableBluetooth
* @note This is used by btm-sysmodule.
*/
btdrvEnableBluetooth :: () -> Result #foreign libnx;

/**
* @brief DisableBluetooth
* @note This is used by btm-sysmodule.
*/
btdrvDisableBluetooth :: () -> Result #foreign libnx;

/**
* @brief FinalizeBluetooth
* @note This is not used by btm-sysmodule, this should not be used by other processes.
*/
btdrvFinalizeBluetooth :: () -> Result #foreign libnx;

/**
* @brief GetAdapterProperties [1.0.0-11.0.1]
* @param[out] properties \ref BtdrvAdapterPropertyOld
*/
btdrvLegacyGetAdapterProperties :: (properties: *BtdrvAdapterPropertyOld) -> Result #foreign libnx;

/**
* @brief GetAdapterProperties [12.0.0+]
* @param[out] properties \ref BtdrvAdapterPropertySet
*/
btdrvGetAdapterProperties :: (properties: *BtdrvAdapterPropertySet) -> Result #foreign libnx;

/**
* @brief GetAdapterProperty [1.0.0-11.0.1]
* @param[in] type \ref BtdrvBluetoothPropertyType
* @param[out] buffer Output buffer, see \ref BtdrvBluetoothPropertyType for the contents.
* @param[in] size Output buffer size.
*/
btdrvLegacyGetAdapterProperty :: (type: BtdrvBluetoothPropertyType, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief GetAdapterProperty [12.0.0+]
* @param[in] type \ref BtdrvAdapterPropertyType
* @param[in] property \ref BtdrvAdapterProperty
*/
btdrvGetAdapterProperty :: (type: BtdrvAdapterPropertyType, property: *BtdrvAdapterProperty) -> Result #foreign libnx;

/**
* @brief SetAdapterProperty [1.0.0-11.0.1]
* @param[in] type \ref BtdrvBluetoothPropertyType
* @param[in] buffer Input buffer, see \ref BtdrvBluetoothPropertyType for the contents.
* @param[in] size Input buffer size.
*/
btdrvLegacySetAdapterProperty :: (type: BtdrvBluetoothPropertyType, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief SetAdapterProperty [12.0.0+]
* @param[in] type \ref BtdrvAdapterPropertyType
* @param[in] property \ref BtdrvAdapterProperty
*/
btdrvSetAdapterProperty :: (type: BtdrvAdapterPropertyType, property: *BtdrvAdapterProperty) -> Result #foreign libnx;

/**
* @brief StartInquiry [1.0.0-11.0.1]. This starts Inquiry, the output data will be available via \ref btdrvGetEventInfo. Inquiry will automatically stop in 10.24 seconds.
* @note This is used by btm-sysmodule.
*/
btdrvLegacyStartInquiry :: () -> Result #foreign libnx;

/**
* @brief StartInquiry [12.0.0+]. This starts Inquiry, the output data will be available via \ref btdrvGetEventInfo.
* @param[in] services Bitfield of allowed services. When -1 the original defaults from pre-12.0.0 are used.
* @param[in] duration Inquiry duration in nanoseconds.
* @note This is used by btm-sysmodule.
*/
btdrvStartInquiry :: (services: u32, duration: s64) -> Result #foreign libnx;

/**
* @brief This stops Inquiry which was started by \ref btdrvStartInquiry, if it's still active.
* @note This is used by btm-sysmodule.
*/
btdrvStopInquiry :: () -> Result #foreign libnx;

/**
* @brief CreateBond
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] type TransportType
*/
btdrvCreateBond :: (addr: BtdrvAddress, type: u32) -> Result #foreign libnx;

/**
* @brief RemoveBond
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
*/
btdrvRemoveBond :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief CancelBond
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
*/
btdrvCancelBond :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief RespondToPinRequest [1.0.0-11.0.1]
* @note The official sysmodule only uses the input \ref BtdrvAddress.
* @param[in] addr \ref BtdrvAddress
* @param[in] flag Flag
* @param[in] pin_code \ref BtdrvBluetoothPinCode
* @param[in] length Length of pin_code
*/
btdrvLegacyRespondToPinRequest :: (addr: BtdrvAddress, flag: bool, pin_code: *BtdrvBluetoothPinCode, length: u8) -> Result #foreign libnx;

/**
* @brief RespondToPinRequest [12.0.0+]
* @param[in] addr \ref BtdrvAddress
* @param[in] pin_code \ref BtdrvPinCode
*/
btdrvRespondToPinRequest :: (addr: BtdrvAddress, pin_code: *BtdrvPinCode) -> Result #foreign libnx;

/**
* @brief RespondToSspRequest
* @note The official sysmodule only uses the input \ref BtdrvAddress and the flag.
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] variant BluetoothSspVariant
* @param[in] accept Whether the request is accepted.
* @param[in] passkey Passkey.
*/
btdrvRespondToSspRequest :: (addr: BtdrvAddress, variant: u32, accept: bool, passkey: u32) -> Result #foreign libnx;

/**
* @brief GetEventInfo
* @note This is used by btm-sysmodule.
* @param[out] buffer Output buffer, see \ref BtdrvEventInfo.
* @param[in] size Output buffer size.
* @param[out] type Output BtdrvEventType.
*/
btdrvGetEventInfo :: (buffer: *void, size: u64, type: *BtdrvEventType) -> Result #foreign libnx;

/**
* @brief InitializeHid
* @note This is used by btm-sysmodule, this should not be used by other processes.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btdrvInitializeHid :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief OpenHidConnection
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
*/
btdrvOpenHidConnection :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief CloseHidConnection
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
*/
btdrvCloseHidConnection :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief This sends a HID DATA transaction packet with report-type Output.
* @param[in] addr \ref BtdrvAddress
* @param[in] buffer Input \ref BtdrvHidReport, on pre-9.0.0 this is \ref BtdrvHidData.
*/
btdrvWriteHidData :: (addr: BtdrvAddress, buffer: *BtdrvHidReport) -> Result #foreign libnx;

/**
* @brief WriteHidData2
* @param[in] addr \ref BtdrvAddress
* @param[in] buffer Input buffer, same as the buffer for \ref btdrvWriteHidData.
* @param[in] size Input buffer size.
*/
btdrvWriteHidData2 :: (addr: BtdrvAddress, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief This sends a HID SET_REPORT transaction packet.
* @param[in] addr \ref BtdrvAddress
* @param[in] type \ref BtdrvBluetoothHhReportType
* @param[in] buffer Input \ref BtdrvHidReport, on pre-9.0.0 this is \ref BtdrvHidData.
*/
btdrvSetHidReport :: (addr: BtdrvAddress, type: BtdrvBluetoothHhReportType, buffer: *BtdrvHidReport) -> Result #foreign libnx;

/**
* @brief This sends a HID GET_REPORT transaction packet.
* @param[in] addr \ref BtdrvAddress
* @param[in] report_id This is sent in the packet for the Report Id, when non-zero.
* @param[in] type \ref BtdrvBluetoothHhReportType
*/
btdrvGetHidReport :: (addr: BtdrvAddress, report_id: u8, type: BtdrvBluetoothHhReportType) -> Result #foreign libnx;

/**
* @brief TriggerConnection
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] unk [9.0.0+] Unknown
*/
btdrvTriggerConnection :: (addr: BtdrvAddress, unk: u16) -> Result #foreign libnx;

/**
* @brief AddPairedDeviceInfo
* @note This is used by btm-sysmodule.
* @param[in] settings \ref SetSysBluetoothDevicesSettings
*/
btdrvAddPairedDeviceInfo :: (settings: *SetSysBluetoothDevicesSettings) -> Result #foreign libnx;

/**
* @brief GetPairedDeviceInfo
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[out] settings \ref SetSysBluetoothDevicesSettings
*/
btdrvGetPairedDeviceInfo :: (addr: BtdrvAddress, settings: *SetSysBluetoothDevicesSettings) -> Result #foreign libnx;

/**
* @brief FinalizeHid
* @note This is not used by btm-sysmodule, this should not be used by other processes.
*/
btdrvFinalizeHid :: () -> Result #foreign libnx;

/**
* @brief GetHidEventInfo
* @note This is used by btm-sysmodule.
* @param[out] buffer Output buffer, see \ref BtdrvHidEventInfo.
* @param[in] size Output buffer size.
* @param[out] type \ref BtdrvHidEventType, always ::BtdrvHidEventType_Connection or ::BtdrvHidEventType_Ext.
*/
btdrvGetHidEventInfo :: (buffer: *void, size: u64, type: *BtdrvHidEventType) -> Result #foreign libnx;

/**
* @brief SetTsi
* @note The response will be available via \ref btdrvGetHidEventInfo ([12.0.0+] \ref btdrvGetEventInfo).
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] tsi Tsi: non-value-0xFF to Set, value 0xFF to Exit. See also \ref BtmTsiMode.
*/
btdrvSetTsi :: (addr: BtdrvAddress, tsi: u8) -> Result #foreign libnx;

/**
* @brief EnableBurstMode
* @note The response will be available via \ref btdrvGetHidEventInfo ([12.0.0+] \ref btdrvGetEventInfo).
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] flag Flag: true = Set, false = Exit.
*/
btdrvEnableBurstMode :: (addr: BtdrvAddress, flag: bool) -> Result #foreign libnx;

/**
* @brief SetZeroRetransmission
* @note The response will be available via \ref btdrvGetHidEventInfo ([12.0.0+] \ref btdrvGetEventInfo).
* @note This is used by btm-sysmodule.
* @param[in] addr \ref BtdrvAddress
* @param[in] report_ids Input buffer containing an array of u8s.
* @param[in] count Total u8s in the input buffer. This can be 0, the max is 5.
*/
btdrvSetZeroRetransmission :: (addr: BtdrvAddress, report_ids: *u8, count: u8) -> Result #foreign libnx;

/**
* @brief EnableMcMode
* @note This is used by btm-sysmodule.
* @param[in] flag Flag
*/
btdrvEnableMcMode :: (flag: bool) -> Result #foreign libnx;

/**
* @brief EnableLlrScan
* @note This is used by btm-sysmodule.
*/
btdrvEnableLlrScan :: () -> Result #foreign libnx;

/**
* @brief DisableLlrScan
* @note This is used by btm-sysmodule.
*/
btdrvDisableLlrScan :: () -> Result #foreign libnx;

/**
* @brief EnableRadio
* @note This is used by btm-sysmodule.
* @param[in] flag Flag
*/
btdrvEnableRadio :: (flag: bool) -> Result #foreign libnx;

/**
* @brief SetVisibility
* @note This is used by btm-sysmodule.
* @param[in] inquiry_scan Controls Inquiry Scan, whether the device can be discovered during Inquiry.
* @param[in] page_scan Controls Page Scan, whether the device accepts connections.
*/
btdrvSetVisibility :: (inquiry_scan: bool, page_scan: bool) -> Result #foreign libnx;

/**
* @brief EnableTbfcScan
* @note Only available on [4.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] flag Flag
*/
btdrvEnableTbfcScan :: (flag: bool) -> Result #foreign libnx;

/**
* @brief RegisterHidReportEvent
* @note This also does sharedmem init/handling if needed, on [7.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true. This is signaled when data is available with \ref btdrvGetHidReportEventInfo.
*/
btdrvRegisterHidReportEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetHidReportEventInfo
* @note \ref btdrvRegisterHidReportEvent must be used before this, on [7.0.0+].
* @note This is used by hid-sysmodule. When used by other processes, hid/user-process will conflict. No events will be received by that user-process, or it will be corrupted, etc.
* @note [7.0.0+] When data isn't available, the type is set to ::BtdrvHidEventType_Data, with the buffer cleared to all-zero.
* @param[out] buffer Output buffer, see \ref BtdrvHidReportEventInfo.
* @param[in] size Output buffer size.
* @param[out] type \ref BtdrvHidEventType
*/
btdrvGetHidReportEventInfo :: (buffer: *void, size: u64, type: *BtdrvHidEventType) -> Result #foreign libnx;

/// Gets the SharedMemory addr for HidReportEventInfo (\ref BtdrvCircularBuffer), only valid when \ref btdrvRegisterHidReportEvent was previously used, on [7.0.0+].
btdrvGetHidReportEventInfoSharedmemAddr :: () -> *void #foreign libnx;

/**
* @brief GetLatestPlr
* @param[out] out Output \ref BtdrvPlrList, on pre-9.0.0 this is \ref BtdrvPlrStatistics.
*/
btdrvGetLatestPlr :: (out: *BtdrvPlrList) -> Result #foreign libnx;

/**
* @brief GetPendingConnections
* @note The output data will be available via \ref btdrvGetHidEventInfo ([12.0.0+] \ref btdrvGetEventInfo).
* @note This is used by btm-sysmodule.
* @note Only available on [3.0.0+].
*/
btdrvGetPendingConnections :: () -> Result #foreign libnx;

/**
* @brief GetChannelMap
* @note Only available on [3.0.0+].
* @param[out] out \ref BtdrvChannelMapList
*/
btdrvGetChannelMap :: (out: *BtdrvChannelMapList) -> Result #foreign libnx;

/**
* @brief EnableTxPowerBoostSetting
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
btdrvEnableTxPowerBoostSetting :: (flag: bool) -> Result #foreign libnx;

/**
* @brief IsTxPowerBoostSettingEnabled
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
btdrvIsTxPowerBoostSettingEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EnableAfhSetting
* @note Only available on [3.0.0+].
* @param[in] flag Input flag.
*/
btdrvEnableAfhSetting :: (flag: bool) -> Result #foreign libnx;

/**
* @brief IsAfhSettingEnabled
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
btdrvIsAfhSettingEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief InitializeBle
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btdrvInitializeBle :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief EnableBle
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
*/
btdrvEnableBle :: () -> Result #foreign libnx;

/**
* @brief DisableBle
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
*/
btdrvDisableBle :: () -> Result #foreign libnx;

/**
* @brief FinalizeBle
* @note Only available on [5.0.0+].
*/
btdrvFinalizeBle :: () -> Result #foreign libnx;

/**
* @brief SetBleVisibility
* @note Only available on [5.0.0+].
* @param[in] discoverable Whether the BLE device is discoverable.
* @param[in] connectable Whether the BLE device is connectable.
*/
btdrvSetBleVisibility :: (discoverable: bool, connectable: bool) -> Result #foreign libnx;

/**
* @brief SetLeConnectionParameter
* @note Only available on [5.0.0-8.1.1]. This is the older version of \ref btdrvSetBleConnectionParameter.
* @param[in] param \ref BtdrvLeConnectionParams
*/
btdrvSetLeConnectionParameter :: (param: *BtdrvLeConnectionParams) -> Result #foreign libnx;

/**
* @brief SetBleConnectionParameter
* @note Only available on [9.0.0+]. This is the newer version of \ref btdrvSetLeConnectionParameter.
* @param[in] addr \ref BtdrvAddress
* @param[in] param \ref BtdrvBleConnectionParameter
* @param[in] preference Unused
*/
btdrvSetBleConnectionParameter :: (addr: BtdrvAddress, param: *BtdrvBleConnectionParameter, preference: bool) -> Result #foreign libnx;

/**
* @brief SetLeDefaultConnectionParameter
* @note Only available on [5.0.0-8.1.1]. This is the older version of \ref btdrvSetBleDefaultConnectionParameter.
* @param[in] param \ref BtdrvLeConnectionParams
*/
btdrvSetLeDefaultConnectionParameter :: (param: *BtdrvLeConnectionParams) -> Result #foreign libnx;

/**
* @brief SetBleDefaultConnectionParameter
* @note Only available on [9.0.0+]. This is the newer version of \ref btdrvSetLeDefaultConnectionParameter.
* @param[in] param \ref BtdrvBleConnectionParameter
*/
btdrvSetBleDefaultConnectionParameter :: (param: *BtdrvBleConnectionParameter) -> Result #foreign libnx;

/**
* @brief SetBleAdvertiseData
* @note Only available on [5.0.0+].
* @param[in] data \ref BtdrvBleAdvertisePacketData
*/
btdrvSetBleAdvertiseData :: (data: *BtdrvBleAdvertisePacketData) -> Result #foreign libnx;

/**
* @brief SetBleAdvertiseParameter
* @note Only available on [5.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] min_interval Minimum advertisement interval
* @param[in] max_interval Maximum advertisement interval
*/
btdrvSetBleAdvertiseParameter :: (addr: BtdrvAddress, min_interval: u16, max_interval: u16) -> Result #foreign libnx;

/**
* @brief StartBleScan
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
*/
btdrvStartBleScan :: () -> Result #foreign libnx;

/**
* @brief StopBleScan
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
*/
btdrvStopBleScan :: () -> Result #foreign libnx;

/**
* @brief AddBleScanFilterCondition
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] filter \ref BtdrvBleAdvertiseFilter
*/
btdrvAddBleScanFilterCondition :: (filter: *BtdrvBleAdvertiseFilter) -> Result #foreign libnx;

/**
* @brief DeleteBleScanFilterCondition
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] filter \ref BtdrvBleAdvertiseFilter
*/
btdrvDeleteBleScanFilterCondition :: (filter: *BtdrvBleAdvertiseFilter) -> Result #foreign libnx;

/**
* @brief DeleteBleScanFilter
* @note Only available on [5.0.0+].
* @param[in] index Filter index
*/
btdrvDeleteBleScanFilter :: (index: u8) -> Result #foreign libnx;

/**
* @brief ClearBleScanFilters
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
*/
btdrvClearBleScanFilters :: () -> Result #foreign libnx;

/**
* @brief EnableBleScanFilter
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] flag Flag
*/
btdrvEnableBleScanFilter :: (flag: bool) -> Result #foreign libnx;

/**
* @brief RegisterGattClient
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvRegisterGattClient :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief UnregisterGattClient
* @note Only available on [5.0.0+].
* @param[in] client_if Client interface ID
*/
btdrvUnregisterGattClient :: (client_if: u8) -> Result #foreign libnx;

/**
* @brief UnregisterAllGattClients
* @note Only available on [5.0.0+].
*/
btdrvUnregisterAllGattClients :: () -> Result #foreign libnx;

/**
* @brief ConnectGattServer
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] client_if Client interface ID
* @param[in] addr \ref BtdrvAddress
* @param[in] is_direct Whether a direct connection or a background auto connection
* @param[in] AppletResourceUserId AppletResourceUserId
*/
btdrvConnectGattServer :: (client_if: u8, addr: BtdrvAddress, is_direct: bool, AppletResourceUserId: u64) -> Result #foreign libnx;

/**
* @brief CancelConnectGattServer
* @note Only available on [5.1.0+].
* @note This is used by btm-sysmodule.
* @param[in] client_if Client interface ID
* @param[in] addr \ref BtdrvAddress
* @param[in] is_direct Whether a direct connection or a background auto connection
*/
btdrvCancelConnectGattServer :: (client_if: u8, addr: BtdrvAddress, is_direct: bool) -> Result #foreign libnx;

/**
* @brief DisconnectGattServer
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] conn_id Connection ID
*/
btdrvDisconnectGattServer :: (conn_id: u32) -> Result #foreign libnx;

/**
* @brief GetGattAttribute
* @note Only available on [5.0.0+].
* @param[in] addr \ref BtdrvAddress, only used on pre-9.0.0.
* @param[in] conn_id Connection ID
*/
btdrvGetGattAttribute :: (addr: BtdrvAddress, conn_id: u32) -> Result #foreign libnx;

/**
* @brief GetGattService
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvGetGattService :: (conn_id: u32, uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief ConfigureAttMtu
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] conn_id Connection ID
* @param[in] mtu MTU
*/
btdrvConfigureAttMtu :: (conn_id: u32, mtu: u16) -> Result #foreign libnx;

/**
* @brief RegisterGattServer
* @note Only available on [5.0.0+].
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvRegisterGattServer :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief UnregisterGattServer
* @note Only available on [5.0.0+].
* @param[in] server_if Server interface ID
*/
btdrvUnregisterGattServer :: (server_if: u8) -> Result #foreign libnx;

/**
* @brief ConnectGattClient
* @note Only available on [5.0.0+].
* @param[in] server_if Server interface ID
* @param[in] addr \ref BtdrvAddress
* @param[in] is_direct Whether a direct connection or a background auto connection
*/
btdrvConnectGattClient :: (server_if: u8, addr: BtdrvAddress, is_direct: bool) -> Result #foreign libnx;

/**
* @brief DisconnectGattClient
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] addr \ref BtdrvAddress, only used on pre-9.0.0.
*/
btdrvDisconnectGattClient :: (conn_id: u8, addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief AddGattService
* @note Only available on [5.0.0+].
* @param[in] server_if Server interface ID
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[in] num_handle Number of handles
* @param[in] is_primary Is a primary service or not
*/
btdrvAddGattService :: (server_if: u8, uuid: *BtdrvGattAttributeUuid, num_handle: u8, is_primary: bool) -> Result #foreign libnx;

/**
* @brief EnableGattService
* @note Only available on [5.0.0+].
* @param[in] service_id Service ID
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvEnableGattService :: (service_id: u8, uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief AddGattCharacteristic
* @note Only available on [5.0.0+].
* @param[in] service_id Service ID
* @param[in] serv_uuid Service UUID \ref BtdrvGattAttributeUuid
* @param[in] char_uuid Characteristic UUID \ref BtdrvGattAttributeUuid
* @param[in] permissions \ref BtdrvGattAttributePermission
* @param[in] property \ref BtdrvGattCharacteristicProperty
*/
btdrvAddGattCharacteristic :: (service_id: u8, serv_uuid: *BtdrvGattAttributeUuid, char_uuid: *BtdrvGattAttributeUuid, permissions: u8, property: u16) -> Result #foreign libnx;

/**
* @brief AddGattDescriptor
* @note Only available on [5.0.0+].
* @param[in] service_id Service ID
* @param[in] serv_uuid Service UUID \ref BtdrvGattAttributeUuid
* @param[in] desc_uuid Descriptor UUID \ref BtdrvGattAttributeUuid
* @param[in] permissions \ref BtdrvGattAttributePermission
*/
btdrvAddGattDescriptor :: (service_id: u8, serv_uuid: *BtdrvGattAttributeUuid, desc_uuid: *BtdrvGattAttributeUuid, permissions: u16) -> Result #foreign libnx;

/**
* @brief GetBleManagedEventInfo
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[out] buffer Output buffer. 0x400-bytes from state is written here. See \ref BtdrvBleEventInfo.
* @param[in] size Output buffer size.
* @param[out] type Output BtdrvBleEventType.
*/
btdrvGetBleManagedEventInfo :: (buffer: *void, size: u64, type: *BtdrvBleEventType) -> Result #foreign libnx;

/**
* @brief GetGattFirstCharacteristic
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] is_primary Is a primary service or not
* @param[in] filter_uuid Characteristic filter UUID \ref BtdrvGattAttributeUuid
* @param[out] out_property Output property \ref BtdrvGattCharacteristicProperty
* @param[out] out_char_id Output characteristic GATT ID \ref BtdrvGattId
*/
btdrvGetGattFirstCharacteristic :: (conn_id: u32, serv_id: *BtdrvGattId, is_primary: bool, filter_uuid: *BtdrvGattAttributeUuid, out_property: *u8, out_char_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief GetGattNextCharacteristic
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] serv_id Service ID \ref BtdrvGattId
* @param[in] is_primary Is a primary service or not
* @param[in] char_id Previous characteristic GATT ID \ref BtdrvGattId
* @param[in] filter_uuid Characteristic filter UUID \ref BtdrvGattAttributeUuid
* @param[out] out_property Output property \ref BtdrvGattCharacteristicProperty
* @param[out] out_char_id Output characteristic GATT ID \ref BtdrvGattId
*/
btdrvGetGattNextCharacteristic :: (conn_id: u32, serv_id: *BtdrvGattId, is_primary: bool, char_id: *BtdrvGattId, filter_uuid: *BtdrvGattAttributeUuid, out_property: *u8, out_char_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief GetGattFirstDescriptor
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] is_primary Is a primary service or not
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] filter_uuid Descriptor filter UUID \ref BtdrvGattAttributeUuid
* @param[out] out_desc_id Output descriptor GATT ID \ref BtdrvGattId
*/
btdrvGetGattFirstDescriptor :: (conn_id: u32, serv_id: *BtdrvGattId, is_primary: bool, char_id: *BtdrvGattId, filter_uuid: *BtdrvGattAttributeUuid, out_desc_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief GetGattNextDescriptor
* @note Only available on [5.0.0+].
* @param[in] conn_id Connection ID
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] is_primary Is a primary service or not
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] desc_id Previous descriptor GATT ID \ref BtdrvGattId
* @param[in] filter_uuid Descriptor filter UUID \ref BtdrvGattAttributeUuid
* @param[out] out_desc_id Output descriptor GATT ID \ref BtdrvGattId
*/
btdrvGetGattNextDescriptor :: (conn_id: u32, serv_id: *BtdrvGattId, is_primary: bool, char_id: *BtdrvGattId, desc_id: *BtdrvGattId, filter_uuid: *BtdrvGattAttributeUuid, out_desc_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief RegisterGattManagedDataPath
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvRegisterGattManagedDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief UnregisterGattManagedDataPath
* @note Only available on [5.0.0+].
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvUnregisterGattManagedDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief RegisterGattHidDataPath
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvRegisterGattHidDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief UnregisterGattHidDataPath
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvUnregisterGattHidDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief RegisterGattDataPath
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvRegisterGattDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief UnregisterGattDataPath
* @note Only available on [5.0.0+].
* @note This is used by btm-sysmodule.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdrvUnregisterGattDataPath :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief ReadGattCharacteristic
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] auth_req \ref BtdrvGattAuthReqType
*/
btdrvReadGattCharacteristic :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId, auth_req: u8) -> Result #foreign libnx;

/**
* @brief ReadGattDescriptor
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] desc_id Descriptor GATT ID \ref BtdrvGattId
* @param[in] auth_req \ref BtdrvGattAuthReqType
*/
btdrvReadGattDescriptor :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId, desc_id: *BtdrvGattId, auth_req: u8) -> Result #foreign libnx;

/**
* @brief WriteGattCharacteristic
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, must be <=0x258.
* @param[in] auth_req \ref BtdrvGattAuthReqType
* @param[in] with_response Whether to use Write-With-Response write type or not
*/
btdrvWriteGattCharacteristic :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId, buffer: *void, size: u64, auth_req: u8, with_response: bool) -> Result #foreign libnx;

/**
* @brief WriteGattDescriptor
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
* @param[in] desc_id Descriptor GATT ID \ref BtdrvGattId
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, must be <=0x258.
* @param[in] auth_req \ref BtdrvGattAuthReqType
*/
btdrvWriteGattDescriptor :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId, desc_id: *BtdrvGattId, buffer: *void, size: u64, auth_req: u8) -> Result #foreign libnx;

/**
* @brief RegisterGattNotification
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
*/
btdrvRegisterGattNotification :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief UnregisterGattNotification
* @note Only available on [5.0.0+].
* @param[in] connection_handle ConnectionHandle
* @param[in] is_primary Is a primary service or not
* @param[in] serv_id Service GATT ID \ref BtdrvGattId
* @param[in] char_id Characteristic GATT ID \ref BtdrvGattId
*/
btdrvUnregisterGattNotification :: (connection_handle: u32, is_primary: bool, serv_id: *BtdrvGattId, char_id: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief GetLeHidEventInfo
* @note Only available on [5.0.0+].
* @note The state used by this is reset after writing the data to output.
* @param[out] buffer Output buffer. 0x400-bytes from state is written here. See \ref BtdrvBleEventInfo.
* @param[in] size Output buffer size.
* @param[out] type \ref BtdrvBleEventType.
*/
btdrvGetLeHidEventInfo :: (buffer: *void, size: u64, type: *BtdrvBleEventType) -> Result #foreign libnx;

/**
* @brief RegisterBleHidEvent
* @note Only available on [5.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btdrvRegisterBleHidEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief SetBleScanParameter
* @note Only available on [5.1.0+].
* @note This is used by btm-sysmodule.
* @param[in] scan_interval Scan interval
* @param[in] scan_window Scan window
*/
btdrvSetBleScanParameter :: (scan_interval: u16, scan_window: u16) -> Result #foreign libnx;

/**
* @brief MoveToSecondaryPiconet
* @note The response will be available via \ref btdrvGetHidEventInfo ([12.0.0+] \ref btdrvGetEventInfo).
* @note Only available on [10.0.0+].
* @param[in] addr \ref BtdrvAddress
*/
btdrvMoveToSecondaryPiconet :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief IsBluetoothEnabled
* @note Only available on [12.0.0+].
* @param[out] out Output flag.
*/
btdrvIsBluetoothEnabled :: (out: *bool) -> Result #foreign libnx;

/**
* @brief AcquireAudioEvent
* @note Only available on [12.0.0+].
* @param[out] out_event Output Event.
* @param[in] autoclear Event autoclear.
*/
btdrvAcquireAudioEvent :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief GetAudioEventInfo
* @note Only available on [12.0.0+].
* @param[out] buffer Output buffer, see \ref BtdrvAudioEventInfo.
* @param[in] size Output buffer size.
* @param[out] type \ref BtdrvAudioEventType.
*/
btdrvGetAudioEventInfo :: (buffer: *void, size: u64, type: *BtdrvAudioEventType) -> Result #foreign libnx;

/**
* @brief OpenAudioConnection
* @note Only available on [12.0.0+].
* @param[in] addr \ref BtdrvAddress
*/
btdrvOpenAudioConnection :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief CloseAudioConnection
* @note Only available on [12.0.0+].
* @param[in] addr \ref BtdrvAddress
*/
btdrvCloseAudioConnection :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief OpenAudioOut
* @note Only available on [12.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[out] audio_handle Audio handle.
*/
btdrvOpenAudioOut :: (addr: BtdrvAddress, audio_handle: *u32) -> Result #foreign libnx;

/**
* @brief CloseAudioOut
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
*/
btdrvCloseAudioOut :: (audio_handle: u32) -> Result #foreign libnx;

/**
* @brief StartAudioOut
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[in] pcm_param \ref BtdrvPcmParameter
* @param[in] in_latency Input latency in nanoseconds.
* @param[out] out_latency Output latency in nanoseconds.
* @param[out] out1 Unknown output.
*/
btdrvStartAudioOut :: (audio_handle: u32, pcm_param: *BtdrvPcmParameter, in_latency: s64, out_latency: *s64, out1: *u64) -> Result #foreign libnx;

/**
* @brief StopAudioOut
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
*/
btdrvStopAudioOut :: (audio_handle: u32) -> Result #foreign libnx;

/**
* @brief GetAudioOutState
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[out] out \ref BtdrvAudioOutState
*/
btdrvGetAudioOutState :: (audio_handle: u32, out: *BtdrvAudioOutState) -> Result #foreign libnx;

/**
* @brief GetAudioOutFeedingCodec
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[out] out \ref BtdrvAudioCodec
*/
btdrvGetAudioOutFeedingCodec :: (audio_handle: u32, out: *BtdrvAudioCodec) -> Result #foreign libnx;

/**
* @brief GetAudioOutFeedingParameter
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[out] out \ref BtdrvPcmParameter
*/
btdrvGetAudioOutFeedingParameter :: (audio_handle: u32, out: *BtdrvPcmParameter) -> Result #foreign libnx;

/**
* @brief AcquireAudioOutStateChangedEvent
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[out] out_event Output Event.
* @param[in] autoclear Event autoclear.
*/
btdrvAcquireAudioOutStateChangedEvent :: (audio_handle: u32, out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief AcquireAudioOutBufferAvailableEvent
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[out] out_event Output Event.
* @param[in] autoclear Event autoclear.
*/
btdrvAcquireAudioOutBufferAvailableEvent :: (audio_handle: u32, out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief SendAudioData
* @note Only available on [12.0.0+].
* @param[in] audio_handle Audio handle from \ref btdrvOpenAudioOut.
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
* @param[out] Output transferred size. This is always either 0 (error occured) or the buffer size.
*/
btdrvSendAudioData :: (audio_handle: u32, buffer: *void, size: u64, transferred_size: *u64) -> Result #foreign libnx;

/**
* @brief AcquireAudioControlInputStateChangedEvent
* @note Only available on [12.0.0+].
* @param[out] out_event Output Event.
* @param[in] autoclear Event autoclear.
*/
btdrvAcquireAudioControlInputStateChangedEvent :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief GetAudioControlInputState
* @note Only available on [12.0.0+].
* @param[out] states Output array of \ref BtdrvAudioControlButtonState.
* @param[in] count Size of the states array in entries, the maximum is 0xF.
* @param[out] total_out Total output entries.
*/
btdrvGetAudioControlInputState :: (states: *BtdrvAudioControlButtonState, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief AcquireAudioConnectionStateChangedEvent
* @note Only available on [12.0.0-13.2.1].
* @param[out] out_event Output Event.
* @param[in] autoclear Event autoclear.
*/
btdrvAcquireAudioConnectionStateChangedEvent :: (out_event: *Event, autoclear: bool) -> Result #foreign libnx;

/**
* @brief GetConnectedAudioDevice
* @note Only available on [12.0.0-13.2.1].
* @param[out] addrs Output array of \ref BtdrvAddress.
* @param[in] count Size of the addrs array in entries, the maximum is 0x8.
* @param[out] total_out Total output entries.
*/
btdrvGetConnectedAudioDevice :: (addrs: *BtdrvAddress, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief CloseAudioControlInput
* @note Only available on [13.0.0+].
* @param[in] addr \ref BtdrvAddress
*/
btdrvCloseAudioControlInput :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief RegisterAudioControlNotification
* @note Only available on [13.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] event_type AvrcEventType
*/
btdrvRegisterAudioControlNotification :: (addr: BtdrvAddress, event_type: u32) -> Result #foreign libnx;

/**
* @brief SendAudioControlPassthroughCommand
* @note Only available on [13.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] op_id AvrcOperationId
* @param[in] state_type AvrcStateType
*/
btdrvSendAudioControlPassthroughCommand :: (addr: BtdrvAddress, op_id: u32, state_type: u32) -> Result #foreign libnx;

/**
* @brief SendAudioControlSetAbsoluteVolumeCommand
* @note Only available on [13.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] val Input value
*/
btdrvSendAudioControlSetAbsoluteVolumeCommand :: (addr: BtdrvAddress, val: s32) -> Result #foreign libnx;

/**
* @brief IsManufacturingMode
* @note Only available on [5.0.0+].
* @param[out] out Output flag.
*/
btdrvIsManufacturingMode :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EmulateBluetoothCrash
* @note Only available on [7.0.0+].
* @param[in] reason \ref BtdrvFatalReason
*/
btdrvEmulateBluetoothCrash :: (reason: BtdrvFatalReason) -> Result #foreign libnx;

/**
* @brief GetBleChannelMap
* @note Only available on [9.0.0+].
* @param[out] out \ref BtdrvChannelMapList
*/
btdrvGetBleChannelMap :: (out: *BtdrvChannelMapList) -> Result #foreign libnx;

/**
* @brief Read
* @note Used by \ref btdrvGetHidReportEventInfo on [7.0.0+].
* @param c \ref BtdrvCircularBuffer
*/
btdrvCircularBufferRead :: (c: *BtdrvCircularBuffer) -> *void #foreign libnx;

/**
* @brief Free
* @note Used by \ref btdrvGetHidReportEventInfo on [7.0.0+].
* @param c \ref BtdrvCircularBuffer
*/
btdrvCircularBufferFree :: (c: *BtdrvCircularBuffer) -> bool #foreign libnx;

/// Initialize bt. Only available on [5.0.0+].
btInitialize :: () -> Result #foreign libnx;

/// Exit bt.
btExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual bt service session.
btGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief LeClientReadCharacteristic
* @note This is essentially the same as \ref btdrvReadGattCharacteristic.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
* @param[in] unk Unknown
*/
btLeClientReadCharacteristic :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId, unk: u8) -> Result #foreign libnx;

/**
* @brief LeClientReadDescriptor
* @note This is essentially the same as \ref btdrvReadGattDescriptor.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
* @param[in] id2 \ref BtdrvGattId
* @param[in] unk Unknown
*/
btLeClientReadDescriptor :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId, id2: *BtdrvGattId, unk: u8) -> Result #foreign libnx;

/**
* @brief LeClientWriteCharacteristic
* @note This is essentially the same as \ref btdrvWriteGattCharacteristic.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, must be <=0x258.
* @param[in] unk Unknown
* @param[in] flag Flag
*/
btLeClientWriteCharacteristic :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId, buffer: *void, size: u64, unk: u8, flag: bool) -> Result #foreign libnx;

/**
* @brief LeClientWriteDescriptor
* @note This is essentially the same as \ref btdrvWriteGattDescriptor.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
* @param[in] id2 \ref BtdrvGattId
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, must be <=0x258.
* @param[in] unk Unknown
*/
btLeClientWriteDescriptor :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId, id2: *BtdrvGattId, buffer: *void, size: u64, unk: u8) -> Result #foreign libnx;

/**
* @brief LeClientRegisterNotification
* @note This is essentially the same as \ref btdrvRegisterGattNotification.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
*/
btLeClientRegisterNotification :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief LeClientDeregisterNotification
* @note This is essentially the same as \ref btdrvUnregisterGattNotification.
* @param[in] connection_handle ConnectionHandle
* @param[in] primary_service PrimaryService
* @param[in] id0 \ref BtdrvGattId
* @param[in] id1 \ref BtdrvGattId
*/
btLeClientDeregisterNotification :: (connection_handle: u32, primary_service: bool, id0: *BtdrvGattId, id1: *BtdrvGattId) -> Result #foreign libnx;

/**
* @brief SetLeResponse
* @param[in] unk Unknown
* @param[in] uuid0 \ref BtdrvGattAttributeUuid
* @param[in] uuid1 \ref BtdrvGattAttributeUuid
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, must be <=0x258.
*/
btSetLeResponse :: (unk: u8, uuid0: *BtdrvGattAttributeUuid, uuid1: *BtdrvGattAttributeUuid, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief LeSendIndication
* @param[in] unk Unknown
* @param[in] uuid0 \ref BtdrvGattAttributeUuid
* @param[in] uuid1 \ref BtdrvGattAttributeUuid
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, clamped to max size 0x258.
* @param[in] flag Flag
*/
btLeSendIndication :: (unk: u8, uuid0: *BtdrvGattAttributeUuid, uuid1: *BtdrvGattAttributeUuid, buffer: *void, size: u64, flag: bool) -> Result #foreign libnx;

/**
* @brief GetLeEventInfo
* @note This is identical to \ref btdrvGetLeHidEventInfo except different state is used.
* @note The state used by this is reset after writing the data to output.
* @param[in] buffer Output buffer. 0x400-bytes from state is written here. See \ref BtdrvLeEventInfo.
* @param[in] size Output buffer size.
* @param[out] type Output BleEventType.
*/
btGetLeEventInfo :: (buffer: *void, size: u64, type: *u32) -> Result #foreign libnx;

/**
* @brief RegisterBleEvent
* @note This is identical to \ref btdrvRegisterBleHidEvent except different state is used.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btRegisterBleEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Initialize btm.
btmInitialize :: () -> Result #foreign libnx;

/// Exit btm.
btmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual btm service session.
btmGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief GetState
* @param[out] out \ref BtmState
*/
btmGetState :: (out: *BtmState) -> Result #foreign libnx;

/**
* @brief GetHostDeviceProperty
* @param[out] out \ref BtmHostDeviceProperty
*/
btmGetHostDeviceProperty :: (out: *BtmHostDeviceProperty) -> Result #foreign libnx;

/**
* @brief AcquireDeviceConditionEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireDeviceConditionEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetDeviceCondition [1.0.0-12.1.0]
* @param[out] out \ref BtmDeviceCondition
*/
btmLegacyGetDeviceCondition :: (out: *BtmDeviceCondition) -> Result #foreign libnx;

/**
* @brief GetDeviceCondition [13.0.0+]
* @param[in] profile \ref BtmProfile, when not ::BtmProfile_None entries are only returned which match this profile.
* @param[out] out \ref BtmConnectedDeviceV13
* @param[in] count Size of the out array in entries.
* @param[out] total_out Total output entries.
*/
btmGetDeviceCondition :: (profile: BtmProfile, out: *BtmConnectedDeviceV13, count: u64, total_out: *s32) -> Result #foreign libnx;

/**
* @brief SetBurstMode
* @param[in] addr \ref BtdrvAddress
* @param[in] flag Flag
*/
btmSetBurstMode :: (addr: BtdrvAddress, flag: bool) -> Result #foreign libnx;

/**
* @brief SetSlotMode
* @param[in] list \ref BtmDeviceSlotModeList
*/
btmSetSlotMode :: (list: *BtmDeviceSlotModeList) -> Result #foreign libnx;

/**
* @brief SetBluetoothMode
* @note Only available on pre-9.0.0.
* @param[in] mode \ref BtmBluetoothMode
*/
btmSetBluetoothMode :: (mode: BtmBluetoothMode) -> Result #foreign libnx;

/**
* @brief SetWlanMode
* @param[in] mode \ref BtmWlanMode
*/
btmSetWlanMode :: (mode: BtmWlanMode) -> Result #foreign libnx;

/**
* @brief AcquireDeviceInfoEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireDeviceInfoEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetDeviceInfo [1.0.0-12.1.0]
* @param[out] out \ref BtmDeviceInfoList
*/
btmLegacyGetDeviceInfo :: (out: *BtmDeviceInfoList) -> Result #foreign libnx;

/**
* @brief GetDeviceInfo [13.0.0+]
* @param[in] profile \ref BtmProfile, when not ::BtmProfile_None entries are only returned which match this profile.
* @param[out] out \ref BtmDeviceInfoV13
* @param[in] count Size of the out array in entries.
* @param[out] total_out Total output entries.
*/
btmGetDeviceInfo :: (profile: BtmProfile, out: *BtmDeviceInfoV13, count: u64, total_out: *s32) -> Result #foreign libnx;

/**
* @brief AddDeviceInfo
* @param[in] info \ref BtmDeviceInfo
*/
btmAddDeviceInfo :: (info: *BtmDeviceInfo) -> Result #foreign libnx;

/**
* @brief RemoveDeviceInfo
* @param[in] addr \ref BtdrvAddress
*/
btmRemoveDeviceInfo :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief IncreaseDeviceInfoOrder
* @param[in] addr \ref BtdrvAddress
*/
btmIncreaseDeviceInfoOrder :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief LlrNotify
* @param[in] addr \ref BtdrvAddress
* @param[in] unk [9.0.0+] Unknown
*/
btmLlrNotify :: (addr: BtdrvAddress, unk: s32) -> Result #foreign libnx;

/**
* @brief EnableRadio
*/
btmEnableRadio :: () -> Result #foreign libnx;

/**
* @brief DisableRadio
*/
btmDisableRadio :: () -> Result #foreign libnx;

/**
* @brief HidDisconnect
* @param[in] addr \ref BtdrvAddress
*/
btmHidDisconnect :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief HidSetRetransmissionMode
* @param[in] addr \ref BtdrvAddress
* @param[in] list \ref BtmZeroRetransmissionList
*/
btmHidSetRetransmissionMode :: (addr: BtdrvAddress, list: *BtmZeroRetransmissionList) -> Result #foreign libnx;

/**
* @brief AcquireAwakeReqEvent
* @note Only available on [2.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireAwakeReqEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief AcquireLlrStateEvent
* @note Only available on [4.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireLlrStateEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief IsLlrStarted
* @note Only available on [4.0.0+].
* @param[out] out Output flag.
*/
btmIsLlrStarted :: (out: *bool) -> Result #foreign libnx;

/**
* @brief EnableSlotSaving
* @note Only available on [4.0.0+].
* @param[in] flag Flag
*/
btmEnableSlotSaving :: (flag: bool) -> Result #foreign libnx;

/**
* @brief ProtectDeviceInfo
* @note Only available on [5.0.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] flag Flag
*/
btmProtectDeviceInfo :: (addr: BtdrvAddress, flag: bool) -> Result #foreign libnx;

/**
* @brief AcquireBleScanEvent
* @note Only available on [5.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireBleScanEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetBleScanParameterGeneral
* @note Only available on [5.1.0+].
* @param[in] parameter_id Must be value 0x1 or 0xFFFF.
* @param[out] out \ref BtdrvBleAdvertisePacketParameter
*/
btmGetBleScanParameterGeneral :: (parameter_id: u16, out: *BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief GetBleScanParameterSmartDevice
* @note Only available on [5.1.0+].
* @param[in] parameter_id Must be value 0x2.
* @param[out] out \ref BtdrvGattAttributeUuid. The first 4-bytes is always 0.
*/
btmGetBleScanParameterSmartDevice :: (parameter_id: u16, out: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief StartBleScanForGeneral
* @note Only available on [5.1.0+].
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmStartBleScanForGeneral :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief StopBleScanForGeneral
* @note Only available on [5.1.0+].
*/
btmStopBleScanForGeneral :: () -> Result #foreign libnx;

/**
* @brief GetBleScanResultsForGeneral
* @note Only available on [5.1.0+].
* @param[out] results Output array of \ref BtdrvBleScanResult.
* @param[in] count Size of the results array in entries. The max is 10.
* @param[out] total_out Total output entries.
*/
btmGetBleScanResultsForGeneral :: (results: *BtdrvBleScanResult, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief StartBleScanForPaired
* @note Only available on [5.1.0+].
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmStartBleScanForPaired :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief StopBleScanForPaired
* @note Only available on [5.1.0+].
*/
btmStopBleScanForPaired :: () -> Result #foreign libnx;

/**
* @brief StartBleScanForSmartDevice
* @note Only available on [5.1.0+].
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btmStartBleScanForSmartDevice :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief StopBleScanForSmartDevice
* @note Only available on [5.1.0+].
*/
btmStopBleScanForSmartDevice :: () -> Result #foreign libnx;

/**
* @brief GetBleScanResultsForSmartDevice
* @note Only available on [5.1.0+].
* @param[out] results Output array of \ref BtdrvBleScanResult.
* @param[in] count Size of the results array in entries. The max is 10.
* @param[out] total_out Total output entries.
*/
btmGetBleScanResultsForSmartDevice :: (results: *BtdrvBleScanResult, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleConnectionEvent
* @note Only available on [5.1.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireBleConnectionEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief BleConnect
* @note Only available on [5.0.0+].
* @note The \ref BtdrvAddress must not be already connected. A maximum of 4 devices can be connected.
* @param[in] addr \ref BtdrvAddress
*/
btmBleConnect :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief BleOverrideConnection
* @note Only available on [5.1.0+].
* @param[in] id Same as \ref btmBleDisconnect.
*/
btmBleOverrideConnection :: (id: u32) -> Result #foreign libnx;

/**
* @brief BleDisconnect
* @note Only available on [5.0.0+].
* @param[in] connection_handle This must match a BtdrvBleConnectionInfo::id from \ref btmBleGetConnectionState. [5.1.0+] 0xFFFFFFFF is invalid.
*/
btmBleDisconnect :: (connection_handle: u32) -> Result #foreign libnx;

/**
* @brief BleGetConnectionState
* @note Only available on [5.0.0+].
* @param[out] info Output array of \ref BtdrvBleConnectionInfo.
* @param[in] count Size of the info array in entries. Other cmds which use this internally use count=4.
* @param[out] total_out Total output entries.
*/
btmBleGetConnectionState :: (info: *BtdrvBleConnectionInfo, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief BleGetGattClientConditionList
* @note Only available on [5.0.0+].
* @param[out] list \ref BtmGattClientConditionList
*/
btmBleGetGattClientConditionList :: (list: *BtmGattClientConditionList) -> Result #foreign libnx;

/**
* @brief AcquireBlePairingEvent
* @note Only available on [5.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireBlePairingEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief BlePairDevice
* @note Only available on [5.1.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmBlePairDevice :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleUnpairDeviceOnBoth
* @note Only available on [5.1.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmBleUnpairDeviceOnBoth :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleUnPairDevice
* @note Only available on [5.1.0+].
* @param[in] addr \ref BtdrvAddress
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmBleUnPairDevice :: (addr: BtdrvAddress, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleGetPairedAddresses
* @note Only available on [5.1.0+].
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
* @param[out] addrs Output array of \ref BtdrvAddress.
* @param[in] count Size of the addrs array in entries.
* @param[out] total_out Total output entries. The max is 10.
*/
btmBleGetPairedAddresses :: (param: BtdrvBleAdvertisePacketParameter, addrs: *BtdrvAddress, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleServiceDiscoveryEvent
* @note Only available on [5.1.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireBleServiceDiscoveryEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetGattServices
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[out] services Output array of \ref BtmGattService.
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmGetGattServices :: (connection_handle: u32, services: *BtmGattService, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Same as \ref btmGetGattServices except this only returns the \ref BtmGattService which matches the input \ref BtdrvGattAttributeUuid.
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[out] service \ref BtmGattService
* @param[out] flag Whether a \ref BtmGattService was returned.
*/
btmGetGattService :: (connection_handle: u32, uuid: *BtdrvGattAttributeUuid, service: *BtmGattService, flag: *bool) -> Result #foreign libnx;

/**
* @brief Same as \ref btmGetGattServices except this only returns \ref BtmGattService entries where various checks pass with u16 fields.
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] service_handle ServiceHandle
* @param[out] services \ref BtmGattService
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] out Output value.
*/
btmGetGattIncludedServices :: (connection_handle: u32, service_handle: u16, services: *BtmGattService, count: u8, out: *u8) -> Result #foreign libnx;

/**
* @brief This is similar to \ref btmGetGattIncludedServices except this only returns 1 \ref BtmGattService.
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] attribute_handle AttributeHandle
* @param[out] service \ref BtmGattService
* @param[out] flag Whether a \ref BtmGattService was returned.
*/
btmGetBelongingService :: (connection_handle: u32, attribute_handle: u16, service: *BtmGattService, flag: *bool) -> Result #foreign libnx;

/**
* @brief GetGattCharacteristics
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] service_handle This controls which \ref BtmGattCharacteristic entries to return.
* @param[out] characteristics \ref BtmGattCharacteristic
* @param[in] count Size of the characteristics array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmGetGattCharacteristics :: (connection_handle: u32, service_handle: u16, characteristics: *BtmGattCharacteristic, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief GetGattDescriptors
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] char_handle Characteristic handle. This controls which \ref BtmGattDescriptor entries to return.
* @param[out] descriptors \ref BtmGattDescriptor
* @param[in] count Size of the descriptors array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmGetGattDescriptors :: (connection_handle: u32, char_handle: u16, descriptors: *BtmGattDescriptor, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleMtuConfigEvent
* @note Only available on [5.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmAcquireBleMtuConfigEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief ConfigureBleMtu
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[in] mtu MTU
*/
btmConfigureBleMtu :: (connection_handle: u32, mtu: u16) -> Result #foreign libnx;

/**
* @brief GetBleMtu
* @note Only available on [5.0.0+].
* @param[in] connection_handle Same as \ref btmBleDisconnect.
* @param[out] out Output MTU.
*/
btmGetBleMtu :: (connection_handle: u32, out: *u16) -> Result #foreign libnx;

/**
* @brief RegisterBleGattDataPath
* @note Only available on [5.0.0+].
* @param[in] path \ref BtmBleDataPath
*/
btmRegisterBleGattDataPath :: (path: *BtmBleDataPath) -> Result #foreign libnx;

/**
* @brief UnregisterBleGattDataPath
* @note Only available on [5.0.0+].
* @param[in] path \ref BtmBleDataPath
*/
btmUnregisterBleGattDataPath :: (path: *BtmBleDataPath) -> Result #foreign libnx;

/**
* @brief RegisterAppletResourceUserId
* @note Only available on [5.0.0+].
* @param[in] AppletResourceUserId AppletResourceUserId
* @param[in] unk Unknown
*/
btmRegisterAppletResourceUserId :: (AppletResourceUserId: u64, unk: u32) -> Result #foreign libnx;

/**
* @brief UnregisterAppletResourceUserId
* @note Only available on [5.0.0+].
* @param[in] AppletResourceUserId AppletResourceUserId
*/
btmUnregisterAppletResourceUserId :: (AppletResourceUserId: u64) -> Result #foreign libnx;

/**
* @brief SetAppletResourceUserId
* @note Only available on [5.0.0+].
* @param[in] AppletResourceUserId AppletResourceUserId
*/
btmSetAppletResourceUserId :: (AppletResourceUserId: u64) -> Result #foreign libnx;

/// Initialize btm:u.
btmuInitialize :: () -> Result #foreign libnx;

/// Exit btm:u.
btmuExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual btm:u service session. This object must be closed by the user once finished using cmds with this.
btmuGetServiceSession :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IBtmUserCore.
btmuGetServiceSession_IBtmUserCore :: () -> *Service #foreign libnx;

/**
* @brief AcquireBleScanEvent
* @note This is similar to \ref btmAcquireBleScanEvent.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmuAcquireBleScanEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetBleScanFilterParameter
* @note This is the same as \ref btmGetBleScanParameterGeneral.
* @param[in] parameter_id Must be value 0x1 or 0xFFFF.
* @param[out] out \ref BtdrvBleAdvertisePacketParameter
*/
btmuGetBleScanFilterParameter :: (parameter_id: u16, out: *BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief GetBleScanFilterParameter2
* @note This is the same as \ref btmGetBleScanParameterSmartDevice.
* @param[in] parameter_id Must be value 0x2.
* @param[out] out \ref BtdrvGattAttributeUuid. The first 4-bytes is always 0.
*/
btmuGetBleScanFilterParameter2 :: (parameter_id: u16, out: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief StartBleScanForGeneral
* @note This is similar to \ref btmStartBleScanForGeneral.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmuStartBleScanForGeneral :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief StopBleScanForGeneral
* @note This is similar to \ref btmStopBleScanForGeneral.
*/
btmuStopBleScanForGeneral :: () -> Result #foreign libnx;

/**
* @brief GetBleScanResultsForGeneral
* @note This is similar to \ref btmGetBleScanResultsForGeneral.
* @param[out] results Output array of \ref BtdrvBleScanResult.
* @param[in] count Size of the results array in entries. The max is 10.
* @param[out] total_out Total output entries.
*/
btmuGetBleScanResultsForGeneral :: (results: *BtdrvBleScanResult, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief StartBleScanForPaired
* @note This is similar to \ref btmStartBleScanForPaired.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmuStartBleScanForPaired :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief StopBleScanForPaired
* @note This is similar to \ref btmStopBleScanForPaired.
*/
btmuStopBleScanForPaired :: () -> Result #foreign libnx;

/**
* @brief StartBleScanForSmartDevice
* @note This is similar to \ref btmStartBleScanForSmartDevice.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btmuStartBleScanForSmartDevice :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief StopBleScanForSmartDevice
* @note This is similar to \ref btmStopBleScanForSmartDevice.
*/
btmuStopBleScanForSmartDevice :: () -> Result #foreign libnx;

/**
* @brief GetBleScanResultsForSmartDevice
* @note This is similar to \ref btmGetBleScanResultsForSmartDevice.
* @param[out] results Output array of \ref BtdrvBleScanResult.
* @param[in] count Size of the results array in entries. The max is 10.
* @param[out] total_out Total output entries.
*/
btmuGetBleScanResultsForSmartDevice :: (results: *BtdrvBleScanResult, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleConnectionEvent
* @note This is similar to \ref btmAcquireBleConnectionEvent.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmuAcquireBleConnectionEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief BleConnect
* @note This is similar to \ref btmBleConnect.
* @param[in] addr \ref BtdrvAddress
*/
btmuBleConnect :: (addr: BtdrvAddress) -> Result #foreign libnx;

/**
* @brief BleDisconnect
* @note This is similar to \ref btmBleDisconnect.
* @param[in] connection_handle This must match a BtdrvBleConnectionInfo::connection_handle from \ref btmuBleGetConnectionState. [5.1.0+] 0xFFFFFFFF is invalid.
*/
btmuBleDisconnect :: (connection_handle: u32) -> Result #foreign libnx;

/**
* @brief BleGetConnectionState
* @note This is similar to \ref btmBleGetConnectionState.
* @param[out] info Output array of \ref BtdrvBleConnectionInfo.
* @param[in] count Size of the info array in entries. Other cmds which use this internally use count=4.
* @param[out] total_out Total output entries.
*/
btmuBleGetConnectionState :: (info: *BtdrvBleConnectionInfo, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBlePairingEvent
* @note This is similar to \ref btmAcquireBlePairingEvent.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmuAcquireBlePairingEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief BlePairDevice
* @note This is similar to \ref btmBlePairDevice.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmuBlePairDevice :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleUnPairDevice
* @note This is similar to \ref btmBleUnpairDeviceOnBoth.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmuBleUnPairDevice :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleUnPairDevice2
* @note This is similar to \ref btmBleUnPairDevice.
* @param[in] addr \ref BtdrvAddress
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
*/
btmuBleUnPairDevice2 :: (addr: BtdrvAddress, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/**
* @brief BleGetPairedDevices
* @note This is similar to \ref btmBleGetPairedAddresses.
* @param[in] param \ref BtdrvBleAdvertisePacketParameter
* @param[out] addrs Output array of \ref BtdrvAddress.
* @param[in] count Size of the addrs array in entries.
* @param[out] total_out Total output entries. The max is 10.
*/
btmuBleGetPairedDevices :: (param: BtdrvBleAdvertisePacketParameter, addrs: *BtdrvAddress, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleServiceDiscoveryEvent
* @note This is similar to \ref btmAcquireBleServiceDiscoveryEvent.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmuAcquireBleServiceDiscoveryEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetGattServices
* @note This is similar to \ref btmGetGattServices.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[out] services Output array of \ref BtmGattService.
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmuGetGattServices :: (connection_handle: u32, services: *BtmGattService, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Same as \ref btmuGetGattServices except this only returns the \ref BtmGattService which matches the input \ref BtdrvGattAttributeUuid.
* @note This is similar to \ref btmGetGattService.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[out] service \ref BtmGattService
* @param[out] flag Whether a \ref BtmGattService was returned.
*/
btmuGetGattService :: (connection_handle: u32, uuid: *BtdrvGattAttributeUuid, service: *BtmGattService, flag: *bool) -> Result #foreign libnx;

/**
* @brief Same as \ref btmuGetGattServices except this only returns \ref BtmGattService entries where various checks pass with u16 fields.
* @note This is similar to \ref btmGetGattIncludedServices.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] service_handle ServiceHandle
* @param[out] services \ref BtmGattService
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] out Output value.
*/
btmuGetGattIncludedServices :: (connection_handle: u32, service_handle: u16, services: *BtmGattService, count: u8, out: *u8) -> Result #foreign libnx;

/**
* @brief This is similar to \ref btmuGetGattIncludedServices except this only returns 1 \ref BtmGattService.
* @note This is similar to \ref btmGetBelongingService.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] attribute_handle AttributeHandle
* @param[out] service \ref BtmGattService
* @param[out] flag Whether a \ref BtmGattService was returned.
*/
btmuGetBelongingGattService :: (connection_handle: u32, attribute_handle: u16, service: *BtmGattService, flag: *bool) -> Result #foreign libnx;

/**
* @brief GetGattCharacteristics
* @note This is similar to \ref btmGetGattCharacteristics.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] service_handle This controls which \ref BtmGattCharacteristic entries to return.
* @param[out] characteristics \ref BtmGattCharacteristic
* @param[in] count Size of the characteristics array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmuGetGattCharacteristics :: (connection_handle: u32, service_handle: u16, characteristics: *BtmGattCharacteristic, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief GetGattDescriptors
* @note This is similar to \ref btmGetGattDescriptors.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] char_handle Characteristic handle. This controls which \ref BtmGattDescriptor entries to return.
* @param[out] descriptors \ref BtmGattDescriptor
* @param[in] count Size of the descriptors array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btmuGetGattDescriptors :: (connection_handle: u32, char_handle: u16, descriptors: *BtmGattDescriptor, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief AcquireBleMtuConfigEvent
* @note This is similar to \ref btmAcquireBleMtuConfigEvent.
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmuAcquireBleMtuConfigEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief ConfigureBleMtu
* @note This is similar to \ref btmConfigureBleMtu.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] mtu MTU
*/
btmuConfigureBleMtu :: (connection_handle: u32, mtu: u16) -> Result #foreign libnx;

/**
* @brief GetBleMtu
* @note This is similar to \ref btmGetBleMtu.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[out] out Output MTU.
*/
btmuGetBleMtu :: (connection_handle: u32, out: *u16) -> Result #foreign libnx;

/**
* @brief RegisterBleGattDataPath
* @note This is similar to \ref btmRegisterBleGattDataPath.
* @param[in] path \ref BtmBleDataPath
*/
btmuRegisterBleGattDataPath :: (path: *BtmBleDataPath) -> Result #foreign libnx;

/**
* @brief UnregisterBleGattDataPath
* @note This is similar to \ref btmUnregisterBleGattDataPath.
* @param[in] path \ref BtmBleDataPath
*/
btmuUnregisterBleGattDataPath :: (path: *BtmBleDataPath) -> Result #foreign libnx;

/// Initialize btm:sys.
btmsysInitialize :: () -> Result #foreign libnx;

/// Exit btm:sys.
btmsysExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual btm:sys service session. This object must be closed by the user once finished using cmds with this.
btmsysGetServiceSession :: (srv_out: *Service) -> Result #foreign libnx;

/// Gets the Service object for IBtmSystemCore.
btmsysGetServiceSession_IBtmSystemCore :: () -> *Service #foreign libnx;

/**
* @brief StartGamepadPairing
*/
btmsysStartGamepadPairing :: () -> Result #foreign libnx;

/**
* @brief CancelGamepadPairing
*/
btmsysCancelGamepadPairing :: () -> Result #foreign libnx;

/**
* @brief ClearGamepadPairingDatabase
*/
btmsysClearGamepadPairingDatabase :: () -> Result #foreign libnx;

/**
* @brief GetPairedGamepadCount
* @param[out] out Output count.
*/
btmsysGetPairedGamepadCount :: (out: *u8) -> Result #foreign libnx;

/**
* @brief EnableRadio
*/
btmsysEnableRadio :: () -> Result #foreign libnx;

/**
* @brief DisableRadio
*/
btmsysDisableRadio :: () -> Result #foreign libnx;

/**
* @brief GetRadioOnOff
* @param[out] out Output flag.
*/
btmsysGetRadioOnOff :: (out: *bool) -> Result #foreign libnx;

/**
* @brief AcquireRadioEvent
* @note Only available on [3.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmsysAcquireRadioEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief AcquireGamepadPairingEvent
* @note Only available on [3.0.0+].
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=true.
*/
btmsysAcquireGamepadPairingEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief IsGamepadPairingStarted
* @note Only available on [3.0.0+].
* @param[out] out Output flag.
*/
btmsysIsGamepadPairingStarted :: (out: *bool) -> Result #foreign libnx;

SplConfigItem :: enum u32 {
    DisableProgramVerification :: 1;
    DramId                     :: 2;
    SecurityEngineIrqNumber    :: 3;
    Version                    :: 4;
    HardwareType               :: 5;
    IsRetail                   :: 6;
    IsRecoveryBoot             :: 7;
    DeviceId                   :: 8;
    BootReason                 :: 9;
    MemoryArrange              :: 10;
    IsDebugMode                :: 11;
    KernelMemoryConfiguration  :: 12;
    IsChargerHiZModeEnabled    :: 13;
    IsKiosk                    :: 14;
    NewHardwareType            :: 15;
    NewKeyGeneration           :: 16;
    Package2Hash               :: 17;
}

RsaKeyVersion :: enum u32 {
    Deprecated :: 0;
    Extended   :: 1;
}

/// Initialize 'spl:'.
splInitialize :: () -> Result #foreign libnx;

/// Exit 'spl:'.
splExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with spl*().
splGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize spl:mig. On pre-4.0.0 this just calls \ref splInitialize.
splCryptoInitialize :: () -> Result #foreign libnx;

/// Exit spl:mig. On pre-4.0.0 this just calls \ref splExit.
splCryptoExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with splCrypto*().
splCryptoGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize spl:ssl. On pre-4.0.0 this just calls \ref splInitialize.
splSslInitialize :: () -> Result #foreign libnx;

/// Exit spl:ssl. On pre-4.0.0 this just calls \ref splExit.
splSslExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with splSsl*().
splSslGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize spl:es. On pre-4.0.0 this just calls \ref splInitialize.
splEsInitialize :: () -> Result #foreign libnx;

/// Exit spl:es. On pre-4.0.0 this just calls \ref splExit.
splEsExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with splEs*().
splEsGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize spl:fs. On pre-4.0.0 this just calls \ref splInitialize.
splFsInitialize :: () -> Result #foreign libnx;

/// Exit spl:fs. On pre-4.0.0 this just calls \ref splExit.
splFsExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with splFs*().
splFsGetServiceSession :: () -> *Service #foreign libnx;

/// Initialize spl:manu. On pre-4.0.0 this just calls \ref splInitialize.
splManuInitialize :: () -> Result #foreign libnx;

/// Exit spl:manu. On pre-4.0.0 this just calls \ref splExit.
splManuExit :: () -> void #foreign libnx;

/// Gets the Service object for the IGeneralInterface usable with splManu*().
splManuGetServiceSession :: () -> *Service #foreign libnx;

splGetConfig :: (config_item: SplConfigItem, out_config: *u64) -> Result #foreign libnx;
splUserExpMod :: (input: *void, modulus: *void, exp: *void, exp_size: u64, dst: *void) -> Result #foreign libnx;
splSetConfig :: (config_item: SplConfigItem, value: u64) -> Result #foreign libnx;
splGetRandomBytes :: (out: *void, out_size: u64) -> Result #foreign libnx;
splIsDevelopment :: (out_is_development: *bool) -> Result #foreign libnx;
splSetBootReason :: (value: u32) -> Result #foreign libnx;
splGetBootReason :: (out_value: *u32) -> Result #foreign libnx;

splCryptoGenerateAesKek :: (wrapped_kek: *void, key_generation: u32, option: u32, out_sealed_kek: *void) -> Result #foreign libnx;
splCryptoLoadAesKey :: (sealed_kek: *void, wrapped_key: *void, keyslot: u32) -> Result #foreign libnx;
splCryptoGenerateAesKey :: (sealed_kek: *void, wrapped_key: *void, out_sealed_key: *void) -> Result #foreign libnx;
splCryptoDecryptAesKey :: (wrapped_key: *void, key_generation: u32, option: u32, out_sealed_key: *void) -> Result #foreign libnx;
splCryptoCryptAesCtr :: (input: *void, output: *void, size: u64, keyslot: u32, ctr: *void) -> Result #foreign libnx;
splCryptoComputeCmac :: (input: *void, size: u64, keyslot: u32, out_cmac: *void) -> Result #foreign libnx;
splCryptoLockAesEngine :: (out_keyslot: *u32) -> Result #foreign libnx;
splCryptoUnlockAesEngine :: (keyslot: u32) -> Result #foreign libnx;
splCryptoGetSecurityEngineEvent :: (out_event: *Event) -> Result #foreign libnx;

splRsaDecryptPrivateKey :: (sealed_kek: *void, wrapped_key: *void, wrapped_rsa_key: *void, wrapped_rsa_key_size: u64, version: RsaKeyVersion, dst: *void, dst_size: u64) -> Result #foreign libnx;

splSslLoadSecureExpModKey :: (sealed_kek: *void, wrapped_key: *void, wrapped_rsa_key: *void, wrapped_rsa_key_size: u64) -> Result #foreign libnx;
splSslSecureExpMod :: (input: *void, modulus: *void, dst: *void) -> Result #foreign libnx;

splEsLoadRsaOaepKey :: (sealed_kek: *void, wrapped_key: *void, wrapped_rsa_key: *void, wrapped_rsa_key_size: u64, version: RsaKeyVersion) -> Result #foreign libnx;
splEsUnwrapRsaOaepWrappedTitlekey :: (rsa_wrapped_titlekey: *void, modulus: *void, label_hash: *void, label_hash_size: u64, key_generation: u32, out_sealed_titlekey: *void) -> Result #foreign libnx;
splEsUnwrapAesWrappedTitlekey :: (aes_wrapped_titlekey: *void, key_generation: u32, out_sealed_titlekey: *void) -> Result #foreign libnx;
splEsLoadSecureExpModKey :: (sealed_kek: *void, wrapped_key: *void, wrapped_rsa_key: *void, wrapped_rsa_key_size: u64) -> Result #foreign libnx;
splEsSecureExpMod :: (input: *void, modulus: *void, dst: *void) -> Result #foreign libnx;
splEsUnwrapElicenseKey :: (rsa_wrapped_elicense_key: *void, modulus: *void, label_hash: *void, label_hash_size: u64, key_generation: u32, out_sealed_elicense_key: *void) -> Result #foreign libnx;
splEsLoadElicenseKey :: (sealed_elicense_key: *void, keyslot: u32) -> Result #foreign libnx;

splFsLoadSecureExpModKey :: (sealed_kek: *void, wrapped_key: *void, wrapped_rsa_key: *void, wrapped_rsa_key_size: u64, version: RsaKeyVersion) -> Result #foreign libnx;
splFsSecureExpMod :: (input: *void, modulus: *void, dst: *void) -> Result #foreign libnx;
splFsGenerateSpecificAesKey :: (wrapped_key: *void, key_generation: u32, option: u32, out_sealed_key: *void) -> Result #foreign libnx;
splFsLoadTitlekey :: (sealed_titlekey: *void, keyslot: u32) -> Result #foreign libnx;
splFsGetPackage2Hash :: (out_hash: *void) -> Result #foreign libnx;

splManuEncryptRsaKeyForImport :: (sealed_kek_pre: *void, wrapped_key_pre: *void, sealed_kek_post: *void, wrapped_kek_post: *void, option: u32, wrapped_rsa_key: *void, out_wrapped_rsa_key: *void, rsa_key_size: u64) -> Result #foreign libnx;

/// ContentStorage
NcmContentStorage :: struct {
    s: Service; ///< IContentStorage
}

/// ContentMetaDatabase
NcmContentMetaDatabase :: struct {
    s: Service; ///< IContentMetaDatabase
}

/// RightsId
NcmRightsId :: struct {
    rights_id:      FsRightsId;
    key_generation: u8; ///< [3.0.0+]
    pad:            [7] u8; ///< [3.0.0+]
}

/// Initialize ncm.
ncmInitialize :: () -> Result #foreign libnx;

/// Exit ncm.
ncmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ncm service session.
ncmGetServiceSession :: () -> *Service #foreign libnx;

ncmCreateContentStorage :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmCreateContentMetaDatabase :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmVerifyContentStorage :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmVerifyContentMetaDatabase :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmOpenContentStorage :: (out_content_storage: *NcmContentStorage, storage_id: NcmStorageId) -> Result #foreign libnx;
ncmOpenContentMetaDatabase :: (out_content_meta_database: *NcmContentMetaDatabase, storage_id: NcmStorageId) -> Result #foreign libnx;
ncmCloseContentStorageForcibly :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmCloseContentMetaDatabaseForcibly :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmCleanupContentMetaDatabase :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmActivateContentStorage :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmInactivateContentStorage :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmActivateContentMetaDatabase :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmInactivateContentMetaDatabase :: (storage_id: NcmStorageId) -> Result #foreign libnx;
ncmInvalidateRightsIdCache :: () -> Result #foreign libnx;
ncmActivateFsContentStorage :: (fs_storage_id: FsContentStorageId) -> Result #foreign libnx;

ncmContentStorageClose :: (cs: *NcmContentStorage) -> void #foreign libnx;
ncmContentStorageGeneratePlaceHolderId :: (cs: *NcmContentStorage, out_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageCreatePlaceHolder :: (cs: *NcmContentStorage, content_id: *NcmContentId, placeholder_id: *NcmPlaceHolderId, size: s64) -> Result #foreign libnx;
ncmContentStorageDeletePlaceHolder :: (cs: *NcmContentStorage, placeholder_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageHasPlaceHolder :: (cs: *NcmContentStorage, out: *bool, placeholder_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageWritePlaceHolder :: (cs: *NcmContentStorage, placeholder_id: *NcmPlaceHolderId, offset: u64, data: *void, data_size: u64) -> Result #foreign libnx;
ncmContentStorageRegister :: (cs: *NcmContentStorage, content_id: *NcmContentId, placeholder_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageDelete :: (cs: *NcmContentStorage, content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentStorageHas :: (cs: *NcmContentStorage, out: *bool, content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentStorageGetPath :: (cs: *NcmContentStorage, out_path: *u8, out_size: u64, content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentStorageGetPlaceHolderPath :: (cs: *NcmContentStorage, out_path: *u8, out_size: u64, placeholder_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageCleanupAllPlaceHolder :: (cs: *NcmContentStorage) -> Result #foreign libnx;
ncmContentStorageListPlaceHolder :: (cs: *NcmContentStorage, out_ids: *NcmPlaceHolderId, count: s32, out_count: *s32) -> Result #foreign libnx;
ncmContentStorageGetContentCount :: (cs: *NcmContentStorage, out_count: *s32) -> Result #foreign libnx;
ncmContentStorageListContentId :: (cs: *NcmContentStorage, out_ids: *NcmContentId, count: s32, out_count: *s32, start_offset: s32) -> Result #foreign libnx;
ncmContentStorageGetSizeFromContentId :: (cs: *NcmContentStorage, out_size: *s64, content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentStorageDisableForcibly :: (cs: *NcmContentStorage) -> Result #foreign libnx;
ncmContentStorageRevertToPlaceHolder :: (cs: *NcmContentStorage, placeholder_id: *NcmPlaceHolderId, old_content_id: *NcmContentId, new_content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentStorageSetPlaceHolderSize :: (cs: *NcmContentStorage, placeholder_id: *NcmPlaceHolderId, size: s64) -> Result #foreign libnx;
ncmContentStorageReadContentIdFile :: (cs: *NcmContentStorage, out_data: *void, out_data_size: u64, content_id: *NcmContentId, offset: s64) -> Result #foreign libnx;
ncmContentStorageGetRightsIdFromPlaceHolderId :: (cs: *NcmContentStorage, out_rights_id: *NcmRightsId, placeholder_id: *NcmPlaceHolderId, attr: FsContentAttributes) -> Result #foreign libnx;
ncmContentStorageGetRightsIdFromContentId :: (cs: *NcmContentStorage, out_rights_id: *NcmRightsId, content_id: *NcmContentId, attr: FsContentAttributes) -> Result #foreign libnx;
ncmContentStorageWriteContentForDebug :: (cs: *NcmContentStorage, content_id: *NcmContentId, offset: s64, data: *void, data_size: u64) -> Result #foreign libnx;
ncmContentStorageGetFreeSpaceSize :: (cs: *NcmContentStorage, out_size: *s64) -> Result #foreign libnx;
ncmContentStorageGetTotalSpaceSize :: (cs: *NcmContentStorage, out_size: *s64) -> Result #foreign libnx;
ncmContentStorageFlushPlaceHolder :: (cs: *NcmContentStorage) -> Result #foreign libnx;
ncmContentStorageGetSizeFromPlaceHolderId :: (cs: *NcmContentStorage, out_size: *s64, placeholder_id: *NcmPlaceHolderId) -> Result #foreign libnx;
ncmContentStorageRepairInvalidFileAttribute :: (cs: *NcmContentStorage) -> Result #foreign libnx;
ncmContentStorageGetRightsIdFromPlaceHolderIdWithCache :: (cs: *NcmContentStorage, out_rights_id: *NcmRightsId, placeholder_id: *NcmPlaceHolderId, cache_content_id: *NcmContentId, attr: FsContentAttributes) -> Result #foreign libnx;
ncmContentStorageRegisterPath :: (cs: *NcmContentStorage, content_id: *NcmContentId, path: *u8) -> Result #foreign libnx;
ncmContentStorageClearRegisteredPath :: (cs: *NcmContentStorage) -> Result #foreign libnx;
ncmContentStorageGetProgramId :: (cs: *NcmContentStorage, out: *u64, content_id: *NcmContentId, attr: FsContentAttributes) -> Result #foreign libnx;

ncmContentMetaDatabaseClose :: (db: *NcmContentMetaDatabase) -> void #foreign libnx;
ncmContentMetaDatabaseSet :: (db: *NcmContentMetaDatabase, key: *NcmContentMetaKey, data: *void, data_size: u64) -> Result #foreign libnx;
ncmContentMetaDatabaseGet :: (db: *NcmContentMetaDatabase, key: *NcmContentMetaKey, out_size: *u64, out_data: *void, out_data_size: u64) -> Result #foreign libnx;
ncmContentMetaDatabaseRemove :: (db: *NcmContentMetaDatabase, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseGetContentIdByType :: (db: *NcmContentMetaDatabase, out_content_id: *NcmContentId, key: *NcmContentMetaKey, type: NcmContentType) -> Result #foreign libnx;
ncmContentMetaDatabaseListContentInfo :: (db: *NcmContentMetaDatabase, out_entries_written: *s32, out_info: *NcmContentInfo, count: s32, key: *NcmContentMetaKey, start_index: s32) -> Result #foreign libnx;
ncmContentMetaDatabaseList :: (db: *NcmContentMetaDatabase, out_entries_total: *s32, out_entries_written: *s32, out_keys: *NcmContentMetaKey, count: s32, meta_type: NcmContentMetaType, id: u64, id_min: u64, id_max: u64, install_type: NcmContentInstallType) -> Result #foreign libnx;
ncmContentMetaDatabaseGetLatestContentMetaKey :: (db: *NcmContentMetaDatabase, out_key: *NcmContentMetaKey, id: u64) -> Result #foreign libnx;
ncmContentMetaDatabaseListApplication :: (db: *NcmContentMetaDatabase, out_entries_total: *s32, out_entries_written: *s32, out_keys: *NcmApplicationContentMetaKey, count: s32, meta_type: NcmContentMetaType) -> Result #foreign libnx;
ncmContentMetaDatabaseHas :: (db: *NcmContentMetaDatabase, out: *bool, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseHasAll :: (db: *NcmContentMetaDatabase, out: *bool, keys: *NcmContentMetaKey, count: s32) -> Result #foreign libnx;
ncmContentMetaDatabaseGetSize :: (db: *NcmContentMetaDatabase, out_size: *u64, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseGetRequiredSystemVersion :: (db: *NcmContentMetaDatabase, out_version: *u32, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseGetPatchContentMetaId :: (db: *NcmContentMetaDatabase, out_patch_id: *u64, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseDisableForcibly :: (db: *NcmContentMetaDatabase) -> Result #foreign libnx;
ncmContentMetaDatabaseLookupOrphanContent :: (db: *NcmContentMetaDatabase, out_orphaned: *bool, content_ids: *NcmContentId, count: s32) -> Result #foreign libnx;
ncmContentMetaDatabaseCommit :: (db: *NcmContentMetaDatabase) -> Result #foreign libnx;
ncmContentMetaDatabaseHasContent :: (db: *NcmContentMetaDatabase, out: *bool, key: *NcmContentMetaKey, content_id: *NcmContentId) -> Result #foreign libnx;
ncmContentMetaDatabaseListContentMetaInfo :: (db: *NcmContentMetaDatabase, out_entries_written: *s32, out_meta_info: *void, count: s32, key: *NcmContentMetaKey, start_index: s32) -> Result #foreign libnx;
ncmContentMetaDatabaseGetAttributes :: (db: *NcmContentMetaDatabase, key: *NcmContentMetaKey, out: *u8) -> Result #foreign libnx;
ncmContentMetaDatabaseGetRequiredApplicationVersion :: (db: *NcmContentMetaDatabase, out_version: *u32, key: *NcmContentMetaKey) -> Result #foreign libnx;
ncmContentMetaDatabaseGetContentIdByTypeAndIdOffset :: (db: *NcmContentMetaDatabase, out_content_id: *NcmContentId, key: *NcmContentMetaKey, type: NcmContentType, id_offset: u8) -> Result #foreign libnx;
ncmContentMetaDatabaseGetPlatform :: (db: *NcmContentMetaDatabase, out: *u8, key: *NcmContentMetaKey) -> Result #foreign libnx;

PscPmState :: enum u32 {
    Awake               :: 0;
    ReadyAwaken         :: 1;
    ReadySleep          :: 2;
    ReadySleepCritical  :: 3;
    ReadyAwakenCritical :: 4;
    ReadyShutdown       :: 5;
}

PscPmModuleId :: enum u32 {
    Usb         :: 4;
    Ethernet    :: 5;
    Fgm         :: 6;
    PcvClock    :: 7;
    PcvVoltage  :: 8;
    Gpio        :: 9;
    Pinmux      :: 10;
    Uart        :: 11;
    I2c         :: 12;
    I2cPcv      :: 13;
    Spi         :: 14;
    Pwm         :: 15;
    Psm         :: 16;
    Tc          :: 17;
    Omm         :: 18;
    Pcie        :: 19;
    Lbl         :: 20;
    Display     :: 21;

    Hid         :: 24;
    WlanSockets :: 25;

    Fs          :: 27;
    Audio       :: 28;

    TmaHostIo   :: 30;
    Bluetooth   :: 31;
    Bpc         :: 32;
    Fan         :: 33;
    Pcm         :: 34;
    Nfc         :: 35;
    Apm         :: 36;
    Btm         :: 37;
    Nifm        :: 38;
    GpioLow     :: 39;
    Npns        :: 40;
    Lm          :: 41;
    Bcat        :: 42;
    Time        :: 43;
    Pctl        :: 44;
    Erpt        :: 45;
    Eupld       :: 46;
    Friends     :: 47;
    Bgtc        :: 48;
    Account     :: 49;
    Sasbus      :: 50;
    Ntc         :: 51;
    Idle        :: 52;
    Tcap        :: 53;
    PsmLow      :: 54;
    Ndd         :: 55;
    Olsc        :: 56;

    Ns          :: 61;

    Nvservices  :: 101;

    Spsm        :: 127;
}

PscPmModule :: struct {
    event:     Event;
    srv:       Service;
    module_id: PscPmModuleId;
}

/// Initialize psc:m.
pscmInitialize :: () -> Result #foreign libnx;

/// Exit psc:m.
pscmExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual psc:m service session.
pscmGetServiceSession :: () -> *Service #foreign libnx;

pscmGetPmModule :: (out: *PscPmModule, module_id: PscPmModuleId, dependencies: *u32, dependency_count: u64, autoclear: bool) -> Result #foreign libnx;

pscPmModuleGetRequest :: (module: *PscPmModule, out_state: *PscPmState, out_flags: *u32) -> Result #foreign libnx;
pscPmModuleAcknowledge :: (module: *PscPmModule, state: PscPmState) -> Result #foreign libnx;
pscPmModuleFinalize :: (module: *PscPmModule) -> Result #foreign libnx;

pscPmModuleClose :: (module: *PscPmModule) -> void #foreign libnx;

/// Initialize caps:a.
capsaInitialize :: () -> Result #foreign libnx;

/// Exit caps:a.
capsaExit :: () -> void #foreign libnx;

/// Gets the Service for caps:a.
capsaGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service for IAlbumAccessorSession, only initialized after \ref capsaOpenAlbumMovieStream was used (unaffected by using \ref capsaCloseAlbumMovieStream).
capsaGetServiceSession_Accessor :: () -> *Service #foreign libnx;

/**
* @brief Gets the amount of files at a AlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
* @param[out] count Amount of files.
*/
capsaGetAlbumFileCount :: (storage: CapsAlbumStorage, count: *u64) -> Result #foreign libnx;

/**
* @brief Gets a listing of \ref CapsAlbumEntry, where the AlbumFile's storage matches the input one.
* @param[in] storage \ref CapsAlbumStorage
* @param[out] out Total output entries.
* @param[out] entries Output array of \ref CapsAlbumEntry.
* @param[in] count Reserved entry count.
*/
capsaGetAlbumFileList :: (storage: CapsAlbumStorage, out: *u64, entries: *CapsAlbumEntry, count: u64) -> Result #foreign libnx;

/**
* @brief Loads a file into the specified buffer.
* @param[in] file_id \ref CapsAlbumFileId
* @param[out] out_size Size of the AlbumFile.
* @param[out] filebuf File output buffer.
* @param[in] filebuf_size Size of the filebuf.
*/
capsaLoadAlbumFile :: (file_id: *CapsAlbumFileId, out_size: *u64, filebuf: *void, filebuf_size: u64) -> Result #foreign libnx;

/**
* @brief Deletes an AlbumFile corresponding to the specified \ref CapsAlbumFileId.
* @param[in] file_id \ref CapsAlbumFileId
*/
capsaDeleteAlbumFile :: (file_id: *CapsAlbumFileId) -> Result #foreign libnx;

/**
* @brief Copies an AlbumFile to the specified \ref CapsAlbumStorage.
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] dst_storage \ref CapsAlbumStorage
*/
capsaStorageCopyAlbumFile :: (file_id: *CapsAlbumFileId, dst_storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Gets the mount status of the specified \ref CapsAlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
* @param[out] is_mounted Boolean over whether the storage is mounted or not.
*/
capsaIsAlbumMounted :: (storage: CapsAlbumStorage, is_mounted: *bool) -> Result #foreign libnx;

/**
* @brief Returns the AlbumUsage for a specified \ref CapsAlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
* @param[out] out \ref CapsAlbumUsage2
*/
capsaGetAlbumUsage :: (storage: CapsAlbumStorage, out: *CapsAlbumUsage2) -> Result #foreign libnx;

/**
* @brief Gets the size for the specified AlbumFile.
* @param[in] file_id \ref CapsAlbumFileId
* @param[out] size Size of the file.
*/
capsaGetAlbumFileSize :: (file_id: *CapsAlbumFileId, size: *u64) -> Result #foreign libnx;

/**
* @brief Load the Thumbnail for the specified AlbumFile.
* @note Will always be 320x180.
* @param[in] file_id \ref CapsAlbumFileId
* @param[out] out_size Size of the Thumbnail.
* @param[out] image JPEG image output buffer.
* @param[in] image_size Image buffer size.
*/
capsaLoadAlbumFileThumbnail :: (file_id: *CapsAlbumFileId, out_size: *u64, image: *void, image_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotImage for the specified AlbumFile.
* @note Only available on [2.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[in] file_id \ref CapsAlbumFileId
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 1280x720.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotImage :: (width: *u64, height: *u64, file_id: *CapsAlbumFileId, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotThumbnailImage for the specified AlbumFile.
* @note Only available on [2.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[in] file_id \ref CapsAlbumFileId
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 320x180.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotThumbnailImage :: (width: *u64, height: *u64, file_id: *CapsAlbumFileId, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load an \ref CapsAlbumEntry from a \ref CapsApplicationAlbumEntry and an ApplicationId.
* @note Only available on [2.0.0+].
* @param[out] entry \ref CapsAlbumEntry
* @param[in] application_entry \ref CapsApplicationAlbumEntry
* @param[in] application_id ApplicationId
*/
capsaGetAlbumEntryFromApplicationAlbumEntry :: (entry: *CapsAlbumEntry, application_entry: *CapsApplicationAlbumEntry, application_id: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotImage for the specified AlbumFile.
* @note Only available on [3.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 1280x720.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotImageEx :: (width: *u64, height: *u64, file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotThumbnailImage for the specified AlbumFile.
* @note Only available on [3.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 320x180.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotThumbnailImageEx :: (width: *u64, height: *u64, file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotImage for the specified AlbumFile.
* @note Only available on [3.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[out] attr \ref CapsScreenShotAttribute
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 1280x720.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotImageEx0 :: (width: *u64, height: *u64, attr: *CapsScreenShotAttribute, file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Returns the AlbumUsage for a specified \ref CapsAlbumStorage.
* @note Only available on [4.0.0+].
* @param[in] storage \ref CapsAlbumStorage
* @param[out] out \ref CapsAlbumUsage3
*/
capsaGetAlbumUsage3 :: (storage: CapsAlbumStorage, out: *CapsAlbumUsage3) -> Result #foreign libnx;

/**
* @brief Returns the result for a AlbumStorage mount.
* @note Only available on [4.0.0+].
* @param[in] storage \ref CapsAlbumStorage
*/
capsaGetAlbumMountResult :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Returns the AlbumUsage for a specified \ref CapsAlbumStorage.
* @note Only available on [4.0.0+].
* @param[in] storage \ref CapsAlbumStorage
* @param[in] flags \ref CapsAlbumFileContentsFlag
* @param[out] out \ref CapsAlbumUsage16
*/
capsaGetAlbumUsage16 :: (storage: CapsAlbumStorage, flags: u8, out: *CapsAlbumUsage16) -> Result #foreign libnx;

/**
* @brief Returns the start and end of the Applet Id range.
* @note Only available on [6.0.0+].
* @param[out] success Returns bool over whether the call was handled or not.
* @param[out] min Mimimum applet id. Always 0x0100000000001000
* @param[out] max Maximum applet id. Always 0x0100000000001FFF
*/
capsaGetMinMaxAppletId :: (success: *bool, min: *u64, max: *u64) -> Result #foreign libnx;

/**
* @brief Gets the amount of files of the specified type at a AlbumStorage.
* @note Only available on [5.0.0+].
* @param[in] storage \ref CapsAlbumStorage
* @param[in] flags \ref CapsAlbumFileContentsFlag
* @param[out] count Amount of files.
*/
capsaGetAlbumFileCountEx0 :: (storage: CapsAlbumStorage, flags: u8, count: *u64) -> Result #foreign libnx;

/**
* @brief Gets a listing of \ref CapsAlbumEntry, where the AlbumFile's storage and type matches the input one.
* @note Only available on [5.0.0+].
* @param[in] storage \ref CapsAlbumStorage
* @param[in] flags \ref CapsAlbumFileContentsFlag
* @param[out] out Total output entries.
* @param[out] entries Output array of \ref CapsAlbumEntry.
* @param[in] count Reserved entry count.
*/
capsaGetAlbumFileListEx0 :: (storage: CapsAlbumStorage, flags: u8, out: *u64, entries: *CapsAlbumEntry, count: u64) -> Result #foreign libnx;

/**
* @brief Returns the image from the last shown ScreenShot Overlay.
* @param[out] file_id \ref CapsAlbumFileId
* @param[out] out_size Size of the thumbnail image. Always 0x5100.
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 96×54.
*/
capsaGetLastOverlayScreenShotThumbnail :: (file_id: *CapsAlbumFileId, out_size: *u64, image: *void, image_size: u64) -> Result #foreign libnx;

/**
* @brief Returns the image from the last shown Movie Overlay.
* @note Only available on [4.0.0+].
* @param[out] file_id \ref CapsAlbumFileId
* @param[out] out_size Size of the thumbnail image. Always 0x5100.
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 96×54.
*/
capsaGetLastOverlayMovieThumbnail :: (file_id: *CapsAlbumFileId, out_size: *u64, image: *void, image_size: u64) -> Result #foreign libnx;

/**
* @brief Gets the currently set autosaving storage.
* @note Wrapper around setsysGetPrimaryAlbumStorage but defaults to NAND if SD isn't available.
* @param[out] storage \ref CapsAlbumStorage
*/
capsaGetAutoSavingStorage :: (storage: *CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Gets required size to copy all files from one Storage to another.
* @param[in] dst_storage \ref CapsAlbumStorage
* @param[in] src_storage \ref CapsAlbumStorage
* @param[out] out Required storage space size.
*/
capsaGetRequiredStorageSpaceSizeToCopyAll :: (dst_storage: CapsAlbumStorage, src_storage: CapsAlbumStorage, out: *u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotThumbnailImage for the specified AlbumFile.
* @note Only available on [3.0.0+].
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[out] attr \ref CapsScreenShotAttribute
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 320x180.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsLoadAlbumScreenShotThumbnailImageEx0 :: (width: *u64, height: *u64, attr: *CapsScreenShotAttribute, file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotImage for the specified AlbumFile.
* @note Only available on [4.0.0+].
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] out \ref CapsLoadAlbumScreenShotImageOutput
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 1280x720.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotImageEx1 :: (file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, out: *CapsLoadAlbumScreenShotImageOutput, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotThumbnailImage for the specified AlbumFile.
* @note Only available on [4.0.0+].
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] opts \ref CapsScreenShotDecodeOption
* @param[out] out \ref CapsLoadAlbumScreenShotImageOutput
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 320x180.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
*/
capsaLoadAlbumScreenShotThumbnailImageEx1 :: (file_id: *CapsAlbumFileId, opts: *CapsScreenShotDecodeOption, out: *CapsLoadAlbumScreenShotImageOutput, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64) -> Result #foreign libnx;

/**
* @brief Unmounts the specified AlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
*/
capsaForceAlbumUnmounted :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Resets mount status for the specified AlbumStorage.
* @note Mounts the Storage if available.
* @param[in] storage \ref CapsAlbumStorage
*/
capsaResetAlbumMountStatus :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Refreshs Album Cache for the specified AlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
*/
capsaRefreshAlbumCache :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Gets the AlbumCache of the specified AlbumStorage.
* @note Stubbed on [4.0.0+].
* @note use \ref capsaGetAlbumCacheEx instead.
* @param[in] storage \ref CapsAlbumStorage
* @param[out] cache \ref CapsAlbumCache
*/
capsaGetAlbumCache :: (storage: CapsAlbumStorage, cache: *CapsAlbumCache) -> Result #foreign libnx;

/**
* @brief Gets the AlbumCache for the specified type of the specified AlbumStorage.
* @param[in] storage \ref CapsAlbumStorage
* @param[in] contents \ref CapsAlbumFileContents
* @param[out] cache \ref CapsAlbumCache
*/
capsaGetAlbumCacheEx :: (storage: CapsAlbumStorage, contents: CapsAlbumFileContents, cache: *CapsAlbumCache) -> Result #foreign libnx;

/**
* @brief Load an \ref CapsAlbumEntry from a \ref CapsApplicationAlbumEntry and an AppletResourceUserId.
* @note Only available on [2.0.0+].
* @param[out] entry \ref CapsAlbumEntry
* @param[in] application_entry \ref CapsApplicationAlbumEntry
*/
capsaGetAlbumEntryFromApplicationAlbumEntryAruid :: (entry: *CapsAlbumEntry, application_entry: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Opens an AlbumMovieStream.
* @note This opens IAlbumAccessorSession if not previously opened, it's closed during \ref capsaExit.
* @note Up to 4 streams can be open at the same time. Multiple streams can be open at the same time for the same \ref CapsAlbumFileId.
* @note Only available on [4.0.0+].
* @param[out] stream Stream handle.
* @param[in] entry \ref CapsAlbumFileId
*/
capsaOpenAlbumMovieStream :: (stream: *u64, file_id: *CapsAlbumFileId) -> Result #foreign libnx;

/**
* @brief Closes an AlbumMovieStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capsaCloseAlbumMovieStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an AlbumMovieStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Size of the actual MP4, without the JPEG at the end.
*/
capsaGetAlbumMovieStreamSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Reads data from an AlbumMovieStream.
* @note offset(+size) must not be negative. offset and size must be aligned to 0x40000-bytes.
* @note When offset(+size) goes beyond the size from \ref capsaGetAlbumMovieStreamSize, the regions of the buffer which goes beyond that are cleared to 0, and actual_size is still set to the input size.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capsaReadMovieDataFromAlbumMovieReadStream :: (stream: u64, offset: s64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the BrokenReason for an AlbumMovieStream.
* @note Official sw doesn't use this.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capsaGetAlbumMovieReadStreamBrokenReason :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an Image taken from an AlbumMovieStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Expected size of an Image.
*/
capsaGetAlbumMovieReadStreamImageDataSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Reads data of an Image taken from an AlbumMovieStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capsaReadImageDataFromAlbumMovieReadStream :: (stream: u64, offset: s64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the file attribute of an AlbumMovieStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] attr \ref CapsScreenShotAttribute
*/
capsaReadFileAttributeFromAlbumMovieReadStream :: (stream: u64, attr: *CapsScreenShotAttribute) -> Result #foreign libnx;

/// Initialize caps:c
capscInitialize :: () -> Result #foreign libnx;

/// Exit caps:c.
capscExit :: () -> void #foreign libnx;

/// Gets the Service for caps:c.
capscGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Notify the service that a storage is now available.
* @note This will result in capsrv mounting the image directory on that storage medium.
* @param[in] storage \ref CapsAlbumStorage
*/
capscNotifyAlbumStorageIsAvailable :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Notify the service that a storage is now unavailable.
* @note This will result in capsrv unmounting the image directory on that storage medium.
* @param[in] storage \ref CapsAlbumStorage
*/
capscNotifyAlbumStorageIsUnAvailable :: (storage: CapsAlbumStorage) -> Result #foreign libnx;

/**
* @brief Register an applet for later usage.
* @note Called at application launch by the system.
* @note Will generate a random AES-256 key for this application for use on Shim-Version 0.
* @note Only available on [2.0.0+].
* @param[in] appletResourceUserId AppletResourceUserId.
* @param[in] application_id ApplicationId.
*/
capscRegisterAppletResourceUserId :: (appletResourceUserId: u64, application_id: u64) -> Result #foreign libnx;

/**
* @brief Unregister an applet.
* @note Called at application exit by the system.
* @note Only available on [2.0.0+].
* @param[in] appletResourceUserId AppletResourceUserId.
* @param[in] application_id ApplicationId.
*/
capscUnregisterAppletResourceUserId :: (appletResourceUserId: u64, application_id: u64) -> Result #foreign libnx;

/**
* @brief Get an ApplicationId that corresponds to an AppletResourceUserId.
* @note Returns value set by \ref capscRegisterAppletResourceUserId.
* @note Only available on [2.0.0+].
* @param[out] application_id ApplicationId.
* @param[in] appletResourceUserId AppletResourceUserId.
*/
capscGetApplicationIdFromAruid :: (application_id: *u64, aruid: u64) -> Result #foreign libnx;

/**
* @brief Checks whether an ApplicationId is registered.
* @note Only available on [2.0.0+].
* @param[in] application_id ApplicationId.
*/
capscCheckApplicationIdRegistered :: (application_id: u64) -> Result #foreign libnx;

/**
* @brief Generate an AlbumFileId based on parameters and current time.
* @param[in] application_id ApplicationId.
* @note Only available on [2.0.0+].
* @param[in] contents \ref CapsAlbumFileContents
* @param[out] file_id \ref CapsAlbumFileId
*/
capscGenerateCurrentAlbumFileId :: (application_id: u64, contents: CapsAlbumFileContents, file_id: *CapsAlbumFileId) -> Result #foreign libnx;

/**
* @brief Generate an ApplicationAlbumEntry based on parameters.
* @note Output will be different between Shim Version 0 and 1.
* @note Only available on [2.0.0+].
* @param[out] appEntry \ref CapsApplicationAlbumEntry
* @param[in] entry \ref CapsAlbumEntry
* @param[in] application_id ApplicationId.
*/
capscGenerateApplicationAlbumEntry :: (appEntry: *CapsApplicationAlbumEntry, entry: *CapsAlbumEntry, application_id: u64) -> Result #foreign libnx;

/**
* @brief Save a jpeg image.
* @note Only available on [2.0.0-3.0.2].
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] buffer JPEG image buffer.
* @param[in] buffer_size Size of the JPEG image.
*/
capscSaveAlbumScreenShotFile :: (file_id: *CapsAlbumFileId, buffer: *void, buffer_size: u64) -> Result #foreign libnx;

/**
* @brief Save a jpeg image.
* @note Only available on [4.0.0+].
* @note Version 3 as of [9.1.0].
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] version Revision number.
* @param[in] makernote_offset Offset to makernote in JPEG buffer.
* @param[in] makernote_size Size of the makernote in JPEG buffer.
* @param[in] buffer JPEG image buffer.
* @param[in] buffer_size Size of the JPEG image.
*/
capscSaveAlbumScreenShotFileEx :: (file_id: *CapsAlbumFileId, version: u64, makernote_offset: u64, makernote_size: u64, buffer: *void, buffer_size: u64) -> Result #foreign libnx;

/**
* @brief Sets thumbnail data for the last taken screenshot.
* @note 96×54 Image will get saved.
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] image RGBA8 image buffer.
* @param[in] image_size size of the RGBA8 image buffer.
*/
capscSetOverlayScreenShotThumbnailData :: (file_id: *CapsAlbumFileId, image: *void, image_size: u64) -> Result #foreign libnx;

/**
* @brief Sets thumbnail data for the last recorded movie.
* @note Only availabe on [4.0.0+].
* @note 96×54 Image will get saved.
* @param[in] file_id \ref CapsAlbumFileId
* @param[in] image RGBA8 image buffer.
* @param[in] image_size size of the RGBA8 image buffer.
*/
capscSetOverlayMovieThumbnailData :: (file_id: *CapsAlbumFileId, image: *void, image_size: u64) -> Result #foreign libnx;

/**
* @brief Opens an AlbumMovieReadStream.
* @note This opens IAlbumControlSession if not previously opened, it's closed during \ref capscExit.
* @note Up to 4 streams can be open at the same time. Multiple streams can be open at the same time for the same \ref CapsAlbumFileId.
* @note Only available on [4.0.0+].
* @param[out] stream Stream handle.
* @param[in] entry \ref CapsAlbumFileId
*/
capscOpenAlbumMovieReadStream :: (stream: *u64, file_id: *CapsAlbumFileId) -> Result #foreign libnx;

/**
* @brief Closes an AlbumMovieReadStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscCloseAlbumMovieStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an AlbumMovieReadStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Size of the actual MP4, without the JPEG at the end.
*/
capscGetAlbumMovieStreamSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Reads data from an AlbumMovieReadStream.
* @note offset(+size) must not be negative. offset and size must be aligned to 0x40000-bytes.
* @note When offset(+size) goes beyond the size from \ref capscGetAlbumMovieStreamSize, the regions of the buffer which goes beyond that are cleared to 0, and actual_size is still set to the input size.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capscReadMovieDataFromAlbumMovieReadStream :: (stream: u64, offset: u64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the BrokenReason for an AlbumMovieReadStream.
* @note Official sw doesn't use this.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscGetAlbumMovieReadStreamBrokenReason :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an Image taken from an AlbumMovieReadStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Expected size of an Image.
*/
capscGetAlbumMovieReadStreamImageDataSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Reads data of an Image taken from an AlbumMovieReadStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] buffer Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capscReadImageDataFromAlbumMovieReadStream :: (stream: u64, offset: u64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the file attribute of an AlbumMovieReadStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] attr \ref CapsScreenShotAttribute
*/
capscReadFileAttributeFromAlbumMovieReadStream :: (stream: u64, attribute: *CapsScreenShotAttribute) -> Result #foreign libnx;

/**
* @brief Opens an AlbumMovieWriteStream.
* @note This opens IAlbumControlSession if not previously opened, it's closed during \ref capsaExit.
* @note Up to 2 streams can be open at the same time.
* @note Only available on [4.0.0+].
* @param[out] stream Stream handle.
* @param[in] entry \ref CapsAlbumFileId
*/
capscOpenAlbumMovieWriteStream :: (stream: *u64, file_id: *CapsAlbumFileId) -> Result #foreign libnx;

/**
* @brief Finish write to AlbumMovieWriteStream.
* @note Copies file from save to destination storage and deletes the temporary file.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscFinishAlbumMovieWriteStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Closes a finished AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscCommitAlbumMovieWriteStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Closes an AlbumMovieWriteStream in any state.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscDiscardAlbumMovieWriteStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Closes an AlbumMovieWriteStream in any state without deleting the temporary file.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscDiscardAlbumMovieWriteStreamNoDelete :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Closes a finished AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] entry \ref CapsAlbumEntry
*/
capscCommitAlbumMovieWriteStreamEx :: (stream: u64, entry: *CapsAlbumEntry) -> Result #foreign libnx;

/**
* @brief Start AlbumMovieWriteStream data section.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscStartAlbumMovieWriteStreamDataSection :: (stream: u64) -> Result #foreign libnx;

/**
* @brief End AlbumMovieWriteStream data section.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscEndAlbumMovieWriteStreamDataSection :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Start AlbumMovieWriteStream meta section.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscStartAlbumMovieWriteStreamMetaSection :: (stream: u64) -> Result #foreign libnx;

/**
* @brief End AlbumMovieWriteStream meta section.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscEndAlbumMovieWriteStreamMetaSection :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Reads data from an AlbumMovieWriteStream.
* @note offset(+size) must not be negative. offset and size must be aligned to 0x40000-bytes.
* @note When offset(+size) goes beyond the size from \ref capscGetAlbumMovieStreamSize, the regions of the buffer which goes beyond that are cleared to 0, and actual_size is still set to the input size.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] buffer Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capscReadDataFromAlbumMovieWriteStream :: (stream: u64, offset: u64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Write data to an AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[in] buffer Input data buffer.
* @param[in] size Data buffer size.
*/
capscWriteDataToAlbumMovieWriteStream :: (stream: u64, offset: u64, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Write meta data to an AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[in] buffer Input data buffer.
* @param[in] size Data buffer size.
*/
capscWriteMetaToAlbumMovieWriteStream :: (stream: u64, offset: u64, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets the BrokenReason for an AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
*/
capscGetAlbumMovieWriteStreamBrokenReason :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an AlbumMovieWriteStream.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Size of the data section.
*/
capscGetAlbumMovieWriteStreamDataSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Sets the data size of an AlbumMovieWriteStream.
* @note Must not be bigger than 2GiB.
* @note Only available on [4.0.0+].
* @param[in] stream Stream handle.
* @param[out] size Size of the data section.
*/
capscSetAlbumMovieWriteStreamDataSize :: (stream: u64, size: u64) -> Result #foreign libnx;

/// Initialize caps:dc
capsdcInitialize :: () -> Result #foreign libnx;

/// Exit caps:dc.
capsdcExit :: () -> void #foreign libnx;

/// Gets the Service for caps:dc.
capsdcGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Decodes a jpeg buffer into RGBX.
* @param[in] width Image width.
* @param[in] height Image height.
* @param[in] opts \ref CapsScreenShotDecodeOption.
* @param[in] jpeg Jpeg image input buffer.
* @param[in] jpeg_size Input image buffer size.
* @param[out] out_image RGBA8 image output buffer.
* @param[in] out_image_size Output image buffer size, should be at least large enough for RGBA8 width x height.
*/
capsdcDecodeJpeg :: (width: u32, height: u32, opts: *CapsScreenShotDecodeOption, jpeg: *void, jpeg_size: u64, out_image: *void, out_image_size: u64) -> Result #foreign libnx;

/**
* @brief Shrinks a jpeg's dimensions by 2.
*/
capsdcShrinkJpeg :: (width: u32, height: u32, opts: *CapsScreenShotDecodeOption, jpeg: *void, jpeg_size: u64, out_jpeg: *void, out_jpeg_size: u64, out_result_size: *u64) -> Result #foreign libnx;

/// Initialize caps:u. Only available on [5.0.0+].
capsuInitialize :: () -> Result #foreign libnx;

/// Exit caps:u.
capsuExit :: () -> void #foreign libnx;

/// Gets the Service for caps:u.
capsuGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service for IAlbumAccessorApplicationSession, only initialized after \ref capsuOpenAlbumMovieStream was used (unaffected by using \ref capsuCloseAlbumMovieStream).
capsuGetServiceSession_Accessor :: () -> *Service #foreign libnx;

/**
* @brief Gets a listing of \ref CapsApplicationAlbumFileEntry.
* @note On [6.0.0+] this uses GetAlbumFileList1AafeAruidDeprecated, otherwise this uses GetAlbumFileList0AafeAruidDeprecated.
* @note This is an old version of \ref capsuGetAlbumFileList3.
* @param[out] entries Output array of \ref CapsApplicationAlbumFileEntry.
* @param[in] count Max size of the output array in entries.
* @param[in] type \ref CapsContentType
* @param[in] start_datetime Start \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] end_datetime End \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[out] total_entries Total output entries.
*/
capsuGetAlbumFileListDeprecated1 :: (entries: *CapsApplicationAlbumFileEntry, count: s32, type: CapsContentType, start_datetime: *CapsAlbumFileDateTime, end_datetime: *CapsAlbumFileDateTime, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Gets a listing of \ref CapsApplicationAlbumFileEntry, where the AlbumFile has an UserId which matches the input one. See also \ref capssuSaveScreenShotWithUserIds.
* @note Only available on [6.0.0+].
* @note This is an old version of \ref capsuGetAlbumFileList4.
* @param[out] entries Output array of \ref CapsApplicationAlbumFileEntry.
* @param[in] count Max size of the output array in entries.
* @param[in] type \ref CapsContentType
* @param[in] start_datetime Start \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] end_datetime End \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] uid \ref AccountUid
* @param[out] total_entries Total output entries.
*/
capsuGetAlbumFileListDeprecated2 :: (entries: *CapsApplicationAlbumFileEntry, count: s32, type: CapsContentType, start_datetime: *CapsAlbumFileDateTime, end_datetime: *CapsAlbumFileDateTime, uid: AccountUid, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Gets a listing of \ref CapsApplicationAlbumEntry.
* @note Only available on [7.0.0+], on prior sysvers use \ref capsuGetAlbumFileListDeprecated1 instead.
* @param[out] entries Output array of \ref CapsApplicationAlbumEntry.
* @param[in] count Max size of the output array in entries.
* @param[in] type \ref CapsContentType
* @param[in] start_datetime Start \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] end_datetime End \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[out] total_entries Total output entries.
*/
capsuGetAlbumFileList3 :: (entries: *CapsApplicationAlbumEntry, count: s32, type: CapsContentType, start_datetime: *CapsAlbumFileDateTime, end_datetime: *CapsAlbumFileDateTime, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Gets a listing of \ref CapsApplicationAlbumEntry, where the AlbumFile has an UserId which matches the input one. See also \ref capssuSaveScreenShotWithUserIds.
* @note Only available on [7.0.0+], on prior sysvers use \ref capsuGetAlbumFileListDeprecated2 instead.
* @param[out] entries Output array of \ref CapsApplicationAlbumEntry.
* @param[in] count Max size of the output array in entries.
* @param[in] type \ref CapsContentType
* @param[in] start_datetime Start \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] end_datetime End \ref CapsAlbumFileDateTime, when NULL the default is used.
* @param[in] uid \ref AccountUid
* @param[out] total_entries Total output entries.
*/
capsuGetAlbumFileList4 :: (entries: *CapsApplicationAlbumEntry, count: s32, type: CapsContentType, start_datetime: *CapsAlbumFileDateTime, end_datetime: *CapsAlbumFileDateTime, uid: AccountUid, total_entries: *s32) -> Result #foreign libnx;

/**
* @brief Deletes the specified AlbumFile.
* @param[in] type \ref CapsContentType, must match ::CapsContentType_ExtraMovie.
* @param[in] entry \ref CapsApplicationAlbumFileEntry
*/
capsuDeleteAlbumFile :: (type: CapsContentType, entry: *CapsApplicationAlbumFileEntry) -> Result #foreign libnx;

/**
* @brief Gets the filesize for the entire specified AlbumFile.
* @param[in] entry \ref CapsApplicationAlbumFileEntry
* @param[out] size Output filesize.
*/
capsuGetAlbumFileSize :: (entry: *CapsApplicationAlbumFileEntry, size: *u64) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotImage for the specified AlbumFile.
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[out] attr \ref CapsScreenShotAttributeForApplication
* @param[out] userdata Output buffer containing the UserData. Optional, can be NULL. This buffer is cleared to 0 using userdata_maxsize, prior to doing the memcpy.
* @param[in] userdata_maxsize Max size of the userdata buffer. Optional, can be 0.
* @param[out] userdata_size Userdata size field, clamped to max size sizeof(CapsApplicationData::userdata) when needed.
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 1280x720.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
* @param[in] entry \ref CapsApplicationAlbumFileEntry
* @param[in] option \ref CapsScreenShotDecodeOption
*/
capsuLoadAlbumScreenShotImage :: (width: *s32, height: *s32, attr: *CapsScreenShotAttributeForApplication, userdata: *void, userdata_maxsize: u64, userdata_size: *u32, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64, entry: *CapsApplicationAlbumFileEntry, option: *CapsScreenShotDecodeOption) -> Result #foreign libnx;

/**
* @brief Load the ScreenShotThumbnailImage for the specified AlbumFile.
* @param[out] width Output image width. Optional, can be NULL.
* @param[out] height Output image height. Optional, can be NULL.
* @param[out] attr \ref CapsScreenShotAttributeForApplication
* @param[out] userdata Output buffer containing the UserData. Optional, can be NULL. This buffer is cleared to 0 using userdata_maxsize, prior to doing the memcpy.
* @param[in] userdata_maxsize Max size of the userdata buffer. Optional, can be 0.
* @param[out] userdata_size Userdata size field, clamped to max size sizeof(CapsApplicationData::userdata) when needed.
* @param[out] image RGBA8 image output buffer.
* @param[in] image_size Image buffer size, should be at least large enough for RGBA8 320x180.
* @param[out] workbuf Work buffer, cleared to 0 by the cmd before it returns.
* @param[in] workbuf_size Work buffer size, must be at least the size of the JPEG within the AlbumFile.
* @param[in] entry \ref CapsApplicationAlbumFileEntry
* @param[in] option \ref CapsScreenShotDecodeOption
*/
capsuLoadAlbumScreenShotThumbnailImage :: (width: *s32, height: *s32, attr: *CapsScreenShotAttributeForApplication, userdata: *void, userdata_maxsize: u64, userdata_size: *u32, image: *void, image_size: u64, workbuf: *void, workbuf_size: u64, entry: *CapsApplicationAlbumFileEntry, option: *CapsScreenShotDecodeOption) -> Result #foreign libnx;

/**
* @brief PrecheckToCreateContents. Official sw only uses this with ::CapsContentType_ExtraMovie.
* @param[in] type \ref CapsContentType
* @param[in] unk Unknown.
*/
capsuPrecheckToCreateContents :: (type: CapsContentType, unk: u64) -> Result #foreign libnx;

/**
* @brief Opens an AlbumMovieStream.
* @note This opens IAlbumAccessorApplicationSession if not previously opened, it's closed during \ref capsuExit.
* @note Up to 4 streams can be open at the same time. Multiple streams can be open at the same time for the same \ref CapsApplicationAlbumFileEntry.
* @param[out] stream Stream handle.
* @param[in] entry \ref CapsApplicationAlbumFileEntry
*/
capsuOpenAlbumMovieStream :: (stream: *u64, entry: *CapsApplicationAlbumFileEntry) -> Result #foreign libnx;

/**
* @brief Closes an AlbumMovieStream.
* @param[in] stream Stream handle.
*/
capsuCloseAlbumMovieStream :: (stream: u64) -> Result #foreign libnx;

/**
* @brief Gets the data size of an AlbumMovieStream.
* @param[in] stream Stream handle.
* @param[out] size Size of the actual MP4, without the JPEG at the end.
*/
capsuGetAlbumMovieStreamSize :: (stream: u64, size: *u64) -> Result #foreign libnx;

/**
* @brief Reads data from an AlbumMovieStream.
* @note offset(+size) must not be negative. offset and size must be aligned to 0x40000-bytes.
* @note When offset(+size) goes beyond the size from \ref capsuGetAlbumMovieStreamSize, the regions of the buffer which goes beyond that are cleared to 0, and actual_size is still set to the input size.
* @param[in] stream Stream handle.
* @param[in] offset Offset.
* @param[out] Output data buffer.
* @param[in] size Data buffer size.
* @param[out] actual_size Actual read size.
*/
capsuReadAlbumMovieStream :: (stream: u64, offset: s64, buffer: *void, size: u64, actual_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the BrokenReason for an AlbumMovieStream.
* @note Official sw doesn't use this.
* @param[in] stream Stream handle.
*/
capsuGetAlbumMovieStreamBrokenReason :: (stream: u64) -> Result #foreign libnx;

/// Initialize caps:sc. Only available on [2.0.0+].
capsscInitialize :: () -> Result #foreign libnx;

/// Exit caps:sc.
capsscExit :: () -> void #foreign libnx;

/// Gets the Service for caps:sc.
capsscGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief This takes a screenshot, with the screenshot being written into the output buffer.
* @note Not available with [5.0.0+] (stubbed).
* @note buffer_index and buffer_count correspond to buffers with size 0x384000(1280*720*4). These must not be negative.
* @param buf Output buffer containing the RGBA8 image.
* @param size Size of buf, should be 0x384000(1280*720*4) * buffer_count.
* @param layer_stack \ref ViLayerStack
* @param width Image width, must be 1280.
* @param height Image height, must be 720.
* @param buffer_count Total number of output image buffers.
* @param buffer_index Starting image buffer index. Must be < buffer_count.
* @param timeout Timeout in nanoseconds. A default value of 100000000 can be used.
*/
capsscCaptureRawImageWithTimeout :: (buf: *void, size: u64, layer_stack: ViLayerStack, width: u64, height: u64, buffer_count: s64, buffer_index: s64, timeout: s64) -> Result #foreign libnx;

/**
* @brief This takes a raw screenshot, with the screenshot being held until \ref capsscCloseRawScreenShotReadStream is called.
* @note Only available on [3.0.0+]. Requires debug mode.
* @param out_size Pointer to write the size of the captured raw image to. Always 0x384000(1280*720*4).
* @param out_width Pointer to write the width of the captured raw image to. Always 1280.
* @param out_height Pointer to write the height of the captured raw image to. Always 720.
* @param layer_stack \ref ViLayerStack
* @param timeout Timeout in nanoseconds.
*/
capsscOpenRawScreenShotReadStream :: (out_size: *u64, out_width: *u64, out_height: *u64, layer_stack: ViLayerStack, timeout: s64) -> Result #foreign libnx;

/**
* @brief Discards a stream opened by \ref capsscOpenRawScreenShotReadStream.
* @note Only available on [3.0.0+]. Requires debug mode.
*/
capsscCloseRawScreenShotReadStream :: () -> Result #foreign libnx;

/**
* @brief Reads from a stream opened by \ref capsscOpenRawScreenShotReadStream.
* @note Only available on [3.0.0+]. Requires debug mode.
* @param bytes_read Pointer to write the amounts of bytes written to buffer.
* @param buf Output buffer containing the RGBA8 image.
* @param size Size of buf.
* @param offset Offset in image where read should start.
*/
capsscReadRawScreenShotReadStream :: (bytes_read: *u64, buf: *void, size: u64, offset: u64) -> Result #foreign libnx;

/**
* @brief This takes a screenshot, with the screenshot being written as jpeg into the output buffer.
* @note Only available on [9.0.0+]. Requires debug mode before [10.0.0].
* @param out_jpeg_size Pointer to write the size of the captured jpeg to.
* @param jpeg_buf Output buffer containing the JPEG image.
* @param jpeg_buf_size Size of jpeg_buf, official software uses 0x80000.
* @param layer_stack \ref ViLayerStack
* @param timeout Timeout in nanoseconds.
*/
capsscCaptureJpegScreenShot :: (out_jpeg_size: *u64, jpeg_buf: *void, jpeg_buf_size: u64, layer_stack: ViLayerStack, timeout: s64) -> Result #foreign libnx;

/// Initialize caps:su. Only available on [4.0.0+].
capssuInitialize :: () -> Result #foreign libnx;

/// Exit caps:su.
capssuExit :: () -> void #foreign libnx;

/// Gets the Service for caps:su.
capssuGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief This is a wrapper for \ref capssuSaveScreenShotEx0.
* @note This uses an all-zero \ref CapsScreenShotAttribute with orientation = input orientation, and unk_xc = 1.
* @param[in] buffer RGBA8 1280x720 image buffer.
* @param[in] size Size of the buffer.
* @param[in] reportoption \ref AlbumReportOption
* @param[in] orientation \ref AlbumImageOrientation
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShot :: (buffer: *void, size: u64, reportoption: AlbumReportOption, orientation: AlbumImageOrientation, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Similar to \ref capssuSaveScreenShot, except this is a wrapper for \ref capssuSaveScreenShotEx1.
* @note This uses an all-zero \ref CapsScreenShotAttribute with orientation = input orientation, and unk_xc = 1.
* @note Only available on [8.0.0+].
* @param[in] buffer RGBA8 1280x720 image data buffer.
* @param[in] size Size of the buffer.
* @param[in] reportoption \ref AlbumReportOption
* @param[in] orientation \ref AlbumImageOrientation
* @param[in] userdata Input UserData buffer. If NULL, the \ref CapsApplicationData will be empty.
* @param[in] userdata_size Input UserData size, must be within bounds for CapsApplicationData::userdata. If 0, the \ref CapsApplicationData will be empty.
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShotWithUserData :: (buffer: *void, size: u64, reportoption: AlbumReportOption, orientation: AlbumImageOrientation, userdata: *void, userdata_size: u64, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Similar to \ref capssuSaveScreenShot, except this is a wrapper for \ref capssuSaveScreenShotEx2.
* @note This uses an all-zero \ref CapsScreenShotAttribute with orientation = input orientation, and unk_xc = 1.
* @note Only available on [6.0.0+].
* @param[in] buffer RGBA8 1280x720 image data buffer.
* @param[in] size Size of the buffer.
* @param[in] reportoption \ref AlbumReportOption
* @param[in] orientation \ref AlbumImageOrientation
* @param[in] uids Input array of \ref AccountUid. If NULL, the \ref CapsUserIdList will be empty.
* @param[in] uid_count Size of the uids array in entries, must be within bounds for CapsUserIdList::uids. If 0, the \ref CapsUserIdList will be empty.
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShotWithUserIds :: (buffer: *void, size: u64, reportoption: AlbumReportOption, orientation: AlbumImageOrientation, uids: *AccountUid, uid_count: u64, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Saves an Album screenshot using the specified gfx data in the buffer, with the specified \ref CapsScreenShotAttribute.
* @param[in] buffer RGBA8 1280x720 image data buffer.
* @param[in] size Size of the buffer, must be at least 0x384000.
* @param[in] attr \ref CapsScreenShotAttribute
* @param[in] reportoption \ref AlbumReportOption
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShotEx0 :: (buffer: *void, size: u64, attr: *CapsScreenShotAttribute, reportoption: AlbumReportOption, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Same as \ref capssuSaveScreenShotEx0, except this allows specifying the \ref CapsApplicationData.
* @note Only available on [8.0.0+].
* @param[in] buffer RGBA8 1280x720 image data buffer.
* @param[in] size Size of the buffer, must be at least 0x384000.
* @param[in] attr \ref CapsScreenShotAttribute
* @param[in] reportoption \ref AlbumReportOption
* @param[in] appdata \ref CapsApplicationData
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShotEx1 :: (buffer: *void, size: u64, attr: *CapsScreenShotAttribute, reportoption: AlbumReportOption, appdata: *CapsApplicationData, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Same as \ref capssuSaveScreenShotEx0, except this allows specifying the \ref CapsUserIdList.
* @note Only available on [6.0.0+].
* @param[in] buffer RGBA8 1280x720 image data buffer.
* @param[in] size Size of the buffer, must be at least 0x384000.
* @param[in] attr \ref CapsScreenShotAttribute
* @param[in] reportoption \ref AlbumReportOption
* @param[in] list \ref CapsUserIdList
* @param[out] out \ref CapsApplicationAlbumEntry. Optional, can be NULL.
*/
capssuSaveScreenShotEx2 :: (buffer: *void, size: u64, attr: *CapsScreenShotAttribute, reportoption: AlbumReportOption, list: *CapsUserIdList, out: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

capmtpInitialize :: (mem: *void, size: u64, app_count: u32, max_img: u32, max_vid: u32, other_name: *u8) -> Result #foreign libnx;
capmtpExit :: () -> void #foreign libnx;

capmtpGetRootServiceSession :: () -> *Service #foreign libnx;
capmtpGetServiceSession :: () -> *Service #foreign libnx;

capmtpStartCommandHandler :: () -> Result #foreign libnx;
capmtpStopCommandHandler :: () -> Result #foreign libnx;
capmtpIsRunning :: () -> bool #foreign libnx;
capmtpGetConnectionEvent :: () -> *Event #foreign libnx;
capmtpIsConnected :: () -> bool #foreign libnx;
capmtpGetScanErrorEvent :: () -> *Event #foreign libnx;
capmtpGetScanError :: () -> Result #foreign libnx;

MiiServiceType :: enum u32 {
    System :: 0;
    User   :: 1;
}

/// Mii age.
MiiAge :: enum u32 {
    Young  :: 0;
    Normal :: 1;
    Old    :: 2;
    All    :: 3;
}

/// Mii gender.
MiiGender :: enum u32 {
    Male   :: 0;
    Female :: 1;
    All    :: 2;
}

/// Mii face color.
MiiFaceColor :: enum u32 {
    Black :: 0;
    White :: 1;
    Asian :: 2;
    All   :: 3;
}

// Mii source flag.
MiiSourceFlag :: enum u32 {
    Database :: 1;
    Default  :: 2;
    All      :: 3;
}

// Mii special key code
MiiSpecialKeyCode :: enum u32 {
    Normal  :: 0;
    Special :: 2770581391;
}

MiiDatabase :: struct {
    s: Service;
}

// Mii create ID.
MiiCreateId :: struct {
    uuid: Uuid;
}

// Mii data structure.
MiiCharInfo :: struct {
    create_id:             MiiCreateId;
    mii_name:              [11] u16; ///< utf-16be, null-terminated
    unk_x26:               u8;
    mii_color:             u8;
    mii_sex:               u8;
    mii_height:            u8;
    mii_width:             u8;
    unk_x2b:               [2] u8;
    mii_face_shape:        u8;
    mii_face_color:        u8;
    mii_wrinkles_style:    u8;
    mii_makeup_style:      u8;
    mii_hair_style:        u8;
    mii_hair_color:        u8;
    mii_has_hair_flipped:  u8;
    mii_eye_style:         u8;
    mii_eye_color:         u8;
    mii_eye_size:          u8;
    mii_eye_thickness:     u8;
    mii_eye_angle:         u8;
    mii_eye_pos_x:         u8;
    mii_eye_pos_y:         u8;
    mii_eyebrow_style:     u8;
    mii_eyebrow_color:     u8;
    mii_eyebrow_size:      u8;
    mii_eyebrow_thickness: u8;
    mii_eyebrow_angle:     u8;
    mii_eyebrow_pos_x:     u8;
    mii_eyebrow_pos_y:     u8;
    mii_nose_style:        u8;
    mii_nose_size:         u8;
    mii_nose_pos:          u8;
    mii_mouth_style:       u8;
    mii_mouth_color:       u8;
    mii_mouth_size:        u8;
    mii_mouth_thickness:   u8;
    mii_mouth_pos:         u8;
    mii_facial_hair_color: u8;
    mii_beard_style:       u8;
    mii_mustache_style:    u8;
    mii_mustache_size:     u8;
    mii_mustache_pos:      u8;
    mii_glasses_style:     u8;
    mii_glasses_color:     u8;
    mii_glasses_size:      u8;
    mii_glasses_pos:       u8;
    mii_has_mole:          u8;
    mii_mole_size:         u8;
    mii_mole_pos_x:        u8;
    mii_mole_pos_y:        u8;
    unk_x57:               u8;
}

// Original Mii colors and types before Ver3StoreData conversion
MiiNfpStoreDataExtension :: struct {
    faceline_color: u8;
    hair_color:     u8;
    eye_color:      u8;
    eyebrow_color:  u8;
    mouth_color:    u8;
    beard_color:    u8;
    glass_color:    u8;
    glass_type:     u8;
}

/// Initialize mii.
miiInitialize :: (service_type: MiiServiceType) -> Result #foreign libnx;

/// Exit mii.
miiExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual mii service session.
miiGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Opens a mii database.
* @param[in] key_code Mii key code filter.
* @param[out] out Database.
*/
miiOpenDatabase :: (out: *MiiDatabase, key_code: MiiSpecialKeyCode) -> Result #foreign libnx;

/**
* @brief Returns whether the mii database is updated.
* @param[in] db Database.
* @param[in] flag Source flag.
* @param[out] out_updated Whether the mii database is updated.
*/
miiDatabaseIsUpdated :: (db: *MiiDatabase, out_updated: *bool, flag: MiiSourceFlag) -> Result #foreign libnx;

/**
* @brief Returns whether the mii database is full.
* @param[in] db Database.
* @param[out] out_full Whether the mii database is full.
*/
miiDatabaseIsFull :: (db: *MiiDatabase, out_full: *bool) -> Result #foreign libnx;

/**
* @brief Returns number of miis in the database with the specified source flag.
* @param[in] db Database.
* @param[in] flag Source flag.
* @param[out] out_count Out mii count.
*/
miiDatabaseGetCount :: (db: *MiiDatabase, out_count: *s32, flag: MiiSourceFlag) -> Result #foreign libnx;

/**
* @brief Reads mii charinfo data from the specified source flag.
* @param[in] db Database.
* @param[in] flag Source flag.
* @param[out] out_infos Output mii charinfo array.
* @param[in] count Number of mii chainfos to read.
* @param[out] total_out Number of mii charinfos which were actually read.
*/
miiDatabaseGet1 :: (db: *MiiDatabase, flag: MiiSourceFlag, out_infos: *MiiCharInfo, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Generates a random mii charinfo (doesn't register it in the console database).
* @param[in] db Database.
* @param[in] age Mii's age.
* @param[in] gender Mii's gender.
* @param[in] face_color Mii's face color.
* @param[out] out_info Out mii charinfo data.
*/
miiDatabaseBuildRandom :: (db: *MiiDatabase, age: MiiAge, gender: MiiGender, face_color: MiiFaceColor, out_info: *MiiCharInfo) -> Result #foreign libnx;

/// Closes a mii database.
miiDatabaseClose :: (db: *MiiDatabase) -> void #foreign libnx;

/// NfpServiceType
NfpServiceType :: enum u32 {
    User   :: 0;
    Debug  :: 1;
    System :: 2;
}

/// NfcServiceType
NfcServiceType :: enum u32 {
    User   :: 0;
    System :: 1;
}

NfpState :: enum u32 {
    NonInitialized :: 0;
    Initialized    :: 1;
}

NfcState :: enum u32 {
    NonInitialized :: 0;
    Initialized    :: 1;
}

NfpDeviceState :: enum u32 {
    Initialized     :: 0;
    SearchingForTag :: 1;
    TagFound        :: 2;
    TagRemoved      :: 3;
    TagMounted      :: 4;
    Unavailable     :: 5;
    Finalized       :: 6;
}

NfcDeviceState :: enum u32 {
    Initialized     :: 0;
    SearchingForTag :: 1;
    TagFound        :: 2;
    TagRemoved      :: 3;
    TagMounted      :: 4;
    Unavailable     :: 5;
    Finalized       :: 6;
}

NfpApplicationAreaVersion :: enum u32 {
    _3DS   :: 0;
    WiiU   :: 1;
    _3DSv2 :: 2;
    Switch :: 3;
    NotSet :: 255;
}

NfpDeviceType :: enum u32 {
    Amiibo :: 0;
}

NfpMountTarget :: enum u32 {
    Rom :: 1;
    Ram :: 2;
    All :: 3;
}

NfcProtocol :: enum u32 {
    None  :: 0;
    TypeA :: 1;
    TypeB :: 2;
    TypeF :: 4;
    All   :: 4294967295;
}

NfcTagType :: enum u32 {
    None   :: 0;
    Type1  :: 1;
    Type2  :: 2;
    Type3  :: 4;
    Type4A :: 8;
    Type4B :: 16;
    Type5  :: 32;
    Mifare :: 64;
    All    :: 4294967295;
}

NfcMifareCommand :: enum u32 {
    Read      :: 48;
    AuthA     :: 96;
    AuthB     :: 97;
    Write     :: 160;
    Transfer  :: 176;
    Decrement :: 192;
    Increment :: 193;
    Store     :: 194;
}

NfpTagInfo :: struct {
    uuid:        [10] u8;
    uuid_length: u8;
    reserved1:   [21] u8;
    protocol:    u32;
    tag_type:    u32;
    reserved2:   [48] u8;
}

NfcTagInfo :: struct {
    uuid:        [10] u8;
    uuid_length: u8;
    reserved1:   [21] u8;
    protocol:    u32;
    tag_type:    u32;
    reserved2:   [48] u8;
}

NfpCommonInfo :: struct {
    last_write_year:       u16;
    last_write_month:      u8;
    last_write_day:        u8;
    write_counter:         u16;
    version:               u16;
    application_area_size: u32;
    reserved:              [52] u8;
}

NfpModelInfo :: struct {
    amiibo_id: [8] u8;
    reserved:  [56] u8;
}

NfpRegisterInfo :: struct {
    mii:               MiiCharInfo;
    first_write_year:  u16;
    first_write_month: u8;
    first_write_day:   u8;
    amiibo_name:       [41] u8; ///< utf-8, null-terminated
    font_region:       u8;
    reserved:          [122] u8;
}

NfpRegisterInfoPrivate :: struct {
    mii_store_data:    [68] u8;
    first_write_year:  u16;
    first_write_month: u8;
    first_write_day:   u8;
    amiibo_name:       [41] u8; ///< utf-8, null-terminated
    font_region:       u8;
    reserved:          [142] u8;
}

NfpAdminInfo :: struct {
    application_id:           u64;
    application_area_id:      u32;
    crc_change_counter:       u16;
    flags:                    u8;
    tag_type:                 u8;
    application_area_version: u8;
    reserved:                 [47] u8;
}

NfpData :: struct {
    magic:                     u8;
    reserved1:                 [1] u8;
    write_counter:             u8;
    reserved2:                 [1] u8;
    settings_crc:              u32;
    reserved3:                 [56] u8;
    last_write_year:           u16;
    last_write_month:          u8;
    last_write_day:            u8;
    application_write_counter: u16;
    version:                   u16;
    application_area_size:     u32;
    reserved4:                 [52] u8;
    mii:                       MiiCharInfo;
    mii_store_data_extension:  MiiNfpStoreDataExtension;
    first_write_year:          u16;
    first_write_month:         u8;
    first_write_day:           u8;
    amiibo_name:               [11] u16; ///< utf-16, null-terminated
    settings_flag:             u8; ///< bit4 = amiibo was initialized in console settings, bit5 = has application area
    unknown1:                  u8; ///< Normally zero
    register_info_crc:         u32;
    unknown2:                  [5] u32; ///< Normally zero
    reserved5:                 [100] u8;
    application_id:            u64;
    access_id:                 u32;
    settings_crc_counter:      u16;
    font_region:               u8;
    tag_type:                  u8;
    console_type:              u8;
    application_id_byte:       u8; ///< (Original Program ID >> 0x24) & 0xF byte (Program ID has this byte swapped with console type)
    reserved6:                 [46] u8;
    application_area:          [216] u8;
}

NfcSectorKey :: struct {
    mifare_command: u8;
    unknown:        u8; ///< Usually 1
    reserved1:      [6] u8;
    sector_key:     [6] u8;
    reserved2:      [2] u8;
}

NfcMifareReadBlockParameter :: struct {
    sector_number: u8;
    reserved:      [7] u8;
    sector_key:    NfcSectorKey;
}

NfcMifareReadBlockData :: struct {
    data:          [16] u8;
    sector_number: u8;
    reserved:      [7] u8;
}

NfcMifareWriteBlockParameter :: struct {
    data:          [16] u8;
    sector_number: u8;
    reserved:      [7] u8;
    sector_key:    NfcSectorKey;
}

NfcRequiredMcuVersionData :: struct {
    version:  u64;
    reserved: [3] u64;
}

/// Nfc/Nfp DeviceHandle
NfcDeviceHandle :: struct {
    handle: [8] u8; ///< Handle.
}

/// Initialize nfp:*.
nfpInitialize :: (service_type: NfpServiceType) -> Result #foreign libnx;

/// Exit nfp:*.
nfpExit :: () -> void #foreign libnx;

/// Initialize nfc:*.
nfcInitialize :: (service_type: NfcServiceType) -> Result #foreign libnx;

/// Exit nfc:*.
nfcExit :: () -> void #foreign libnx;

/// Initialize nfc:mf:u.
nfcMfInitialize :: (__args: ..Any) -> Result #foreign libnx;

/// Exit nfc:mf:u.
nfcMfExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual nfp:* service session.
nfpGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for the interface from nfp:*.
nfpGetServiceSession_Interface :: () -> *Service #foreign libnx;

/// Gets the Service object for the actual nfc:* service session.
nfcGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for the interface from nfc:*.
nfcGetServiceSession_Interface :: () -> *Service #foreign libnx;

/// Gets the Service object for the actual nfc:mf:u service session.
nfcMfGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for the interface from nfc:mf:u.
nfcMfGetServiceSession_Interface :: () -> *Service #foreign libnx;

nfpListDevices :: (total_out: *s32, out: *NfcDeviceHandle, count: s32) -> Result #foreign libnx;
nfpStartDetection :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;
nfpStopDetection :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;
nfpMount :: (handle: *NfcDeviceHandle, device_type: NfpDeviceType, mount_target: NfpMountTarget) -> Result #foreign libnx;
nfpUnmount :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcListDevices :: (total_out: *s32, out: *NfcDeviceHandle, count: s32) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcStartDetection :: (handle: *NfcDeviceHandle, protocol: NfcProtocol) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcStopDetection :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

nfcMfListDevices :: (total_out: *s32, out: *NfcDeviceHandle, count: s32) -> Result #foreign libnx;
nfcMfStartDetection :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;
nfcMfStopDetection :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
nfpOpenApplicationArea :: (handle: *NfcDeviceHandle, app_id: u32) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
nfpGetApplicationArea :: (handle: *NfcDeviceHandle, buf: *void, buf_size: u64, out_size: *u32) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
nfpSetApplicationArea :: (handle: *NfcDeviceHandle, buf: *void, buf_size: u64) -> Result #foreign libnx;
nfpFlush :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;
nfpRestore :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
nfpCreateApplicationArea :: (handle: *NfcDeviceHandle, app_id: u32, buf: *void, buf_size: u64) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
/// Only available with [3.0.0+].
nfpRecreateApplicationArea :: (handle: *NfcDeviceHandle, app_id: u32, buf: *void, buf_size: u64) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_System.
nfpGetApplicationAreaSize :: (handle: *NfcDeviceHandle, out_app_area_size: *u32) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpDeleteApplicationArea :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpExistsApplicationArea :: (handle: *NfcDeviceHandle, out: *bool) -> Result #foreign libnx;

nfpGetTagInfo :: (handle: *NfcDeviceHandle, out: *NfpTagInfo) -> Result #foreign libnx;
nfpGetRegisterInfo :: (handle: *NfcDeviceHandle, out: *NfpRegisterInfo) -> Result #foreign libnx;
nfpGetCommonInfo :: (handle: *NfcDeviceHandle, out: *NfpCommonInfo) -> Result #foreign libnx;
nfpGetModelInfo :: (handle: *NfcDeviceHandle, out: *NfpModelInfo) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpGetAdminInfo :: (handle: *NfcDeviceHandle, out: *NfpAdminInfo) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcGetTagInfo :: (handle: *NfcDeviceHandle, out: *NfcTagInfo) -> Result #foreign libnx;

nfcMfGetTagInfo :: (handle: *NfcDeviceHandle, out: *NfcTagInfo) -> Result #foreign libnx;

/// Returned event will have autoclear off.
nfpAttachActivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear off.
nfpAttachDeactivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear off.
/// Only available with [4.0.0+].
nfcAttachActivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear off.
/// Only available with [4.0.0+].
nfcAttachDeactivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear off.
nfcMfAttachActivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear off.
nfcMfAttachDeactivateEvent :: (handle: *NfcDeviceHandle, out_event: *Event) -> Result #foreign libnx;

nfpGetState :: (out: *NfpState) -> Result #foreign libnx;
nfpGetDeviceState :: (handle: *NfcDeviceHandle, out: *NfpDeviceState) -> Result #foreign libnx;
nfpGetNpadId :: (handle: *NfcDeviceHandle, out: *u32) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcGetState :: (out: *NfcState) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcGetDeviceState :: (handle: *NfcDeviceHandle, out: *NfcDeviceState) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcGetNpadId :: (handle: *NfcDeviceHandle, out: *u32) -> Result #foreign libnx;

nfcMfGetState :: (out: *NfcState) -> Result #foreign libnx;
nfcMfGetDeviceState :: (handle: *NfcDeviceHandle, out: *NfcDeviceState) -> Result #foreign libnx;
nfcMfGetNpadId :: (handle: *NfcDeviceHandle, out: *u32) -> Result #foreign libnx;

/// Returned event will have autoclear on.
/// Only available with [3.0.0+].
nfpAttachAvailabilityChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear on.
/// Only available with [4.0.0+].
nfcAttachAvailabilityChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Returned event will have autoclear on.
nfcMfAttachAvailabilityChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpGetRegisterInfoPrivate :: (handle: *NfcDeviceHandle, out: *NfpRegisterInfoPrivate) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpSetRegisterInfoPrivate :: (handle: *NfcDeviceHandle, register_info_private: *NfpRegisterInfoPrivate) -> Result #foreign libnx;

/// Not available with ::NfpServiceType_User.
nfpDeleteRegisterInfo :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpGetAll :: (handle: *NfcDeviceHandle, out: *NfpData) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpSetAll :: (handle: *NfcDeviceHandle, nfp_data: *NfpData) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpFlushDebug :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpBreakTag :: (handle: *NfcDeviceHandle, break_type: u32) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpReadBackupData :: (handle: *NfcDeviceHandle, out_buf: *void, buf_size: u64, out_size: *u32) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpWriteBackupData :: (handle: *NfcDeviceHandle, buf: *void, buf_size: u64) -> Result #foreign libnx;

/// Only available with ::NfpServiceType_Debug.
nfpWriteNtf :: (handle: *NfcDeviceHandle, write_type: u32, buf: *void, buf_size: u64) -> Result #foreign libnx;

/// This uses nfc:*.
nfcIsNfcEnabled :: (out: *bool) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcReadMifare :: (handle: *NfcDeviceHandle, out_block_data: *NfcMifareReadBlockData, read_block_parameter: *NfcMifareReadBlockParameter, count: s32) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcWriteMifare :: (handle: *NfcDeviceHandle, write_block_parameter: *NfcMifareWriteBlockParameter, count: s32) -> Result #foreign libnx;

nfcMfReadMifare :: (handle: *NfcDeviceHandle, out_block_data: *NfcMifareReadBlockData, read_block_parameter: *NfcMifareReadBlockParameter, count: s32) -> Result #foreign libnx;
nfcMfWriteMifare :: (handle: *NfcDeviceHandle, write_block_parameter: *NfcMifareWriteBlockParameter, count: s32) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcSendCommandByPassThrough :: (handle: *NfcDeviceHandle, timeout: u64, cmd_buf: *void, cmd_buf_size: u64, reply_buf: *void, reply_buf_size: u64, out_size: *u64) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcKeepPassThroughSession :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// Only available with [4.0.0+].
nfcReleasePassThroughSession :: (handle: *NfcDeviceHandle) -> Result #foreign libnx;

/// WLAN State.
WlanInfState :: enum u32 {
    NotConnected :: 1;
    Connecting   :: 2;
    Connected    :: 3;
}

/// [1.0.0-14.1.2] Initialize wlan:inf.
wlaninfInitialize :: () -> Result #foreign libnx;

/// Exit wlan:inf.
wlaninfExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual wlan:inf service session.
wlaninfGetServiceSession :: () -> *Service #foreign libnx;

/// Gets \ref WlanInfState.
wlaninfGetState :: (out: *WlanInfState) -> Result #foreign libnx;

/// Value goes from -30 (really good signal) to -90 (barely enough to stay connected)
/// on a logarithmic scale
wlaninfGetRSSI :: (out: *s32) -> Result #foreign libnx;

PctlRestrictionSettings :: struct {
    rating_age:                     u8;
    sns_post_restriction:           bool;
    free_communication_restriction: bool;
}

/// Initialize pctl.
pctlInitialize :: () -> Result #foreign libnx;

/// Exit pctl.
pctlExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual pctl service session.
pctlGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for IParentalControlService.
pctlGetServiceSession_Service :: () -> *Service #foreign libnx;

/// Gets whether Parental Controls restrictions are temporarily unlocked.
pctlIsRestrictionTemporaryUnlocked :: (flag: *bool) -> Result #foreign libnx;

/// Confirm whether VrMode is allowed. Only available with [4.0.0+].
pctlConfirmStereoVisionPermission :: () -> Result #foreign libnx;

/// Gets whether Parental Controls are enabled.
pctlIsRestrictionEnabled :: (flag: *bool) -> Result #foreign libnx;

/// Gets whether Parental Controls are enabled.
pctlGetSafetyLevel :: (safety_level: *u32) -> Result #foreign libnx;

/// Returns the current restrictions settings.
pctlGetCurrentSettings :: (settings: *PctlRestrictionSettings) -> Result #foreign libnx;

/// Gets the count of applications that have free communication.
pctlGetFreeCommunicationApplicationListCount :: (count: *u32) -> Result #foreign libnx;

/// Reset the confirmation done by \ref pctlConfirmStereoVisionPermission. Only available with [5.0.0+].
pctlResetConfirmedStereoVisionPermission :: () -> Result #foreign libnx;

/// Gets whether VrMode is allowed. Only available with [5.0.0+].
pctlIsStereoVisionPermitted :: (flag: *bool) -> Result #foreign libnx;

/// Confirm whether pairing is active.
pctlIsPairingActive :: (flag: *bool) -> Result #foreign libnx;

/// Returns the synchronization event.
pctlGetSynchronizationEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Returns the supension event.
pctlGetPlayTimerEventToRequestSuspension :: (out_event: *Event) -> Result #foreign libnx;

/// Confirm whether play timer alarm is disabled. Only available with [4.0.0+].
pctlIsPlayTimerAlarmDisabled :: (flag: *bool) -> Result #foreign libnx;

/// Returns the unlinked event.
pctlGetUnlinkedEvent :: (out_event: *Event) -> Result #foreign libnx;

// From Android PixelFormat.h & graphics-base-v1.0.h.
PIXEL_FORMAT :: enum u32 {
    RGBA_8888              :: 1;
    RGBX_8888              :: 2;
    RGB_888                :: 3;
    RGB_565                :: 4;
    BGRA_8888              :: 5;
    RGBA_5551              :: 6;
    RGBA_4444              :: 7;
    YCRCB_420_SP           :: 17;
    RAW16                  :: 32;
    BLOB                   :: 33;
    IMPLEMENTATION_DEFINED :: 34;
    YCBCR_420_888          :: 35;
    Y8                     :: 538982489;
    Y16                    :: 540422489;
    YV12                   :: 842094169;
}

// From Android gralloc.h.
GRALLOC_USAGE :: enum u32 {
    SW_READ_NEVER    :: 0;

    SW_READ_RARELY   :: 2;

    SW_READ_OFTEN    :: 3;

    SW_READ_MASK     :: 15;

    SW_WRITE_NEVER   :: 0;

    SW_WRITE_RARELY  :: 32;

    SW_WRITE_OFTEN   :: 48;

    SW_WRITE_MASK    :: 240;

    HW_TEXTURE       :: 256;

    HW_RENDER        :: 512;

    HW_2D            :: 1024;

    HW_COMPOSER      :: 2048;

    HW_FB            :: 4096;

    EXTERNAL_DISP    :: 8192;

    PROTECTED        :: 16384;

    CURSOR           :: 32768;

    HW_VIDEO_ENCODER :: 65536;

    HW_CAMERA_WRITE  :: 131072;

    HW_CAMERA_READ   :: 262144;

    HW_CAMERA_ZSL    :: 393216;

    HW_CAMERA_MASK   :: 393216;

    HW_MASK          :: 466688;

    RENDERSCRIPT     :: 1048576;
}

// From Android window.h.
/* attributes queriable with query() */
NATIVE_WINDOW :: enum u32 {
    WIDTH  :: 0;
    HEIGHT :: 1;
    FORMAT :: 2;
}

// From Android window.h.
/* parameter for NATIVE_WINDOW_[API_][DIS]CONNECT */
anon_enum :: enum u32 {
    NATIVE_WINDOW_API_CPU :: 2;
}

/**
* Transformation definitions
*
* IMPORTANT NOTE:
* HAL_TRANSFORM_ROT_90 is applied CLOCKWISE and AFTER HAL_TRANSFORM_FLIP_{H|V}.
*
*/
HAL_TRANSFORM :: enum u32 {
    FLIP_H  :: 1;

    FLIP_V  :: 2;

    ROT_90  :: 4;

    ROT_180 :: 3;

    ROT_270 :: 7;
}

// From Android window.h.
/* parameter for NATIVE_WINDOW_SET_BUFFERS_TRANSFORM */
NATIVE_WINDOW_TRANSFORM :: enum u32 {
    FLIP_H  :: 1;

    FLIP_V  :: 2;

    ROT_90  :: 4;

    ROT_180 :: 3;

    ROT_270 :: 7;
}

// From Android native_handle.h.
NativeHandle :: struct {
    version:  s32;
    num_fds:  s32;
    num_ints: s32;
}

iova_t :: u64;

NvLayout :: enum u32 {
    Pitch       :: 1;
    Tiled       :: 2;
    BlockLinear :: 3;
}

NvDisplayScanFormat :: enum u32 {
    Progressive :: 0;
    Interlaced  :: 1;
}

NvKind :: enum u32 {
    Pitch                        :: 0;
    Z16                          :: 1;
    Z16_2C                       :: 2;
    Z16_MS2_2C                   :: 3;
    Z16_MS4_2C                   :: 4;
    Z16_MS8_2C                   :: 5;
    Z16_MS16_2C                  :: 6;
    Z16_2Z                       :: 7;
    Z16_MS2_2Z                   :: 8;
    Z16_MS4_2Z                   :: 9;
    Z16_MS8_2Z                   :: 10;
    Z16_MS16_2Z                  :: 11;
    Z16_4CZ                      :: 12;
    Z16_MS2_4CZ                  :: 13;
    Z16_MS4_4CZ                  :: 14;
    Z16_MS8_4CZ                  :: 15;
    Z16_MS16_4CZ                 :: 16;
    S8Z24                        :: 17;
    S8Z24_1Z                     :: 18;
    S8Z24_MS2_1Z                 :: 19;
    S8Z24_MS4_1Z                 :: 20;
    S8Z24_MS8_1Z                 :: 21;
    S8Z24_MS16_1Z                :: 22;
    S8Z24_2CZ                    :: 23;
    S8Z24_MS2_2CZ                :: 24;
    S8Z24_MS4_2CZ                :: 25;
    S8Z24_MS8_2CZ                :: 26;
    S8Z24_MS16_2CZ               :: 27;
    S8Z24_2CS                    :: 28;
    S8Z24_MS2_2CS                :: 29;
    S8Z24_MS4_2CS                :: 30;
    S8Z24_MS8_2CS                :: 31;
    S8Z24_MS16_2CS               :: 32;
    S8Z24_4CSZV                  :: 33;
    S8Z24_MS2_4CSZV              :: 34;
    S8Z24_MS4_4CSZV              :: 35;
    S8Z24_MS8_4CSZV              :: 36;
    S8Z24_MS16_4CSZV             :: 37;
    V8Z24_MS4_VC12               :: 38;
    V8Z24_MS4_VC4                :: 39;
    V8Z24_MS8_VC8                :: 40;
    V8Z24_MS8_VC24               :: 41;
    S8                           :: 42;
    S8_2S                        :: 43;
    V8Z24_MS4_VC12_1ZV           :: 46;
    V8Z24_MS4_VC4_1ZV            :: 47;
    V8Z24_MS8_VC8_1ZV            :: 48;
    V8Z24_MS8_VC24_1ZV           :: 49;
    V8Z24_MS4_VC12_2CS           :: 50;
    V8Z24_MS4_VC4_2CS            :: 51;
    V8Z24_MS8_VC8_2CS            :: 52;
    V8Z24_MS8_VC24_2CS           :: 53;
    V8Z24_MS4_VC12_2CZV          :: 58;
    V8Z24_MS4_VC4_2CZV           :: 59;
    V8Z24_MS8_VC8_2CZV           :: 60;
    V8Z24_MS8_VC24_2CZV          :: 61;
    V8Z24_MS4_VC12_2ZV           :: 62;
    V8Z24_MS4_VC4_2ZV            :: 63;
    V8Z24_MS8_VC8_2ZV            :: 64;
    V8Z24_MS8_VC24_2ZV           :: 65;
    V8Z24_MS4_VC12_4CSZV         :: 66;
    V8Z24_MS4_VC4_4CSZV          :: 67;
    V8Z24_MS8_VC8_4CSZV          :: 68;
    V8Z24_MS8_VC24_4CSZV         :: 69;
    Z24S8                        :: 70;
    Z24S8_1Z                     :: 71;
    Z24S8_MS2_1Z                 :: 72;
    Z24S8_MS4_1Z                 :: 73;
    Z24S8_MS8_1Z                 :: 74;
    Z24S8_MS16_1Z                :: 75;
    Z24S8_2CS                    :: 76;
    Z24S8_MS2_2CS                :: 77;
    Z24S8_MS4_2CS                :: 78;
    Z24S8_MS8_2CS                :: 79;
    Z24S8_MS16_2CS               :: 80;
    Z24S8_2CZ                    :: 81;
    Z24S8_MS2_2CZ                :: 82;
    Z24S8_MS4_2CZ                :: 83;
    Z24S8_MS8_2CZ                :: 84;
    Z24S8_MS16_2CZ               :: 85;
    Z24S8_4CSZV                  :: 86;
    Z24S8_MS2_4CSZV              :: 87;
    Z24S8_MS4_4CSZV              :: 88;
    Z24S8_MS8_4CSZV              :: 89;
    Z24S8_MS16_4CSZV             :: 90;
    Z24V8_MS4_VC12               :: 91;
    Z24V8_MS4_VC4                :: 92;
    Z24V8_MS8_VC8                :: 93;
    Z24V8_MS8_VC24               :: 94;
    Z24V8_MS4_VC12_1ZV           :: 99;
    Z24V8_MS4_VC4_1ZV            :: 100;
    Z24V8_MS8_VC8_1ZV            :: 101;
    Z24V8_MS8_VC24_1ZV           :: 102;
    Z24V8_MS4_VC12_2CS           :: 103;
    Z24V8_MS4_VC4_2CS            :: 104;
    Z24V8_MS8_VC8_2CS            :: 105;
    Z24V8_MS8_VC24_2CS           :: 106;
    Z24V8_MS4_VC12_2CZV          :: 111;
    Z24V8_MS4_VC4_2CZV           :: 112;
    Z24V8_MS8_VC8_2CZV           :: 113;
    Z24V8_MS8_VC24_2CZV          :: 114;
    Z24V8_MS4_VC12_2ZV           :: 115;
    Z24V8_MS4_VC4_2ZV            :: 116;
    Z24V8_MS8_VC8_2ZV            :: 117;
    Z24V8_MS8_VC24_2ZV           :: 118;
    Z24V8_MS4_VC12_4CSZV         :: 119;
    Z24V8_MS4_VC4_4CSZV          :: 120;
    Z24V8_MS8_VC8_4CSZV          :: 121;
    Z24V8_MS8_VC24_4CSZV         :: 122;
    ZF32                         :: 123;
    ZF32_1Z                      :: 124;
    ZF32_MS2_1Z                  :: 125;
    ZF32_MS4_1Z                  :: 126;
    ZF32_MS8_1Z                  :: 127;
    ZF32_MS16_1Z                 :: 128;
    ZF32_2CS                     :: 129;
    ZF32_MS2_2CS                 :: 130;
    ZF32_MS4_2CS                 :: 131;
    ZF32_MS8_2CS                 :: 132;
    ZF32_MS16_2CS                :: 133;
    ZF32_2CZ                     :: 134;
    ZF32_MS2_2CZ                 :: 135;
    ZF32_MS4_2CZ                 :: 136;
    ZF32_MS8_2CZ                 :: 137;
    ZF32_MS16_2CZ                :: 138;
    X8Z24_X16V8S8_MS4_VC12       :: 139;
    X8Z24_X16V8S8_MS4_VC4        :: 140;
    X8Z24_X16V8S8_MS8_VC8        :: 141;
    X8Z24_X16V8S8_MS8_VC24       :: 142;
    X8Z24_X16V8S8_MS4_VC12_1CS   :: 143;
    X8Z24_X16V8S8_MS4_VC4_1CS    :: 144;
    X8Z24_X16V8S8_MS8_VC8_1CS    :: 145;
    X8Z24_X16V8S8_MS8_VC24_1CS   :: 146;
    X8Z24_X16V8S8_MS4_VC12_1ZV   :: 151;
    X8Z24_X16V8S8_MS4_VC4_1ZV    :: 152;
    X8Z24_X16V8S8_MS8_VC8_1ZV    :: 153;
    X8Z24_X16V8S8_MS8_VC24_1ZV   :: 154;
    X8Z24_X16V8S8_MS4_VC12_1CZV  :: 155;
    X8Z24_X16V8S8_MS4_VC4_1CZV   :: 156;
    X8Z24_X16V8S8_MS8_VC8_1CZV   :: 157;
    X8Z24_X16V8S8_MS8_VC24_1CZV  :: 158;
    X8Z24_X16V8S8_MS4_VC12_2CS   :: 159;
    X8Z24_X16V8S8_MS4_VC4_2CS    :: 160;
    X8Z24_X16V8S8_MS8_VC8_2CS    :: 161;
    X8Z24_X16V8S8_MS8_VC24_2CS   :: 162;
    X8Z24_X16V8S8_MS4_VC12_2CSZV :: 163;
    X8Z24_X16V8S8_MS4_VC4_2CSZV  :: 164;
    X8Z24_X16V8S8_MS8_VC8_2CSZV  :: 165;
    X8Z24_X16V8S8_MS8_VC24_2CSZV :: 166;
    ZF32_X16V8S8_MS4_VC12        :: 167;
    ZF32_X16V8S8_MS4_VC4         :: 168;
    ZF32_X16V8S8_MS8_VC8         :: 169;
    ZF32_X16V8S8_MS8_VC24        :: 170;
    ZF32_X16V8S8_MS4_VC12_1CS    :: 171;
    ZF32_X16V8S8_MS4_VC4_1CS     :: 172;
    ZF32_X16V8S8_MS8_VC8_1CS     :: 173;
    ZF32_X16V8S8_MS8_VC24_1CS    :: 174;
    ZF32_X16V8S8_MS4_VC12_1ZV    :: 179;
    ZF32_X16V8S8_MS4_VC4_1ZV     :: 180;
    ZF32_X16V8S8_MS8_VC8_1ZV     :: 181;
    ZF32_X16V8S8_MS8_VC24_1ZV    :: 182;
    ZF32_X16V8S8_MS4_VC12_1CZV   :: 183;
    ZF32_X16V8S8_MS4_VC4_1CZV    :: 184;
    ZF32_X16V8S8_MS8_VC8_1CZV    :: 185;
    ZF32_X16V8S8_MS8_VC24_1CZV   :: 186;
    ZF32_X16V8S8_MS4_VC12_2CS    :: 187;
    ZF32_X16V8S8_MS4_VC4_2CS     :: 188;
    ZF32_X16V8S8_MS8_VC8_2CS     :: 189;
    ZF32_X16V8S8_MS8_VC24_2CS    :: 190;
    ZF32_X16V8S8_MS4_VC12_2CSZV  :: 191;
    ZF32_X16V8S8_MS4_VC4_2CSZV   :: 192;
    ZF32_X16V8S8_MS8_VC8_2CSZV   :: 193;
    ZF32_X16V8S8_MS8_VC24_2CSZV  :: 194;
    ZF32_X24S8                   :: 195;
    ZF32_X24S8_1CS               :: 196;
    ZF32_X24S8_MS2_1CS           :: 197;
    ZF32_X24S8_MS4_1CS           :: 198;
    ZF32_X24S8_MS8_1CS           :: 199;
    ZF32_X24S8_MS16_1CS          :: 200;
    SmskedMessage                :: 202;
    SmhostMessage                :: 203;
    C64_MS2_2CRA                 :: 205;
    ZF32_X24S8_2CSZV             :: 206;
    ZF32_X24S8_MS2_2CSZV         :: 207;
    ZF32_X24S8_MS4_2CSZV         :: 208;
    ZF32_X24S8_MS8_2CSZV         :: 209;
    ZF32_X24S8_MS16_2CSZV        :: 210;
    ZF32_X24S8_2CS               :: 211;
    ZF32_X24S8_MS2_2CS           :: 212;
    ZF32_X24S8_MS4_2CS           :: 213;
    ZF32_X24S8_MS8_2CS           :: 214;
    ZF32_X24S8_MS16_2CS          :: 215;
    C32_2C                       :: 216;
    C32_2CBR                     :: 217;
    C32_2CBA                     :: 218;
    C32_2CRA                     :: 219;
    C32_2BRA                     :: 220;
    C32_MS2_2C                   :: 221;
    C32_MS2_2CBR                 :: 222;
    C32_MS2_2CRA                 :: 204;
    C32_MS4_2C                   :: 223;
    C32_MS4_2CBR                 :: 224;
    C32_MS4_2CBA                 :: 225;
    C32_MS4_2CRA                 :: 226;
    C32_MS4_2BRA                 :: 227;
    C32_MS8_MS16_2C              :: 228;
    C32_MS8_MS16_2CRA            :: 229;
    C64_2C                       :: 230;
    C64_2CBR                     :: 231;
    C64_2CBA                     :: 232;
    C64_2CRA                     :: 233;
    C64_2BRA                     :: 234;
    C64_MS2_2C                   :: 235;
    C64_MS2_2CBR                 :: 236;
    C64_MS4_2C                   :: 237;
    C64_MS4_2CBR                 :: 238;
    C64_MS4_2CBA                 :: 239;
    C64_MS4_2CRA                 :: 240;
    C64_MS4_2BRA                 :: 241;
    C64_MS8_MS16_2C              :: 242;
    C64_MS8_MS16_2CRA            :: 243;
    C128_2C                      :: 244;
    C128_2CR                     :: 245;
    C128_MS2_2C                  :: 246;
    C128_MS2_2CR                 :: 247;
    C128_MS4_2C                  :: 248;
    C128_MS4_2CR                 :: 249;
    C128_MS8_MS16_2C             :: 250;
    C128_MS8_MS16_2CR            :: 251;
    X8C24                        :: 252;
    PitchNoSwizzle               :: 253;
    Generic_16BX2                :: 254;
    Invalid                      :: 255;
}

NvColorFormat :: enum u64 {
    Unspecified                     :: 0;
    NonColor8                       :: 153093128;
    NonColor16                      :: 153094672;
    NonColor24                      :: 153098776;
    NonColor32                      :: 153099296;
    X4C4                            :: 153158920;
    A4L4                            :: 4299752712;
    A8L8                            :: 4299755024;
    Float_A16L16                    :: 4299775264;
    A1B5G5R5                        :: 4300411920;
    A4B4G4R4                        :: 4300412176;
    A5B5G5R1                        :: 4300412944;
    A2B10G10R10                     :: 4300415008;
    A8B8G8R8                        :: 4300415264;
    A16B16G16R16                    :: 4300416832;
    Float_A16B16G16R16              :: 4300433216;
    A1R5G5B5                        :: 4308669456;
    A4R4G4B4                        :: 4308669712;
    A5R1G5B5                        :: 4308669968;
    A2R10G10B10                     :: 4308672544;
    A8R8G8B8                        :: 4308672800;
    A1                              :: 4314104065;
    A2                              :: 4314104322;
    A4                              :: 4314104580;
    A8                              :: 4314104840;
    A16                             :: 4314106384;
    A32                             :: 4314111008;
    Float_A16                       :: 4314122768;
    L4A4                            :: 4328523016;
    L8A8                            :: 4328525328;
    B4G4R4A4                        :: 4396291344;
    B5G5R1A5                        :: 4396291856;
    B5G5R5A1                        :: 4396292112;
    B8G8R8A8                        :: 4396294432;
    B10G10R10A2                     :: 4396294944;
    R1G5B5A5                        :: 4404548624;
    R4G4B4A4                        :: 4404548880;
    R5G5B5A1                        :: 4404549648;
    R8G8B8A8                        :: 4404551968;
    R10G10B10A2                     :: 4404552480;
    L1                              :: 4462739713;
    L2                              :: 4462739970;
    L4                              :: 4462740228;
    L8                              :: 4462740488;
    L16                             :: 4462742032;
    L32                             :: 4462746656;
    Float_L16                       :: 4462758416;
    B5G6R5                          :: 4463399440;
    B6G5R5                          :: 4463399696;
    B5G5R5X1                        :: 4463400976;
    B8_G8_R8                        :: 4463401240;
    B8G8R8X8                        :: 4463403296;
    Float_B10G11R11                 :: 4463418912;
    X1B5G5R5                        :: 4468184080;
    X8B8G8R8                        :: 4468187424;
    X16B16G16R16                    :: 4468188992;
    Float_X16B16G16R16              :: 4468205376;
    R3G3B2                          :: 4471653896;
    R5G5B6                          :: 4471656720;
    R5G6B5                          :: 4471656976;
    R5G5B5X1                        :: 4471658512;
    R8_G8_B8                        :: 4471658776;
    R8G8B8X8                        :: 4471660832;
    X1R5G5B5                        :: 4476441616;
    X8R8G8B8                        :: 4476444960;
    RG8                             :: 4480044560;
    R16G16                          :: 4480048416;
    Float_R16G16                    :: 4480064800;
    R8                              :: 4481614856;
    R16                             :: 4481616400;
    Float_R16                       :: 4481632784;
    A2B10G10R10_sRGB                :: 8595382304;
    A8B8G8R8_sRGB                   :: 8595382560;
    A16B16G16R16_sRGB               :: 8595384128;
    A2R10G10B10_sRGB                :: 8603639840;
    B10G10R10A2_sRGB                :: 8691262240;
    R10G10B10A2_sRGB                :: 8699519776;
    X8B8G8R8_sRGB                   :: 8763154720;
    X16B16G16R16_sRGB               :: 8763156288;
    A2B10G10R10_709                 :: 12890349600;
    A8B8G8R8_709                    :: 12890349856;
    A16B16G16R16_709                :: 12890351424;
    A2R10G10B10_709                 :: 12898607136;
    B10G10R10A2_709                 :: 12986229536;
    R10G10B10A2_709                 :: 12994487072;
    X8B8G8R8_709                    :: 13058122016;
    X16B16G16R16_709                :: 13058123584;
    A2B10G10R10_709_Linear          :: 17185316896;
    A8B8G8R8_709_Linear             :: 17185317152;
    A16B16G16R16_709_Linear         :: 17185318720;
    A2R10G10B10_709_Linear          :: 17193574432;
    B10G10R10A2_709_Linear          :: 17281196832;
    R10G10B10A2_709_Linear          :: 17289454368;
    X8B8G8R8_709_Linear             :: 17353089312;
    X16B16G16R16_709_Linear         :: 17353090880;
    Float_A16B16G16R16_scRGB_Linear :: 21480302400;
    A2B10G10R10_2020                :: 25775251488;
    A8B8G8R8_2020                   :: 25775251744;
    A16B16G16R16_2020               :: 25775253312;
    A2R10G10B10_2020                :: 25783509024;
    B10G10R10A2_2020                :: 25871131424;
    R10G10B10A2_2020                :: 25879388960;
    X8B8G8R8_2020                   :: 25943023904;
    X16B16G16R16_2020               :: 25943025472;
    A2B10G10R10_2020_Linear         :: 30070218784;
    A8B8G8R8_2020_Linear            :: 30070219040;
    A16B16G16R16_2020_Linear        :: 30070220608;
    Float_A16B16G16R16_2020_Linear  :: 30070236992;
    A2R10G10B10_2020_Linear         :: 30078476320;
    B10G10R10A2_2020_Linear         :: 30166098720;
    R10G10B10A2_2020_Linear         :: 30174356256;
    X8B8G8R8_2020_Linear            :: 30237991200;
    X16B16G16R16_2020_Linear        :: 30237992768;
    Float_A16B16G16R16_2020_PQ      :: 34365204288;
    A4I4                            :: 38673646856;
    A8I8                            :: 38673649168;
    I4A4                            :: 38707135752;
    I8A8                            :: 38707138064;
    I1                              :: 38807798017;
    I2                              :: 38807798274;
    I4                              :: 38807798532;
    I8                              :: 38807798792;
    A8Y8U8V8                        :: 42963378464;
    A16Y16U16V16                    :: 42963380032;
    Y8U8V8A8                        :: 43059257632;
    V8_U8                           :: 43084678928;
    V8U8                            :: 43084680720;
    V10U10                          :: 43085210144;
    V12U12                          :: 43085210656;
    V8                              :: 43086251016;
    V10                             :: 43086253840;
    V12                             :: 43086254096;
    U8_V8                           :: 43088348944;
    U8V8                            :: 43088350736;
    U10V10                          :: 43092550176;
    U12V12                          :: 43092550688;
    U8                              :: 43100931080;
    U10                             :: 43100933904;
    U12                             :: 43100934160;
    Y8                              :: 43102766088;
    Y10                             :: 43102768912;
    Y12                             :: 43102769168;
    YVYU                            :: 43122690064;
    VYUY                            :: 43122690320;
    YUYV                            :: 43126360080;
    UYVY                            :: 43126360336;
    Y8_U8_V8                        :: 43126364440;
    V8_U8_RR                        :: 47379646224;
    V8U8_RR                         :: 47379648016;
    V8_RR                           :: 47381218312;
    U8_V8_RR                        :: 47383316240;
    U8V8_RR                         :: 47383318032;
    U8_RR                           :: 47395898376;
    Y8_RR                           :: 47397733384;
    V8_U8_ER                        :: 51674613520;
    V8U8_ER                         :: 51674615312;
    V8_ER                           :: 51676185608;
    U8_V8_ER                        :: 51678283536;
    U8V8_ER                         :: 51678285328;
    U8_ER                           :: 51690865672;
    Y8_ER                           :: 51692700680;
    V8_U8_709                       :: 55969580816;
    V8U8_709                        :: 55969582608;
    V10U10_709                      :: 55970112032;
    V12U12_709                      :: 55970112544;
    V8_709                          :: 55971152904;
    V10_709                         :: 55971155728;
    V12_709                         :: 55971155984;
    U8_V8_709                       :: 55973250832;
    U8V8_709                        :: 55973252624;
    U10V10_709                      :: 55977452064;
    U12V12_709                      :: 55977452576;
    U8_709                          :: 55985832968;
    U10_709                         :: 55985835792;
    U12_709                         :: 55985836048;
    Y8_709                          :: 55987667976;
    Y10_709                         :: 55987670800;
    Y12_709                         :: 55987671056;
    V8_U8_709_ER                    :: 60264548112;
    V8U8_709_ER                     :: 60264549904;
    V10U10_709_ER                   :: 60265079328;
    V12U12_709_ER                   :: 60265079840;
    V8_709_ER                       :: 60266120200;
    V10_709_ER                      :: 60266123024;
    V12_709_ER                      :: 60266123280;
    U8_V8_709_ER                    :: 60268218128;
    U8V8_709_ER                     :: 60268219920;
    U10V10_709_ER                   :: 60272419360;
    U12V12_709_ER                   :: 60272419872;
    U8_709_ER                       :: 60280800264;
    U10_709_ER                      :: 60280803088;
    U12_709_ER                      :: 60280803344;
    Y8_709_ER                       :: 60282635272;
    Y10_709_ER                      :: 60282638096;
    Y12_709_ER                      :: 60282638352;
    V10U10_2020                     :: 64560046624;
    V12U12_2020                     :: 64560047136;
    V10_2020                        :: 64561090320;
    V12_2020                        :: 64561090576;
    U10V10_2020                     :: 64567386656;
    U12V12_2020                     :: 64567387168;
    U10_2020                        :: 64575770384;
    U12_2020                        :: 64575770640;
    Y10_2020                        :: 64577605392;
    Y12_2020                        :: 64577605648;
    Bayer8RGGB                      :: 68872569864;
    Bayer16RGGB                     :: 68872571408;
    BayerS16RGGB                    :: 68872604176;
    X2Bayer14RGGB                   :: 68872637200;
    X4Bayer12RGGB                   :: 68872637456;
    X6Bayer10RGGB                   :: 68872637712;
    Bayer8BGGR                      :: 73167537160;
    Bayer16BGGR                     :: 73167538704;
    BayerS16BGGR                    :: 73167571472;
    X2Bayer14BGGR                   :: 73167604496;
    X4Bayer12BGGR                   :: 73167604752;
    X6Bayer10BGGR                   :: 73167605008;
    Bayer8GRBG                      :: 77462504456;
    Bayer16GRBG                     :: 77462506000;
    BayerS16GRBG                    :: 77462538768;
    X2Bayer14GRBG                   :: 77462571792;
    X4Bayer12GRBG                   :: 77462572048;
    X6Bayer10GRBG                   :: 77462572304;
    Bayer8GBRG                      :: 81757471752;
    Bayer16GBRG                     :: 81757473296;
    BayerS16GBRG                    :: 81757506064;
    X2Bayer14GBRG                   :: 81757539088;
    X4Bayer12GBRG                   :: 81757539344;
    X6Bayer10GBRG                   :: 81757539600;
    XYZ                             :: 86076057152;
}

NvSurface :: struct {
    width:               u32;
    height:              u32;
    color_format:        NvColorFormat;
    layout:              NvLayout;
    pitch:               u32;
    unused:              u32; // usually this field contains the nvmap handle, but it's completely unused/overwritten during marshalling
    offset:              u32;
    kind:                NvKind;
    block_height_log2:   u32;
    scan:                NvDisplayScanFormat;
    second_field_offset: u32;
    flags:               u64;
    size:                u64;
    unk:                 [6] u32; // compression related
}

NvGraphicBuffer :: struct {
    header:     NativeHandle;
    unk0:       s32; // -1
    nvmap_id:   s32; // nvmap object id
    unk2:       u32; // 0
    magic:      u32; // 0xDAFFCAFF
    pid:        u32; // 42
    type:       u32; // ?
    usage:      u32; // GRALLOC_USAGE_* bitmask
    format:     u32; // PIXEL_FORMAT_*
    ext_format: u32; // copy of the above (in most cases)
    stride:     u32; // in pixels!
    total_size: u32; // in bytes
    num_planes: u32; // usually 1
    unk12:      u32; // 0
    planes:     [3] NvSurface;
    unused:     u64; // official sw writes a pointer to bookkeeping data here, but it's otherwise completely unused/overwritten during marshalling
}

Binder :: struct {
    created:     bool;
    initialized: bool;
    id:          s32;
    dummy:       u64;
    relay:       *Service;
}

// Note: binderClose will not close the session_handle provided to binderCreate.
binderCreate :: (b: *Binder, id: s32) -> void #foreign libnx;
binderClose :: (b: *Binder) -> void #foreign libnx;

binderInitSession :: (b: *Binder, relay: *Service) -> Result #foreign libnx;

binderTransactParcel :: (b: *Binder, code: u32, parcel_data: *void, parcel_data_size: u64, parcel_reply: *void, parcel_reply_size: u64, flags: u32) -> Result #foreign libnx;

binderConvertErrorCode :: (code: s32) -> Result #foreign libnx;

binderAdjustRefcount :: (b: *Binder, addval: s32, type: s32) -> Result #foreign libnx;
binderGetNativeHandle :: (b: *Binder, unk0: u32, event_out: *Event) -> Result #foreign libnx;

nvioctl_zcull_info :: struct {
    width_align_pixels:            u32; // 0x20  (32)
    height_align_pixels:           u32; // 0x20  (32)
    pixel_squares_by_aliquots:     u32; // 0x400 (1024)
    aliquot_total:                 u32; // 0x800 (2048)
    region_byte_multiplier:        u32; // 0x20  (32)
    region_header_size:            u32; // 0x20  (32)
    subregion_header_size:         u32; // 0xC0  (192)
    subregion_width_align_pixels:  u32; // 0x20  (32)
    subregion_height_align_pixels: u32; // 0x40  (64)
    subregion_count:               u32; // 0x10  (16)
}

nvioctl_zbc_entry :: struct {
    color_ds: [4] u32;
    color_l2: [4] u32;
    depth:    u32;
    ref_cnt:  u32;
    format:   u32;
    type:     u32;
    size:     u32;
}

nvioctl_gpu_characteristics :: struct {
    arch:                       u32; // 0x120 (NVGPU_GPU_ARCH_GM200)
    impl:                       u32; // 0xB (NVGPU_GPU_IMPL_GM20B)
    rev:                        u32; // 0xA1 (Revision A1)
    num_gpc:                    u32; // 0x1
    L2_cache_size:              u64; // 0x40000
    on_board_video_memory_size: u64; // 0x0 (not used)
    num_tpc_per_gpc:            u32; // 0x2
    bus_type:                   u32; // 0x20 (NVGPU_GPU_BUS_TYPE_AXI)
    big_page_size:              u32; // 0x20000
    compression_page_size:      u32; // 0x20000
    pde_coverage_bit_count:     u32; // 0x1B
    available_big_page_sizes:   u32; // 0x30000
    gpc_mask:                   u32; // 0x1
    sm_arch_sm_version:         u32; // 0x503 (Maxwell Generation 5.0.3?)
    sm_arch_spa_version:        u32; // 0x503 (Maxwell Generation 5.0.3?)
    sm_arch_warp_count:         u32; // 0x80
    gpu_va_bit_count:           u32; // 0x28
    reserved:                   u32; // NULL
    flags:                      u64; // 0x55
    twod_class:                 u32; // 0x902D (FERMI_TWOD_A)
    threed_class:               u32; // 0xB197 (MAXWELL_B)
    compute_class:              u32; // 0xB1C0 (MAXWELL_COMPUTE_B)
    gpfifo_class:               u32; // 0xB06F (MAXWELL_CHANNEL_GPFIFO_A)
    inline_to_memory_class:     u32; // 0xA140 (KEPLER_INLINE_TO_MEMORY_B)
    dma_copy_class:             u32; // 0xB0B5 (MAXWELL_DMA_COPY_A)
    max_fbps_count:             u32; // 0x1
    fbp_en_mask:                u32; // 0x0 (disabled)
    max_ltc_per_fbp:            u32; // 0x2
    max_lts_per_ltc:            u32; // 0x1
    max_tex_per_tpc:            u32; // 0x0 (not supported)
    max_gpc_count:              u32; // 0x1
    rop_l2_en_mask_0:           u32; // 0x21D70 (fuse_status_opt_rop_l2_fbp_r)
    rop_l2_en_mask_1:           u32; // 0x0
    chipname:                   u64; // 0x6230326D67 ("gm20b")
    gr_compbit_store_base_hw:   u64; // 0x0 (not supported)
}

nvioctl_va_region :: struct {
    offset:    u64;
    page_size: u32;
    pad:       u32;
    pages:     u64;
}

nvioctl_zbc_slot_mask :: struct {
    slot: u32; // always 0x07 (?)
    mask: u32;
}

nvioctl_gpu_time :: struct {
    timestamp: u64;
    reserved:  u64;
}

nvioctl_fence :: struct {
    id:    u32;
    value: u32;
}

nvioctl_gpfifo_entry :: struct {
    union {
        desc:   u64;
        desc32: [2] u32;
    }
}

nvioctl_cmdbuf :: struct {
    mem:    u32;
    offset: u32;
    words:  u32;
}

nvioctl_reloc :: struct {
    cmdbuf_mem:    u32;
    cmdbuf_offset: u32;
    target:        u32;
    target_offset: u32;
}

nvioctl_reloc_shift :: struct {
    shift: u32;
}

nvioctl_syncpt_incr :: struct {
    syncpt_id:    u32;
    syncpt_incrs: u32;
}

nvioctl_command_buffer_map :: struct {
    handle: u32;
    iova:   u32;
}

// Used with nvioctlNvmap_Param().
nvioctl_map_param :: enum u32 {
    Size      :: 1;
    Alignment :: 2;
    Base      :: 3;
    Heap      :: 4;
    Kind      :: 5;
}

// Used with nvioctlNvmap_Param().
NvMapParam :: nvioctl_map_param;

// Used with nvioctlChannel_AllocObjCtx().
nvioctl_channel_obj_classnum :: enum u32 {
    _2D           :: 36909;
    _3D           :: 45463;
    Compute       :: 45504;
    Kepler        :: 41280;
    DMA           :: 45237;
    ChannelGpfifo :: 45167;
}

// Used with nvioctlChannel_AllocObjCtx().
NvClassNumber :: nvioctl_channel_obj_classnum;

// Used with nvioctlChannel_SetPriority().
nvioctl_channel_priority :: enum u32 {
    Low    :: 50;
    Medium :: 100;
    High   :: 150;
}

// Used with nvioctlChannel_SetPriority().
NvChannelPriority :: nvioctl_channel_priority;

// Used with nvioctlChannel_ZCullBind().
NvZcullConfig :: enum u32 {
    Global              :: 0;
    NoCtxSwitch         :: 1;
    SeparateBuffer      :: 2;
    PartOfRegularBuffer :: 3;
}

// Used with nvioctlNvhostAsGpu_AllocSpace().
NvAllocSpaceFlags :: enum u32 {
    FixedOffset :: 1;
    Sparse      :: 2;
}

// Used with nvioctlNvhostAsGpu_MapBufferEx().
NvMapBufferFlags :: enum u32 {
    FixedOffset :: 1;
    IsCacheable :: 4;
    Modify      :: 256;
}

NvNotificationType :: enum u32 {
    FifoErrorIdleTimeout       :: 8;
    GrErrorSwNotify            :: 13;
    GrSemaphoreTimeout         :: 24;
    GrIllegalNotify            :: 25;
    FifoErrorMmuErrFlt         :: 31;
    PbdmaError                 :: 32;
    ResetChannelVerifError     :: 43;
    PbdmaPushbufferCrcMismatch :: 80;
}

NvNotification :: struct {
    timestamp: u64;
    info32:    u32; // see NvNotificationType
    info16:    u16;
    status:    u16; // always -1
}

NvError :: struct {
    type: u32;
    info: [31] u32;
}

nvioctlNvhostCtrl_SyncptRead :: (fd: u32, id: u32, out: *u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_SyncptIncr :: (fd: u32, id: u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_SyncptWait :: (fd: u32, id: u32, threshold: u32, timeout: u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_EventSignal :: (fd: u32, event_id: u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_EventWait :: (fd: u32, syncpt_id: u32, threshold: u32, timeout: s32, event_id: u32, out: *u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_EventWaitAsync :: (fd: u32, syncpt_id: u32, threshold: u32, timeout: s32, event_id: u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_EventRegister :: (fd: u32, event_id: u32) -> Result #foreign libnx;
nvioctlNvhostCtrl_EventUnregister :: (fd: u32, event_id: u32) -> Result #foreign libnx;

nvioctlNvhostCtrlGpu_ZCullGetCtxSize :: (fd: u32, out: *u32) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_ZCullGetInfo :: (fd: u32, out: *nvioctl_zcull_info) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_ZbcSetTable :: (fd: u32, color_ds: *[4] u32, color_l2: *[4] u32, depth: u32, format: u32, type: u32) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_ZbcQueryTable :: (fd: u32, index: u32, out: *nvioctl_zbc_entry) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_GetCharacteristics :: (fd: u32, out: *nvioctl_gpu_characteristics) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_GetTpcMasks :: (fd: u32, buffer: *void, size: u64) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_ZbcGetActiveSlotMask :: (fd: u32, out: *nvioctl_zbc_slot_mask) -> Result #foreign libnx;
nvioctlNvhostCtrlGpu_GetGpuTime :: (fd: u32, out: *nvioctl_gpu_time) -> Result #foreign libnx;

nvioctlNvhostAsGpu_BindChannel :: (fd: u32, channel_fd: u32) -> Result #foreign libnx;
nvioctlNvhostAsGpu_AllocSpace :: (fd: u32, pages: u32, page_size: u32, flags: u32, align_or_offset: u64, offset: *u64) -> Result #foreign libnx;
nvioctlNvhostAsGpu_FreeSpace :: (fd: u32, offset: u64, pages: u32, page_size: u32) -> Result #foreign libnx;
nvioctlNvhostAsGpu_MapBufferEx :: (fd: u32, flags: u32, kind: u32, nvmap_handle: u32, page_size: u32, buffer_offset: u64, mapping_size: u64, input_offset: u64, offset: *u64) -> Result #foreign libnx;
nvioctlNvhostAsGpu_UnmapBuffer :: (fd: u32, offset: u64) -> Result #foreign libnx;
nvioctlNvhostAsGpu_GetVARegions :: (fd: u32, regions: *[2] nvioctl_va_region) -> Result #foreign libnx;
nvioctlNvhostAsGpu_InitializeEx :: (fd: u32, flags: u32, big_page_size: u32) -> Result #foreign libnx;

nvioctlNvmap_Create :: (fd: u32, size: u32, nvmap_handle: *u32) -> Result #foreign libnx;
nvioctlNvmap_FromId :: (fd: u32, id: u32, nvmap_handle: *u32) -> Result #foreign libnx;
nvioctlNvmap_Alloc :: (fd: u32, nvmap_handle: u32, heapmask: u32, flags: u32, align: u32, kind: u8, addr: *void) -> Result #foreign libnx;
nvioctlNvmap_Free :: (fd: u32, nvmap_handle: u32) -> Result #foreign libnx;
nvioctlNvmap_Param :: (fd: u32, nvmap_handle: u32, param: NvMapParam, result: *u32) -> Result #foreign libnx;
nvioctlNvmap_GetId :: (fd: u32, nvmap_handle: u32, id: *u32) -> Result #foreign libnx;

nvioctlChannel_SetNvmapFd :: (fd: u32, nvmap_fd: u32) -> Result #foreign libnx;
nvioctlChannel_SubmitGpfifo :: (fd: u32, entries: *nvioctl_gpfifo_entry, num_entries: u32, flags: u32, fence_inout: *nvioctl_fence) -> Result #foreign libnx;
nvioctlChannel_KickoffPb :: (fd: u32, entries: *nvioctl_gpfifo_entry, num_entries: u32, flags: u32, fence_inout: *nvioctl_fence) -> Result #foreign libnx;
nvioctlChannel_AllocObjCtx :: (fd: u32, class_num: u32, flags: u32, id_out: *u64) -> Result #foreign libnx;
nvioctlChannel_ZCullBind :: (fd: u32, gpu_va: u64, mode: u32) -> Result #foreign libnx;
nvioctlChannel_SetErrorNotifier :: (fd: u32, enable: u32) -> Result #foreign libnx;
nvioctlChannel_GetErrorInfo :: (fd: u32, out: *NvError) -> Result #foreign libnx;
nvioctlChannel_GetErrorNotification :: (fd: u32, out: *NvNotification) -> Result #foreign libnx;
nvioctlChannel_SetPriority :: (fd: u32, priority: u32) -> Result #foreign libnx;
nvioctlChannel_SetTimeout :: (fd: u32, timeout: u32) -> Result #foreign libnx;
nvioctlChannel_AllocGpfifoEx2 :: (fd: u32, num_entries: u32, flags: u32, unk0: u32, unk1: u32, unk2: u32, unk3: u32, fence_out: *nvioctl_fence) -> Result #foreign libnx;
nvioctlChannel_SetUserData :: (fd: u32, addr: *void) -> Result #foreign libnx;
nvioctlChannel_Submit :: (fd: u32, cmdbufs: *nvioctl_cmdbuf, num_cmdbufs: u32, relocs: *nvioctl_reloc, reloc_shifts: *nvioctl_reloc_shift, num_relocs: u32, syncpt_incrs: *nvioctl_syncpt_incr, num_syncpt_incrs: u32, fences: *nvioctl_fence, num_fences: u32) -> Result #foreign libnx;

nvioctlChannel_GetSyncpt :: (fd: u32, module_id: u32, syncpt: *u32) -> Result #foreign libnx;
nvioctlChannel_GetModuleClockRate :: (fd: u32, module_id: u32, freq: *u32) -> Result #foreign libnx;
nvioctlChannel_MapCommandBuffer :: (fd: u32, maps: *nvioctl_command_buffer_map, num_maps: u32, compressed: bool) -> Result #foreign libnx;
nvioctlChannel_UnmapCommandBuffer :: (fd: u32, maps: *nvioctl_command_buffer_map, num_maps: u32, compressed: bool) -> Result #foreign libnx;

NvFence :: nvioctl_fence;

NvMultiFence :: struct {
    num_fences: u32;
    fences:     [4] NvFence;
}

nvFenceInit :: () -> Result #foreign libnx;
nvFenceExit :: () -> void #foreign libnx;

nvFenceWait :: (f: *NvFence, timeout_us: s32) -> Result #foreign libnx;

nvMultiFenceWait :: (mf: *NvMultiFence, timeout_us: s32) -> Result #foreign libnx;

BqRect :: struct {
    left:   s32;
    top:    s32;
    right:  s32;
    bottom: s32;
}

BqBufferInput :: struct {
    struct {
        timestamp: s64;
    }
    isAutoTimestamp: s32;
    crop:            BqRect;
    scalingMode:     s32;
    transform:       u32; // See the NATIVE_WINDOW_TRANSFORM_* enums.
    stickyTransform: u32;
    unk:             u32;
    swapInterval:    u32;
    fence:           NvMultiFence;
}

BqBufferOutput :: struct {
    width:             u32;
    height:            u32;
    transformHint:     u32;
    numPendingBuffers: u32;
}

BqGraphicBuffer :: struct {
    width:         u32;
    height:        u32;
    stride:        u32;
    format:        u32;
    usage:         u32;
    native_handle: *NativeHandle;
}

bqRequestBuffer :: (b: *Binder, bufferIdx: s32, buf: *BqGraphicBuffer) -> Result #foreign libnx;
bqDequeueBuffer :: (b: *Binder, async: bool, width: u32, height: u32, format: s32, usage: u32, buf: *s32, fence: *NvMultiFence) -> Result #foreign libnx;
bqDetachBuffer :: (b: *Binder, slot: s32) -> Result #foreign libnx;
bqQueueBuffer :: (b: *Binder, buf: s32, input: *BqBufferInput, output: *BqBufferOutput) -> Result #foreign libnx;
bqCancelBuffer :: (b: *Binder, buf: s32, fence: *NvMultiFence) -> Result #foreign libnx;
bqQuery :: (b: *Binder, what: s32, value: *s32) -> Result #foreign libnx;
bqConnect :: (b: *Binder, api: s32, producerControlledByApp: bool, output: *BqBufferOutput) -> Result #foreign libnx;
bqDisconnect :: (b: *Binder, api: s32) -> Result #foreign libnx;
bqSetPreallocatedBuffer :: (b: *Binder, buf: s32, input: *BqGraphicBuffer) -> Result #foreign libnx;

/// Native window structure.
NWindow :: struct {
    magic:                      u32;
    bq:                         Binder;
    event:                      Event;
    mutex:                      Mutex;
    slots_configured:           u64;
    slots_requested:            u64;
    cur_slot:                   s32;
    width:                      u32;
    height:                     u32;
    format:                     u32;
    usage:                      u32;
    crop:                       BqRect;
    scaling_mode:               u32;
    transform:                  u32;
    sticky_transform:           u32;
    default_width:              u32;
    default_height:             u32;
    swap_interval:              u32;
    is_connected:               bool;
    producer_controlled_by_app: bool;
    consumer_running_behind:    bool;
}

/// Checks whether a pointer refers to a valid \ref NWindow object.
nwindowIsValid :: (nw: *NWindow) -> bool #foreign libnx;

/**
* @brief Retrieves the default \ref NWindow object.
* @return Pointer to the default \ref NWindow object.
* @note When this function is used/referenced, libnx will initialize VI services
*       and create a \ref NWindow object from a \ref ViLayer created on the default \ref ViDisplay;
*       all of this happening automatically during application startup (i.e. before main is called).
*       If creating the default \ref NWindow fails, libnx will throw a LibnxError_BadGfxInit fatal error.
*       Likewise, after main returns (or exit is called) libnx will clean up all resources used by it.
*/
nwindowGetDefault :: () -> *NWindow #foreign libnx;

/**
* @brief Creates a \ref NWindow.
* @param[out] nw Output \ref NWindow structure.
* @param[in] binder_session Service object for the Android IGraphicBufferProducer binder session.
* @param[in] binder_id Android IGraphicBufferProducer binder session ID.
* @param[in] producer_controlled_by_app Specifies whether the producer is controlled by the application.
*/
nwindowCreate :: (nw: *NWindow, binder_session: *Service, binder_id: s32, producer_controlled_by_app: bool) -> Result #foreign libnx;

/**
* @brief Creates a \ref NWindow operating on a \ref ViLayer.
* @param[out] nw Output \ref NWindow structure.
* @param[in] layer Pointer to \ref ViLayer structure (such as the one returned by \ref viCreateLayer).
*/
nwindowCreateFromLayer :: (nw: *NWindow, layer: *ViLayer) -> Result #foreign libnx;

/// Closes a \ref NWindow, freeing all resources associated with it.
nwindowClose :: (nw: *NWindow) -> void #foreign libnx;

/**
* @brief Retrieves the dimensions of a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[out] out_width Output variable containing the width of the \ref NWindow.
* @param[out] out_height Output variable containing the height of the \ref NWindow.
* @note After creation, a \ref NWindow reports a default size (usually 1280x720).
*       This size can be overriden by calling \ref nwindowSetDimensions.
*/
nwindowGetDimensions :: (nw: *NWindow, out_width: *u32, out_height: *u32) -> Result #foreign libnx;

/**
* @brief Sets the dimensions of a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] width Desired width of the \ref NWindow.
* @param[in] height Desired width of the \ref NWindow.
* @note This function cannot be called when there are buffers registered with the \ref NWindow.
*/
nwindowSetDimensions :: (nw: *NWindow, width: u32, height: u32) -> Result #foreign libnx;

/**
* @brief Configures the crop applied to images presented through a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] left X coordinate of the left margin of the crop bounding box.
* @param[in] top Y coordinate of the top margin of the crop bounding box.
* @param[in] right X coordinate of the right margin of the crop bounding box.
* @param[in] bottom Y coordinate of the bottom margin of the crop bounding box.
* @note Passing zero to all parameters disables the crop functionality. This is also the default.
* @note The bounding box defined by the parameters will be adjusted to fit within the dimensions of the \ref NWindow.
* @note \p left must be less or equal than \p right.
* @note \p top must be less or equal than \p bottom.
*/
nwindowSetCrop :: (nw: *NWindow, left: s32, top: s32, right: s32, bottom: s32) -> Result #foreign libnx;

/**
* @brief Configures the transformation applied to images presented through a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] transform Android transformation mode (see NATIVE_WINDOW_TRANSFORM_* enum)
* @note The default transformation is 0 (i.e. no transformation applied)
*/
nwindowSetTransform :: (nw: *NWindow, transform: u32) -> Result #foreign libnx;

/**
* @brief Configures the swap interval of a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] swap_interval Value specifying the number of display refreshes (VBlanks) that must occur between presenting images.
* @note The default swap interval is 1.
* @note If the \ref NWindow has three or more buffers configured (with \ref nwindowConfigureBuffer), it is possible to pass 0
*       to disable the swap interval feature and present images as fast as allowed by the compositor. Otherwise, the system
*       enforces a minimum of 1 as the swap interval.
*/
nwindowSetSwapInterval :: (nw: *NWindow, swap_interval: u32) -> Result #foreign libnx;

/**
* @brief Registers a \ref NvGraphicBuffer with a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] slot ID of the slot to configure (starting from 0).
* @param[in] buf Pointer to \ref NvGraphicBuffer structure.
* @note When a buffer is registered, it is added to the internal queue of buffers used for presenting.
* @note All buffers registered with a \ref NWindow must have the same dimensions, format and usage.
*       If \ref nwindowSetDimensions has not been previously called, the \ref NWindow will automatically
*       adopt the dimensions of the first buffer registered with it. Otherwise, said buffer will need
*       to match the dimensions that were previously configured.
*/
nwindowConfigureBuffer :: (nw: *NWindow, slot: s32, buf: *NvGraphicBuffer) -> Result #foreign libnx;

/**
* @brief Dequeues a buffer from a \ref NWindow.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[out] out_slot Output variable containing the ID of the slot that has been dequeued.
* @param[out] out_fence Output variable containing a \ref NvMultiFence that will be signalled by
*             the compositor when the buffer is ready to be written to. Pass NULL to wait instead
*             on this fence before this function returns.
* @note For \p out_fence=NULL to work, \ref nvFenceInit must have been previously called.
*/
nwindowDequeueBuffer :: (nw: *NWindow, out_slot: *s32, out_fence: *NvMultiFence) -> Result #foreign libnx;

/**
* @brief Cancels a buffer previously dequeued with \ref nwindowDequeueBuffer.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] slot ID of the slot to cancel. This must match the output of the previous \ref nwindowDequeueBuffer call.
* @param[in] fence Pointer to the \ref NvMultiFence that will be waited on by the compositor before cancelling the buffer.
*                  Pass NULL if there is no such fence.
*/
nwindowCancelBuffer :: (nw: *NWindow, slot: s32, fence: *NvMultiFence) -> Result #foreign libnx;

/**
* @brief Queues a buffer previously dequeued with \ref nwindowDequeueBuffer, making it ready for presentation.
* @param[in] nw Pointer to \ref NWindow structure.
* @param[in] slot ID of the slot to queue. This must match the output of the previous \ref nwindowDequeueBuffer call.
* @param[in] fence Pointer to the \ref NvMultiFence that will be waited on by the compositor before queuing/presenting the buffer.
*                  Pass NULL if there is no such fence.
*/
nwindowQueueBuffer :: (nw: *NWindow, slot: s32, fence: *NvMultiFence) -> Result #foreign libnx;

/// Releases all buffers registered with a \ref NWindow.
nwindowReleaseBuffers :: (nw: *NWindow) -> Result #foreign libnx;

/// Stream type values for \ref grcdTransfer.
GrcStream :: enum u32 {
    Video :: 0;
    Audio :: 1;
}

/// GameMovieTrimmer
GrcGameMovieTrimmer :: struct {
    s:    Service; ///< IGameMovieTrimmer
    tmem: TransferMemory; ///< TransferMemory
}

/// IMovieMaker
GrcMovieMaker :: struct {
    a:               Service; ///< applet IMovieMaker
    s:               Service; ///< grc IMovieMaker
    video_proxy:     Service; ///< IHOSBinderDriver VideoProxy
    recording_event: Event; ///< Output Event from GetOffscreenLayerRecordingFinishReadyEvent with autoclear=false.
    audio_event:     Event; ///< Output Event from GetOffscreenLayerAudioEncodeReadyEvent with autoclear=false.
    tmem:            TransferMemory; ///< TransferMemory
    win:             NWindow; ///< \ref NWindow
    layer_handle:    u64; ///< LayerHandle
    layer_open:      bool; ///< Whether OpenOffscreenLayer was used successfully, indicating that CloseOffscreenLayer should be used during \ref grcMovieMakerClose.
    started_flag:    bool; ///< Whether \ref grcMovieMakerStart was used successfully. This is also used by \ref grcMovieMakerAbort.
}

/// GameMovieId
GrcGameMovieId :: struct {
    file_id:  CapsAlbumFileId; ///< \ref CapsAlbumFileId
    reserved: [40] u8; ///< Unused, always zero.
}

/// OffscreenRecordingParameter
GrcOffscreenRecordingParameter :: struct {
    unk_x0:                 [16] u8; ///< Unknown. Default value is 0.
    unk_x10:                u32; ///< Unknown. Must match value 0x103, which is the default value.

    video_bitrate:          s32; ///< VideoBitRate, 0 is invalid. Default value is 8000000.
    video_width:            s32; ///< VideoWidth, must match 1280 or 1920. Default value is 1280.
    video_height:           s32; ///< VideoHeight, must match 720 or 1080. Default value is 720.
    video_framerate:        s32; ///< VideoFrameRate, must match 30 or 60. Default value is 30.
    video_keyFrameInterval: s32; ///< VideoKeyFrameInterval, 0 is invalid. Default value is 30.

    audio_bitrate:          s32; ///< AudioBitRate. Default value is 128000 ([5.0.0-5.1.0] 1536000).
    audio_samplerate:       s32; ///< AudioSampleRate, 0 is invalid. Default value is 48000.
    audio_channel_count:    s32; ///< AudioChannelCount. Must match 2, which is the default value.
    audio_sample_format:    s32; ///< \ref PcmFormat AudioSampleFormat. Must match PcmFormat_Int16, which is the default value.

    video_imageOrientation: s32; ///< \ref AlbumImageOrientation VideoImageOrientation. Default value is ::AlbumImageOrientation_Unknown0.

    unk_x3c:                [68] u8; ///< Unknown. Default value is 0.
}

/**
* @brief Creates a \ref GrcGameMovieTrimmer using \ref appletCreateGameMovieTrimmer, uses the cmds from it to trim the specified video, then closes it.
* @note See \ref appletCreateGameMovieTrimmer for the requirements for using this.
* @note This will block until video trimming finishes.
* @param[out] dst_movieid \ref GrcGameMovieId for the output video.
* @param[in] src_movieid \ref GrcGameMovieId for the input video.
* @param[in] tmem_size TransferMemory size. Official sw uses size 0x2000000.
* @param[in] thumbnail Optional, can be NULL. RGBA8 1280x720 thumbnail image data.
* @param[in] start Start timestamp in 0.5s units.
* @param[in] end End timestamp in 0.5s units.
*/
grcTrimGameMovie :: (dst_movieid: *GrcGameMovieId, src_movieid: *GrcGameMovieId, tmem_size: u64, thumbnail: *void, start: s32, end: s32) -> Result #foreign libnx;

/**
* @brief Creates a \ref GrcOffscreenRecordingParameter with the default values, see \ref GrcOffscreenRecordingParameter for the default values.
* @param[out] param \ref GrcOffscreenRecordingParameter
*/
grcCreateOffscreenRecordingParameter :: (param: *GrcOffscreenRecordingParameter) -> void #foreign libnx;

/**
* @brief Creates a \ref GrcMovieMaker using \ref appletCreateMovieMaker, and does the required initialization.
* @note See \ref appletCreateMovieMaker for the requirements for using this.
* @param[out] m \ref GrcMovieMaker
* @param[in] size TransferMemory WorkMemory size. See \ref GRC_MOVIEMAKER_WORKMEMORY_SIZE_DEFAULT.
*/
grcCreateMovieMaker :: (m: *GrcMovieMaker, size: u64) -> Result #foreign libnx;

/**
* @brief Closes a \ref GrcMovieMaker.
* @note This also uses \ref grcMovieMakerAbort.
* @param m \ref GrcMovieMaker
*/
grcMovieMakerClose :: (m: *GrcMovieMaker) -> void #foreign libnx;

/**
* @brief Aborts recording with the specified MovieMaker.
* @note This is used automatically by \ref grcMovieMakerClose.
* @note This will throw an error if \ref grcMovieMakerStart was not used previously, with the flag used for this being cleared afterwards on success.
* @param m \ref GrcMovieMaker
*/
grcMovieMakerAbort :: (m: *GrcMovieMaker) -> Result #foreign libnx;

/**
* @brief Starts recording with the specified MovieMaker and \ref GrcOffscreenRecordingParameter.
* @param m \ref GrcMovieMaker
* @param[in] param \ref GrcOffscreenRecordingParameter
*/
grcMovieMakerStart :: (m: *GrcMovieMaker, param: *GrcOffscreenRecordingParameter) -> Result #foreign libnx;

/**
* @brief Finishes recording with the specified MovieMaker.
* @note This automatically uses \ref grcMovieMakerAbort on error.
* @note The recorded video will not be accessible via the Album-applet since it's stored separately from other Album data.
* @param m \ref GrcMovieMaker
* @param width Width for the thumbnail, must be 1280.
* @param height Height for the thumbnail, must be 720.
* @param[in] userdata UserData input buffer for the JPEG thumbnail. Optional, can be NULL.
* @param[in] userdata_size Size of the UserData input buffer. Optional, can be 0. Must be <=0x400.
* @param[in] thumbnail RGBA8 image buffer containing the thumbnail. Optional, can be NULL.
* @param[in] thumbnail_size Size of the thumbnail buffer. Optional, can be 0.
* @param[out] entry Output \ref CapsApplicationAlbumEntry for the recorded video. Optional, can be NULL. Only available on [7.0.0+], if this is not NULL on pre-7.0.0 an error is thrown.
*/
grcMovieMakerFinish :: (m: *GrcMovieMaker, width: s32, height: s32, userdata: *void, userdata_size: u64, thumbnail: *void, thumbnail_size: u64, entry: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Gets the recording error with the specified MovieMaker.
* @param m \ref GrcMovieMaker
*/
grcMovieMakerGetError :: (m: *GrcMovieMaker) -> Result #foreign libnx;

/**
* @brief Encodes audio sample data with the specified MovieMaker.
* @note This waits on the event and uses the cmd repeatedly until the entire input buffer is handled.
* @note If you don't use this the recorded video will be missing audio.
* @param m \ref GrcMovieMaker
* @param[in] buffer Audio buffer.
* @param[in] size Size of the buffer.
*/
grcMovieMakerEncodeAudioSample :: (m: *GrcMovieMaker, buffer: *void, size: u64) -> Result #foreign libnx;

/// Initialize grc:d.
grcdInitialize :: () -> Result #foreign libnx;

/// Exit grc:d.
grcdExit :: () -> void #foreign libnx;

/// Gets the Service for grc:d.
grcdGetServiceSession :: () -> *Service #foreign libnx;

/// Begins streaming. This must not be called more than once, even from a different service session: otherwise the sysmodule will assert.
grcdBegin :: () -> Result #foreign libnx;

/**
* @brief Retrieves stream data from the continuous recorder in use (from the video recording of the currently running application).
* @note This will block until data is available. This will hang if there is no application running which has video capture enabled.
* @param[in] stream \ref GrcStream
* @param[out] buffer Output buffer.
* @param[in] size Max size of the output buffer.
* @param[out] num_frames num_frames
* @param[out] data_size Actual output data size.
* @param[out] start_timestamp Start timestamp.
*/
grcdTransfer :: (stream: GrcStream, buffer: *void, size: u64, num_frames: *u32, data_size: *u32, start_timestamp: *u64) -> Result #foreign libnx;

FriendsServiceType :: enum u32 {
    User          :: 0;
    Viewer        :: 1;
    Manager       :: 2;
    System        :: 3;
    Administrator :: 4;
}

/// InAppScreenName
FriendsInAppScreenName :: struct {
    name:         [64] u8; ///< UTF-8 string, NUL-terminated.
    languageCode: u64; ///< LanguageCode, see set.h.
}

/// FriendInvitationGameModeDescription
FriendsFriendInvitationGameModeDescription :: struct {
    unk_x0: [3072] u8; ///< Unknown.
}

/// FriendInvitationId
FriendsFriendInvitationId :: struct {
    id: u64; ///< Id.
}

/// FriendInvitationGroupId
FriendsFriendInvitationGroupId :: struct {
    id: u64; ///< Id.
}

/// FriendsUserSetting
FriendsUserSetting :: struct {
    uid:                            AccountUid; ///< User ID
    presence_permission:            u32; ///< Presence permission
    play_log_permission:            u32; ///< Play log permission
    friend_request_reception:       u64; ///< Unknown
    friend_code:                    [32] u8; ///< Friend Code
    friend_code_next_issuable_time: u64; ///< Unknown
    unk_x48:                        [1992] u8; ///< Unknown
}

/// Initialize friends
friendsInitialize :: (service_type: FriendsServiceType) -> Result #foreign libnx;

/// Exit friends
friendsExit :: () -> void #foreign libnx;

/// Gets the Service object for the friends service session.
friendsGetServiceSession :: () -> *Service #foreign libnx;

/// Gets the Service object for the actual IFriendsService service session.
friendsGetServiceSession_IFriendsService :: () -> *Service #foreign libnx;

/**
* @brief Gets the \ref FriendsUserSetting details
* @param[in] uid \ref User AccountUid.
* @param[out] user_setting \ref FriendsUserSetting
*/
friendsGetUserSetting :: (uid: AccountUid, user_setting: *FriendsUserSetting) -> Result #foreign libnx;

/**
* @brief Uses \ref appletTryPopFromFriendInvitationStorageChannel then reads the data from there into the output params.
* @note This is a wrapper for \ref appletTryPopFromFriendInvitationStorageChannel, see that for the usage requirements.
* @param[out] uid \ref AccountUid. Optional, can be NULL.
* @param[out] buffer Output buffer.
* @param[out] size Output buffer size.
* @param[out] out_size Size of the data which was written into the output buffer. Optional, can be NULL.
*/
friendsTryPopFriendInvitationNotificationInfo :: (uid: *AccountUid, buffer: *void, size: u64, out_size: *u64) -> Result #foreign libnx;

/// ServiceType for \ref notifInitialize.
NotifServiceType :: enum u32 {
    Application :: 0;
    System      :: 1;
}

/// Data extracted from NotifWeeklyScheduleAlarmSetting::settings. This uses local-time.
NotifAlarmTime :: struct {
    hour:   s32; ///< Hour.
    minute: s32; ///< Minute.
}

/// WeeklyScheduleAlarmSetting
NotifWeeklyScheduleAlarmSetting :: struct {
    unk_x0:   [10] u8; ///< Unknown.
    settings: [7] s16; ///< Schedule settings for each day of the week, Sun-Sat. High byte is the hour, low byte is the minute. This uses local-time.
}

/// AlarmSetting
NotifAlarmSetting :: struct {
    alarm_setting_id: u16; ///< AlarmSettingId
    kind:             u8; ///< Kind: 0 = WeeklySchedule.
    muted:            u8; ///< u8 bool flag for whether this AlarmSetting is muted (non-zero = AlarmSetting turned off, zero = on).
    pad:              [4] u8; ///< Padding.
    uid:              AccountUid; ///< \ref AccountUid. User account associated with this AlarmSetting. Used for the preselected_user (\ref accountGetPreselectedUser) when launching the Application when the system was previously in sleep-mode, instead of launching the applet for selecting the user.
    application_id:   u64; ///< ApplicationId
    unk_x20:          u64; ///< Unknown.
    schedule:         NotifWeeklyScheduleAlarmSetting; ///< \ref NotifWeeklyScheduleAlarmSetting
}

/// Initialize notif. Only available on [9.0.0+].
notifInitialize :: (service_type: NotifServiceType) -> Result #foreign libnx;

/// Exit notif.
notifExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual notif:* service session.
notifGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Creates a \ref NotifAlarmSetting.
* @note This clears the struct, with all schedule settings set the same as \ref notifAlarmSettingDisable.
* @param[out] alarm_setting \ref NotifAlarmSetting
*/
notifAlarmSettingCreate :: (alarm_setting: *NotifAlarmSetting) -> void #foreign libnx;

/**
* @brief Gets whether the schedule setting for the specified day_of_week is enabled, for the \ref NotifAlarmSetting.
* @param alarm_setting \ref NotifAlarmSetting
* @param[in] day_of_week Day-of-week, must be 0-6 (Sun-Sat).
* @param[out] out Whether the setting is enabled.
*/
notifAlarmSettingIsEnabled :: (alarm_setting: *NotifAlarmSetting, day_of_week: u32, out: *bool) -> Result #foreign libnx;

/**
* @brief Gets the schedule setting for the specified day_of_week, for the \ref NotifAlarmSetting.
* @note Should not be used if the output from \ref notifAlarmSettingIsEnabled is false.
* @param alarm_setting \ref NotifAlarmSetting
* @param[in] day_of_week Day-of-week, must be 0-6 (Sun-Sat).
* @param[out] out \ref NotifAlarmTime
*/
notifAlarmSettingGet :: (alarm_setting: *NotifAlarmSetting, day_of_week: u32, out: *NotifAlarmTime) -> Result #foreign libnx;

/**
* @brief Enables the schedule setting for the specified day_of_week, for the \ref NotifAlarmSetting. This uses local-time.
* @param alarm_setting \ref NotifAlarmSetting
* @param[in] day_of_week Day-of-week, must be 0-6 (Sun-Sat).
* @param[in] hour Hour.
* @param[in] minute Minute.
*/
notifAlarmSettingEnable :: (alarm_setting: *NotifAlarmSetting, day_of_week: u32, hour: s32, minute: s32) -> Result #foreign libnx;

/**
* @brief Disables the schedule setting for the specified day_of_week, for the \ref NotifAlarmSetting.
* @note Schedule settings are disabled by default (\ref notifAlarmSettingCreate).
* @param alarm_setting \ref NotifAlarmSetting
* @param[in] day_of_week Day-of-week, must be 0-6 (Sun-Sat).
*/
notifAlarmSettingDisable :: (alarm_setting: *NotifAlarmSetting, day_of_week: u32) -> Result #foreign libnx;

/**
* @brief Registers the specified AlarmSetting.
* @note See \ref NOTIF_MAX_ALARMS for the maximum alarms.
* @note When indicated by the output from \ref hidIsFirmwareUpdateNeededForNotification, this will use \ref hidLaShowControllerFirmwareUpdate.
* @param[out] alarm_setting_id AlarmSettingId
* @param[in] alarm_setting \ref NotifAlarmSetting
* @param[in] buffer Input buffer containing the ApplicationParameter. Optional, can be NULL.
* @param[in] size Input buffer size, must be <=0x400. Optional, can be 0.
*/
notifRegisterAlarmSetting :: (alarm_setting_id: *u16, alarm_setting: *NotifAlarmSetting, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Updates the specified AlarmSetting.
* @param[in] alarm_setting \ref NotifAlarmSetting
* @param[in] buffer Input buffer containing the ApplicationParameter. Optional, can be NULL.
* @param[in] size Input buffer size, must be <=0x400. Optional, can be 0.
*/
notifUpdateAlarmSetting :: (alarm_setting: *NotifAlarmSetting, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Gets a listing of AlarmSettings.
* @param[out] alarm_settings Output \ref NotifAlarmSetting array.
* @param[in] count Total entries in the alarm_settings array.
* @param[out] total_out Total output entries.
*/
notifListAlarmSettings :: (alarm_settings: *NotifAlarmSetting, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Loads the ApplicationParameter for the specified AlarmSetting.
* @param[in] alarm_setting_id AlarmSettingId
* @param[out] buffer Output buffer containing the ApplicationParameter.
* @param[in] size Output buffer size.
* @param[out] actual_size Actual output size.
*/
notifLoadApplicationParameter :: (alarm_setting_id: u16, buffer: *void, size: u64, actual_size: *u32) -> Result #foreign libnx;

/**
* @brief Deletes the specified AlarmSetting.
* @param[in] alarm_setting_id AlarmSettingId
*/
notifDeleteAlarmSetting :: (alarm_setting_id: u16) -> Result #foreign libnx;

/**
* @brief Uses \ref appletTryPopFromNotificationStorageChannel then reads the data from there into the output params.
* @note This is a wrapper for \ref appletTryPopFromNotificationStorageChannel, see that for the usage requirements.
* @note The system will only push data for this when launching the Application when the Alarm was triggered, where the system was previously in sleep-mode.
* @note Some official apps don't use this.
* @param[out] buffer Output buffer.
* @param[out] size Output buffer size.
* @param[out] out_size Size of the data which was written into the output buffer. Optional, can be NULL.
*/
notifTryPopNotifiedApplicationParameter :: (buffer: *void, size: u64, out_size: *u64) -> Result #foreign libnx;

/// Image ID.
MiiimgImageId :: struct {
    uuid: Uuid;
}

/// Image attribute.
MiiimgImageAttribute :: struct {
    image_id:  MiiimgImageId; ///< Image ID.
    create_id: MiiCreateId; ///< Mii's create ID.
    unk:       u32;
    mii_name:  [11] u16; ///< utf-16be, null-terminated
}

/// Initialize miiimg.
miiimgInitialize :: () -> Result #foreign libnx;

/// Exit miiimg.
miiimgExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual miiimg service session.
miiimgGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Reloads the image database.
*/
miiimgReload :: () -> Result #foreign libnx;

/**
* @brief Gets the number of mii images in the database.
* @param[out] out_count Mii image count.
*/
miiimgGetCount :: (out_count: *s32) -> Result #foreign libnx;

/**
* @brief Gets whether the image database is empty.
* @param[out] out_empty Whether the database is empty.
*/
miiimgIsEmpty :: (out_empty: *bool) -> Result #foreign libnx;

/**
* @brief Gets whether the image database is full.
* @param[out] out_empty Whether the database is full.
*/
miiimgIsFull :: (out_full: *bool) -> Result #foreign libnx;

/**
* @brief Gets the image attribute for the specified image index.
* @param[in] index Image index.
* @param[out] out_attr Out image attribute.
*/
miiimgGetAttribute :: (index: s32, out_attr: *MiiimgImageAttribute) -> Result #foreign libnx;

/**
* @brief Loads the image data (raw RGBA8) for the specified image ID.
* @note Server doesn't seem to check the image buffer size, but 0x40000 is the optimal size.
* @param[in] id Input image ID.
* @param[out] out_image Out iamge buffer.
* @param[in] out_image_size Out image buffer size.
*/
miiimgLoadImage :: (id: MiiimgImageId, out_image: *void, out_image_size: u64) -> Result #foreign libnx;

LdnServiceType :: enum u32 {
    User   :: 0;
    System :: 1;
}

/// State loaded by \ref ldnmGetStateForMonitor / \ref ldnGetState.
LdnState :: enum u32 {
    None               :: 0;
    Initialized        :: 1;
    AccessPointOpened  :: 2;
    AccessPointCreated :: 3;
    StationOpened      :: 4;
    StationConnected   :: 5;
    Error              :: 6;
}

/// DisconnectReason loaded by \ref ldnGetDisconnectReason.
LdnDisconnectReason :: enum u32 {
    None                     :: 0;
    User                     :: 1;
    SystemRequest            :: 2;
    DestroyedByAdmin         :: 3;
    DestroyedBySystemRequest :: 4;
    Admin                    :: 5;
    SignalLost               :: 6;
}

/// ScanFilterFlags
LdnScanFilterFlags :: enum u32 {
    LocalCommunicationId :: 1;
    NetworkId            :: 2;
    Unknown2             :: 4;
    MacAddr              :: 8;
    Ssid                 :: 16;
    UserData             :: 32;
}

/// AcceptPolicy
LdnAcceptPolicy :: enum u32 {
    AllowAll  :: 0;
    DenyAll   :: 1;
    Blacklist :: 2;
    Whitelist :: 3;
}

/// OperationMode
LdnOperationMode :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
}

/// WirelessControllerRestriction
LdnWirelessControllerRestriction :: enum u32 {
    Unknown0 :: 0;
    Unknown1 :: 1;
}

/// Ipv4Address. This is essentially the same as struct in_addr - hence this can be used with standard sockets (byteswap required).
LdnIpv4Address :: struct {
    addr: u32; ///< Address
}

/// SubnetMask. This is essentially the same as struct in_addr - hence this can be used with standard sockets (byteswap required).
LdnSubnetMask :: struct {
    mask: u32; ///< Mask
}

/// MacAddress
LdnMacAddress :: struct {
    addr: [6] u8; ///< Address
}

/// Ssid
LdnSsid :: struct {
    len: u8; ///< Length excluding NUL-terminator, must be 0x1-0x20.
    str: [33] u8; ///< SSID string including NUL-terminator, str[len_field] must be 0. The chars in this string must be be in the range of 0x20-0x7F, for when the Ssid is converted to a string (otherwise the byte written to the string will be 0).
}

/// NodeLatestUpdate
LdnNodeLatestUpdate :: struct {
    val:      u8; ///< The field in state is reset to zero by \ref ldnGetNetworkInfoLatestUpdate after loading it.
    reserved: [7] u8; ///< Not initialized with \ref ldnGetNetworkInfoLatestUpdate.
}

/// AddressEntry
LdnAddressEntry :: struct {
    ip_addr:  LdnIpv4Address; ///< \ref LdnIpv4Address
    mac_addr: LdnMacAddress; ///< \ref LdnMacAddress
    pad:      [2] u8; ///< Padding
}

/// NodeInfo
LdnNodeInfo :: struct {
    ip_addr:                     LdnIpv4Address; ///< \ref LdnIpv4Address
    mac_addr:                    LdnMacAddress; ///< \ref LdnMacAddress
    id:                          s8; ///< ID / index
    is_connected:                u8; ///< IsConnected flag
    nickname:                    [32] u8; ///< LdnUserConfig::nickname
    reserved_x2C:                [2] u8; ///< Reserved
    local_communication_version: s16; ///< LocalCommunicationVersion
    reserved_x30:                [16] u8; ///< Reserved
}

/// UserConfig. The input struct is copied to a tmp struct, which is then used with the cmd.
LdnUserConfig :: struct {
    nickname: [32] u8; ///< NUL-terminated string for the user nickname.
    reserved: [16] u8; ///< Cleared to zero for the tmp struct.
}

/// NetworkInfo
LdnNetworkInfo :: struct {
    local_communication_id: u64; ///< LocalCommunicationId
    reserved_x8:            [2] u8; ///< Reserved
    userdata_filter:        u16; ///< Arbitrary user data which can be used for filtering with \ref LdnScanFilter.
    reserved_xC:            [4] u8; ///< Reserved
    network_id:             [16] u8; ///< LdnSecurityParameter::network_id. NetworkId which is used to generate/overwrite the ssid. With \ref ldnScan / \ref ldnScanPrivate, this is only done after filtering when unk_x4B is value 0x2.
    mac_addr:               LdnMacAddress; ///< \ref LdnMacAddress
    ssid:                   LdnSsid; ///< \ref LdnSsid
    network_channel:        s16; ///< NetworkChannel
    link_level:             s8; ///< LinkLevel
    unk_x4B:                u8; ///< Unknown. Set to hard-coded value 0x2 with output structs, except with \ref ldnScan / \ref ldnScanPrivate which can also set value 0x1 in certain cases.
    pad_x4C:                [4] u8; ///< Padding
    sec_param_data:         [16] u8; ///< LdnSecurityParameter::data
    sec_type:               u16; ///< LdnSecurityConfig::type
    accept_policy:          u8; ///< \ref LdnAcceptPolicy
    unk_x63:                u8; ///< Only set with \ref ldnScan / \ref ldnScanPrivate, when unk_x4B is value 0x2.
    pad_x64:                [2] u8; ///< Padding
    participant_max:        s8; ///< Maximum participants, for nodes.
    participant_num:        u8; ///< ParticipantNum, number of set entries in nodes. If unk_x4B is not 0x2, ParticipantNum should be handled as if it's 0.
    nodes:                  [8] LdnNodeInfo; ///< Array of \ref LdnNodeInfo, starting with the AccessPoint node.
    reserved_x268:          [2] u8; ///< Reserved
    advertise_data_size:    u16; ///< AdvertiseData size (\ref ldnSetAdvertiseData)
    advertise_data:         [384] u8; ///< AdvertiseData (\ref ldnSetAdvertiseData)
    reserved_x3EC:          [140] u8; ///< Reserved
    auth_id:                u64; ///< Random AuthenticationId.
}

/// ScanFilter. The input struct is copied to a tmp struct, which is then used with the cmd (\ref ldnScan and \ref ldnScanPrivate).
LdnScanFilter :: struct {
    local_communication_id: s64; ///< See ::LdnScanFilterFlags_LocalCommunicationId. When enabled, this will be overwritten if it's -1 (written data is from the user-process control.nacp, with value 0 used instead if loading fails). During filtering if enabled, LdnNetworkInfo::unk_x4B must match 0x2, and this ScanFilter field must match LdnNetworkInfo::local_communication_id.
    pad_x8:                 [2] u8; ///< Padding
    userdata_filter:        u16; ///< See ::LdnScanFilterFlags_UserData. During filtering if enabled, LdnNetworkInfo::unk_x4B must match 0x2, and this ScanFilter field must match LdnNetworkInfo::userdata_filter.
    pad_xC:                 [4] u8; ///< Padding
    network_id:             [16] u8; ///< See ::LdnScanFilterFlags_NetworkId. During filtering if enabled, LdnNetworkInfo::unk_x4B must match 0x2, and this ScanFilter data must match LdnNetworkInfo::network_id.
    unk_x20:                u32; ///< See ::LdnScanFilterFlags_Unknown2. When enabled, this must be <=0x3, and during filtering must match LdnNetworkInfo::unk_x4B.
    mac_addr:               LdnMacAddress; ///< \ref LdnMacAddress (::LdnScanFilterFlags_MacAddr, during filtering if enabled this must match LdnNetworkInfo::mac_addr)
    ssid:                   LdnSsid; ///< \ref LdnSsid (::LdnScanFilterFlags_Ssid, during filtering if enabled this must match LdnNetworkInfo::ssid)
    reserved:               [16] u8; ///< Cleared to zero for the tmp struct.
    flags:                  u32; ///< Bitmask for \ref LdnScanFilterFlags. Masked with value 0x37 for \ref ldnScan, with \ref ldnScanPrivate this is masked with 0x3F.
}

/// SecurityConfig
LdnSecurityConfig :: struct {
    type:      u16; ///< Type, a default of value 0x1 can be used here. Overwritten by \ref ldnCreateNetwork, \ref ldnCreateNetworkPrivate, \ref ldnConnect, \ref ldnConnectPrivate.
    data_size: u16; ///< Data size. Must be 0x10-0x40.
    data:      [64] u8; ///< Data, used with key derivation.
}

/// SecurityParameter. The struct used by \ref ldnCreateNetwork internally is randomly-generated.
LdnSecurityParameter :: struct {
    data:       [16] u8; ///< Data, used with the same key derivation as \ref LdnSecurityConfig.
    network_id: [16] u8; ///< LdnNetworkInfo::network_id
}

/// NetworkConfig. The input struct is copied to a tmp struct, which is then used with the cmd (\ref ldnCreateNetwork, \ref ldnCreateNetworkPrivate, \ref ldnConnectPrivate).
LdnNetworkConfig :: struct {
    local_communication_id:      s64; ///< LdnNetworkInfo::local_communication_id. \ref ldnCreateNetwork, \ref ldnCreateNetworkPrivate, \ref ldnConnect, \ref ldnConnectPrivate: When -1, this is overwritten with the first LocalCommunicationId from the user-process control.nacp, if loading fails value 0 is written instead. Otherwise when not -1, if control.nacp loading is successful, this field must match one of the LocalCommunicationIds from there.
    reserved_x8:                 [2] u8; ///< Cleared to zero for the tmp struct.
    userdata_filter:             u16; ///< LdnNetworkInfo::userdata_filter
    reserved_xC:                 [4] u8; ///< Cleared to zero for the tmp struct.
    network_channel:             s16; ///< LdnNetworkInfo::network_channel. Channel, can be zero. Overwritten internally by \ref ldnCreateNetwork.
    participant_max:             s8; ///< LdnNetworkInfo::participant_max. \ref ldnCreateNetwork / \ref ldnCreateNetworkPrivate: Must be 0x1-0x8.
    reserved_x13:                u8; ///< Cleared to zero for the tmp struct.
    local_communication_version: s16; ///< LdnNodeInfo::local_communication_version, for the first entry in LdnNetworkInfo::nodes. Must not be negative.
    reserved_x16:                [10] u8; ///< Cleared to zero for the tmp struct.
}

/// Initialize ldn:m.
ldnmInitialize :: () -> Result #foreign libnx;

/// Exit ldn:m.
ldnmExit :: () -> void #foreign libnx;

/// Gets the Service object for IMonitorService.
ldnmGetServiceSession_MonitorService :: () -> *Service #foreign libnx;

/**
* @brief GetStateForMonitor
* @param[out] out \ref LdnState
*/
ldnmGetStateForMonitor :: (out: *LdnState) -> Result #foreign libnx;

/**
* @brief GetNetworkInfoForMonitor
* @param[out] out \ref LdnNetworkInfo
*/
ldnmGetNetworkInfoForMonitor :: (out: *LdnNetworkInfo) -> Result #foreign libnx;

/**
* @brief GetIpv4AddressForMonitor
* @param[out] addr \ref LdnIpv4Address
* @param[out] mask \ref LdnSubnetMask
*/
ldnmGetIpv4AddressForMonitor :: (addr: *LdnIpv4Address, mask: *LdnSubnetMask) -> Result #foreign libnx;

/**
* @brief GetSecurityParameterForMonitor
* @note Not exposed by official sw.
* @param[out] out \ref LdnSecurityParameter
*/
ldnmGetSecurityParameterForMonitor :: (out: *LdnSecurityParameter) -> Result #foreign libnx;

/**
* @brief GetNetworkConfigForMonitor
* @note Not exposed by official sw.
* @param[out] out \ref LdnNetworkConfig
*/
ldnmGetNetworkConfigForMonitor :: (out: *LdnNetworkConfig) -> Result #foreign libnx;

/// Initialize ldn.
ldnInitialize :: (service_type: LdnServiceType) -> Result #foreign libnx;

/// Exit ldn.
ldnExit :: () -> void #foreign libnx;

/// Gets the Service object for IUserLocalCommunicationService/ISystemLocalCommunicationService.
ldnGetServiceSession_LocalCommunicationService :: () -> *Service #foreign libnx;

/**
* @brief GetState
* @param[out] out \ref LdnState
*/
ldnGetState :: (out: *LdnState) -> Result #foreign libnx;

/**
* @brief GetNetworkInfo
* @param[out] out \ref LdnNetworkInfo
*/
ldnGetNetworkInfo :: (out: *LdnNetworkInfo) -> Result #foreign libnx;

/**
* @brief GetIpv4Address
* @param[out] addr \ref LdnIpv4Address
* @param[out] mask \ref LdnSubnetMask
*/
ldnGetIpv4Address :: (addr: *LdnIpv4Address, mask: *LdnSubnetMask) -> Result #foreign libnx;

/**
* @brief GetDisconnectReason
* @param[out] out \ref LdnDisconnectReason
*/
ldnGetDisconnectReason :: (out: *LdnDisconnectReason) -> Result #foreign libnx;

/**
* @brief GetSecurityParameter
* @param[out] out \ref LdnSecurityParameter
*/
ldnGetSecurityParameter :: (out: *LdnSecurityParameter) -> Result #foreign libnx;

/**
* @brief GetNetworkConfig
* @param[out] out \ref LdnNetworkConfig
*/
ldnGetNetworkConfig :: (out: *LdnNetworkConfig) -> Result #foreign libnx;

/**
* @brief AttachStateChangeEvent
* @note The Event must be closed by the user once finished with it.
* @note This is signaled when the data returned by \ref ldnGetNetworkInfo / \ref ldnGetNetworkInfoLatestUpdate is updated.
* @param[out] out_event Output Event with autoclear=true.
*/
ldnAttachStateChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetNetworkInfoLatestUpdate
* @param[out] network_info \ref LdnNetworkInfo
* @param[out] nodes Output array of \ref LdnNodeLatestUpdate.
* @param[in] count Size of the nodes array in entries, must be 8.
*/
ldnGetNetworkInfoLatestUpdate :: (network_info: *LdnNetworkInfo, nodes: *LdnNodeLatestUpdate, count: s32) -> Result #foreign libnx;

/**
* @brief Scan
* @note \ref LdnState must be ::LdnState_AccessPointCreated, ::LdnState_StationOpened, or ::LdnState_StationConnected.
* @note This is the same as \ref ldnScanPrivate (minus the masking for LdnScanFilter::flags), except this has the same channel-override functionality as \ref ldnCreateNetwork.
* @param[in] channel Channel, value 0 can be used for this.
* @param[in] filter \ref LdnScanFilter
* @param[out] network_info Output array of \ref LdnNetworkInfo.
* @param[in] count Size of the network_info array in entries. Must be at least 1, this is clamped to a maximum of 0x18 internally.
* @param[out] total_out Total output entries.
*/
ldnScan :: (channel: s32, filter: *LdnScanFilter, network_info: *LdnNetworkInfo, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief ScanPrivate
* @note \ref LdnState must be ::LdnState_AccessPointCreated, ::LdnState_StationOpened, or ::LdnState_StationConnected.
* @note See \ref ldnScan.
* @param[in] channel Channel, value 0 can be used for this.
* @param[in] filter \ref LdnScanFilter
* @param[out] network_info Output array of \ref LdnNetworkInfo.
* @param[in] count Size of the network_info array in entries. Must be at least 1, this is clamped to a maximum of 0x18 internally.
* @param[out] total_out Total output entries.
*/
ldnScanPrivate :: (channel: s32, filter: *LdnScanFilter, network_info: *LdnNetworkInfo, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief SetWirelessControllerRestriction
* @note Only available on [5.0.0+].
* @note \ref LdnState must be ::LdnState_Initialized.
* @param[in] restriction \ref LdnWirelessControllerRestriction
*/
ldnSetWirelessControllerRestriction :: (restriction: LdnWirelessControllerRestriction) -> Result #foreign libnx;

/**
* @brief OpenAccessPoint
* @note \ref LdnState must be ::LdnState_Initialized, this eventually sets the State to ::LdnState_AccessPointOpened.
*/
ldnOpenAccessPoint :: () -> Result #foreign libnx;

/**
* @brief CloseAccessPoint
* @note \ref LdnState must be ::LdnState_AccessPointOpened or ::LdnState_AccessPointCreated, this eventually sets the State to ::LdnState_Initialized.
* @note Used automatically internally by \ref ldnExit if needed.
*/
ldnCloseAccessPoint :: () -> Result #foreign libnx;

/**
* @brief CreateNetwork
* @note \ref LdnState must be ::LdnState_AccessPointOpened, this eventually sets the State to ::LdnState_AccessPointCreated.
* @param[in] sec_config \ref LdnSecurityConfig
* @param[in] user_config \ref LdnUserConfig
* @param[in] network_config \ref LdnNetworkConfig
*/
ldnCreateNetwork :: (sec_config: *LdnSecurityConfig, user_config: *LdnUserConfig, network_config: *LdnNetworkConfig) -> Result #foreign libnx;

/**
* @brief CreateNetworkPrivate
* @note \ref LdnState must be ::LdnState_AccessPointOpened, this eventually sets the State to ::LdnState_AccessPointCreated.
* @note This is the same as \ref ldnCreateNetwork besides the additional user-specified params, and with this cmd LdnNetworkConfig::channel is not overwritten (unlike \ref ldnCreateNetwork).
* @param[in] sec_config \ref LdnSecurityConfig
* @param[in] sec_param \ref LdnSecurityParameter
* @param[in] user_config \ref LdnUserConfig
* @param[in] network_config \ref LdnNetworkConfig
* @param[in] addrs Input array of \ref LdnAddressEntry. This can be NULL.
* @param[in] count Size of the addrs array in entries. This must be <=8. This can be 0, in which case the network will be non-Private like \ref ldnCreateNetwork.
*/
ldnCreateNetworkPrivate :: (sec_config: *LdnSecurityConfig, sec_param: *LdnSecurityParameter, user_config: *LdnUserConfig, network_config: *LdnNetworkConfig, addrs: *LdnAddressEntry, count: s32) -> Result #foreign libnx;

/**
* @brief DestroyNetwork
* @note \ref LdnState must be ::LdnState_AccessPointCreated, this eventually sets the State to ::LdnState_AccessPointOpened.
*/
ldnDestroyNetwork :: () -> Result #foreign libnx;

/**
* @brief Reject
* @note \ref LdnState must be ::LdnState_AccessPointCreated.
* @param[in] addr \ref LdnIpv4Address
*/
ldnReject :: (addr: LdnIpv4Address) -> Result #foreign libnx;

/**
* @brief SetAdvertiseData
* @note An empty buffer (buffer=NULL/size=0) can be used to reset the AdvertiseData size in state to zero.
* @note \ref LdnState must be ::LdnState_AccessPointOpened or ::LdnState_AccessPointCreated.
* @param[in] buffer Input buffer containing arbitrary user data.
* @param[in] size Input buffer size, must be <=0x180. If this isn't enough space, you can for example also periodically use this cmd with different regions of your data with some sequence_number field (or use sockets while connected to the network).
*/
ldnSetAdvertiseData :: (buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief SetStationAcceptPolicy
* @note \ref LdnState must be ::LdnState_AccessPointOpened or ::LdnState_AccessPointCreated.
* @param[in] policy \ref LdnAcceptPolicy
*/
ldnSetStationAcceptPolicy :: (policy: LdnAcceptPolicy) -> Result #foreign libnx;

/**
* @brief AddAcceptFilterEntry
* @note \ref LdnState must be ::LdnState_AccessPointOpened or ::LdnState_AccessPointCreated.
* @note See \ref LdnAcceptPolicy.
* @param[in] addr \ref LdnMacAddress. If you want, you can also pass LdnNodeInfo::mac_addr for this.
*/
ldnAddAcceptFilterEntry :: (addr: LdnMacAddress) -> Result #foreign libnx;

/**
* @brief ClearAcceptFilter
* @note \ref LdnState must be ::LdnState_AccessPointOpened or ::LdnState_AccessPointCreated.
*/
ldnClearAcceptFilter :: () -> Result #foreign libnx;

/**
* @brief OpenStation
* @note \ref LdnState must be ::LdnState_Initialized, this eventually sets the State to ::LdnState_StationOpened.
*/
ldnOpenStation :: () -> Result #foreign libnx;

/**
* @brief CloseStation
* @note \ref LdnState must be ::LdnState_StationOpened or ::LdnState_StationConnected, this eventually sets the State to ::LdnState_Initialized.
* @note Used automatically internally by \ref ldnExit if needed.
*/
ldnCloseStation :: () -> Result #foreign libnx;

/**
* @brief Connect
* @note \ref LdnState must be ::LdnState_StationOpened, this eventually sets the State to ::LdnState_StationConnected.
* @note This is identical to \ref ldnConnectPrivate besides the used params, the code overwriting LdnSecurityConfig::type also differs.
* @param[in] sec_config \ref LdnSecurityConfig
* @param[in] user_config \ref LdnUserConfig
* @param[in] version LocalCommunicationVersion, this must be 0x0-0x7FFF.
* @param[in] option ConnectOption bitmask, must be <=0x1. You can use value 0 for example here.
* @param[in] network_info \ref LdnNetworkInfo
*/
ldnConnect :: (sec_config: *LdnSecurityConfig, user_config: *LdnUserConfig, version: s32, option: u32, network_info: *LdnNetworkInfo) -> Result #foreign libnx;

/**
* @brief ConnectPrivate
* @note \ref LdnState must be ::LdnState_StationOpened, this eventually sets the State to ::LdnState_StationConnected.
* @note See \ref ldnConnect.
* @param[in] sec_config \ref LdnSecurityConfig
* @param[in] sec_param \ref LdnSecurityParameter
* @param[in] user_config \ref LdnUserConfig
* @param[in] version LocalCommunicationVersion, this must be 0x0-0x7FFF.
* @param[in] option ConnectOption bitmask, must be <=0x1. You can use value 0 for example here.
* @param[in] network_config \ref LdnNetworkConfig
*/
ldnConnectPrivate :: (sec_config: *LdnSecurityConfig, sec_param: *LdnSecurityParameter, user_config: *LdnUserConfig, version: s32, option: u32, network_config: *LdnNetworkConfig) -> Result #foreign libnx;

/**
* @brief Disconnect
* @note \ref LdnState must be ::LdnState_StationConnected, this eventually sets the State to ::LdnState_StationOpened.
*/
ldnDisconnect :: () -> Result #foreign libnx;

/**
* @brief SetOperationMode
* @note Only available on [4.0.0+].
* @note Only available with ::LdnServiceType_System.
* @note \ref LdnState must be ::LdnState_Initialized.
* @param[in] mode \ref LdnOperationMode
*/
ldnSetOperationMode :: (mode: LdnOperationMode) -> Result #foreign libnx;

Lp2pServiceType :: enum u32 {
    App    :: 0;
    System :: 1;
}

/// MacAddress
Lp2pMacAddress :: struct {
    addr: [6] u8; ///< Address
}

/// GroupId
Lp2pGroupId :: struct {
    id: [6] u8; ///< BSSID
}

/// GroupInfo
/// \ref lp2pScan only uses the following fields for the cmd input struct: supported_platform/priority, frequency/channel, and preshared_key_binary_size/preshared_key.
Lp2pGroupInfo :: struct {
    unk_x0:                    [16] u8; ///< When zero, this is set to randomly-generated data. Used during key derivation.
    local_communication_id:    u64; ///< LocalCommunicationId. When zero, the value from the user-process control.nacp is loaded. This is later validated by \ref lp2pJoin / \ref lp2pCreateGroup the same way as LdnNetworkConfig::local_communication_id. Used during key derivation.
    group_id:                  Lp2pGroupId; ///< Should be all-zero for the input struct so that the default is used.
    service_name:              [33] u8; ///< ServiceName. NUL-terminated string for the SSID. These characters must be '-' or alphanumeric (lowercase/uppercase). '_' must not be used, unless you generate valid data for that. The data for '_' will be automatically generated if it's not present.
    flags_count:               s8; ///< Must be <=0x3F.
    flags:                     [64] s8; ///< Array of s8 with the above count. Each entry value must be <=0x3F. Each entry is an array index used to load a set of flags from a global array with the specified index.
    supported_platform:        u8; ///< SupportedPlatform. Must match value 1. 0 is PlatformIdNX, 1 is PlatformIdFuji.
    member_count_max:          s8; ///< MemberCountMax. Must be <=0x8. If zero during group-creation, a default of value 1 is used for the value passed to a service-cmd.
    unk_x82:                   u8; ///< Unknown
    unk_x83:                   u8; ///< Unknown
    frequency:                 u16; ///< Wifi frequency: 24 = 2.4GHz, 50 = 5GHz.
    channel:                   s16; ///< Wifi channel number. 0 = use default, otherwise this must be one of the following depending on the frequency field. 24: 1, 6, 11. 50: 36, 40, 44, 48.
    network_mode:              u8; ///< NetworkMode
    performance_requirement:   u8; ///< PerformanceRequirement
    security_type:             u8; ///< Security type, used during key derivation. 0 = use defaults, 1 = plaintext, 2 = encrypted. [11.0.0+] 3: Standard WPA2-PSK.
    static_aes_key_index:      s8; ///< StaticAesKeyIndex. Used as the array-index for selecting the KeySource used with GenerateAesKek during key derivation. Should be 1-2, otherwise GenerateAesKek is skipped and zeros are used for the AccessKey instead.
    unk_x8C:                   u8; ///< Unknown
    priority:                  u8; ///< Priority. Must match one of the following, depending on the used service (doesn't apply to \ref lp2pJoin): 55 = SystemPriority (lp2p:sys), 90 = ApplicationPriority (lp2p:app and lp2p:sys).
    stealth_enabled:           u8; ///< StealthEnabled. Bool flag, controls whether the SSID is hidden.
    unk_x8F:                   u8; ///< If zero, a default value of 0x20 is used.
    unk_x90:                   [304] u8; ///< Unknown
    preshared_key_binary_size: u8; ///< PresharedKeyBinarySize
    preshared_key:             [63] u8; ///< PresharedKey. Used during key derivation.
}

/// ScanResult
Lp2pScanResult :: struct {
    group_info:          Lp2pGroupInfo; ///< \ref Lp2pGroupInfo
    unk_x200:            u8; ///< Unknown
    unk_x201:            [5] u8; ///< Unknown
    advertise_data_size: u16; ///< Size of the following AdvertiseData.
    advertise_data:      [128] u8; ///< AdvertiseData, with the above size. This originates from \ref lp2pSetAdvertiseData.
    unk_x288:            [120] u8; ///< Unknown
}

/// NodeInfo
Lp2pNodeInfo :: struct {
    ip_addr:  [32] u8; ///< struct sockaddr for the IP address.
    unk_x20:  [4] u8; ///< Unknown
    mac_addr: Lp2pMacAddress; ///< \ref Lp2pMacAddress
    unk_x2A:  [86] u8; ///< Unknown
}

/// IpConfig. Only contains IPv4 addresses.
Lp2pIpConfig :: struct {
    unk_x0:      [32] u8; ///< Always zeros.
    ip_addr:     [32] u8; ///< struct sockaddr for the IP address.
    subnet_mask: [32] u8; ///< struct sockaddr for the subnet-mask.
    gateway:     [32] u8; ///< struct sockaddr for the gateway(?).
    unk_x80:     [128] u8; ///< Always zeros.
}

/// Initialize lp2p.
lp2pInitialize :: (service_type: Lp2pServiceType) -> Result #foreign libnx;

/// Exit lp2p.
lp2pExit :: () -> void #foreign libnx;

/// Gets the Service object for INetworkService.
lp2pGetServiceSession_INetworkService :: () -> *Service #foreign libnx;

/// Gets the Service object for INetworkServiceMonitor.
lp2pGetServiceSession_INetworkServiceMonitor :: () -> *Service #foreign libnx;

/**
* @brief Creates a default \ref Lp2pGroupInfo for use with \ref lp2pCreateGroup / \ref lp2pJoin.
* @param info \ref Lp2pGroupInfo
*/
lp2pCreateGroupInfo :: (info: *Lp2pGroupInfo) -> void #foreign libnx;

/**
* @brief Creates a default \ref Lp2pGroupInfo for use with \ref lp2pScan.
* @param info \ref Lp2pGroupInfo
*/
lp2pCreateGroupInfoScan :: (info: *Lp2pGroupInfo) -> void #foreign libnx;

/**
* @brief Sets Lp2pGroupInfo::service_name.
* @param info \ref Lp2pGroupInfo
* @param[in] name ServiceName / SSID.
*/
lp2pGroupInfoSetServiceName :: (info: *Lp2pGroupInfo, name: *u8) -> void #foreign libnx;

/**
* @brief Sets Lp2pGroupInfo::flags_count and Lp2pGroupInfo::flags.
* @note The default is count=1 flags[0]=1, which is used by \ref lp2pCreateGroupInfo. [11.0.0+] To use standard WPA2-PSK, you can use flags[0]=0.
* @param info \ref Lp2pGroupInfo
* @param[in] flags Lp2pGroupInfo::flags
* @param[in] count Lp2pGroupInfo::flags_count
*/
lp2pGroupInfoSetFlags :: (info: *Lp2pGroupInfo, flags: *s8, count: u64) -> void #foreign libnx;

/**
* @brief Sets the PresharedKey for the specified \ref Lp2pGroupInfo.
* @note Using this is required before using the \ref Lp2pGroupInfo as input for any cmds, so that Lp2pGroupInfo::preshared_key_binary_size gets initialized.
* @note If standard WPA2-PSK is being used, use \ref lp2pGroupInfoSetPassphrase instead.
* @param info \ref Lp2pGroupInfo
* @param[in] key Data for the PresharedKey.
* @param[in] size Size to copy into the PresharedKey, max is 0x20.
*/
lp2pGroupInfoSetPresharedKey :: (info: *Lp2pGroupInfo, key: *void, size: u64) -> void #foreign libnx;

/**
* @brief Sets the passphrase, for when standard WPA2-PSK is being used.
* @note Configure standard WPA2-PSK usage via \ref lp2pGroupInfoSetFlags / Lp2pGroupInfo::security_type.
* @note Only available on [11.0.0+].
* @param info \ref Lp2pGroupInfo
* @param[in] passphrase Passphrase string, the required length is 0x8-0x3F.
*/
lp2pGroupInfoSetPassphrase :: (info: *Lp2pGroupInfo, passphrase: *u8) -> Result #foreign libnx;

/**
* @brief Scan
* @param[in] info \ref Lp2pGroupInfo
* @param[out] results Output array of \ref Lp2pScanResult.
* @param[in] count Size of the results array in entries.
* @param[out] total_out Total output entries.
*/
lp2pScan :: (info: *Lp2pGroupInfo, results: *Lp2pScanResult, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief CreateGroup
* @note The role (\ref lp2pGetRole) must be 0. This eventually sets the role to value 1.
* @param[in] info \ref Lp2pGroupInfo
*/
lp2pCreateGroup :: (info: *Lp2pGroupInfo) -> Result #foreign libnx;

/**
* @brief This destroys the previously created group from \ref lp2pCreateGroup.
* @note If no group was previously created (role from \ref lp2pGetRole is not 1), this just returns 0.
*/
lp2pDestroyGroup :: () -> Result #foreign libnx;

/**
* @brief SetAdvertiseData
* @note The role (\ref lp2pGetRole) must be <=1.
* @note An empty buffer (buffer=NULL/size=0) can be used to reset the AdvertiseData size in state to zero.
* @param[out] buffer Input buffer containing arbitrary user data.
* @param[in] size Input buffer size, must be <=0x80.
*/
lp2pSetAdvertiseData :: (buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief This sends an Action frame to the specified \ref Lp2pGroupId, with the specified destination \ref Lp2pMacAddress.
* @note The role (\ref lp2pGetRole) must be non-zero.
* @note The error from \ref lp2pGetNetworkInterfaceLastError will be returned if it's set.
* @note [11.0.0+] Lp2pGroupInfo::security_type must be value 2 (default encryption), otherwise an error is returned.
* @param[in] buffer Input buffer containing arbitrary user data.
* @param[in] size Input buffer size, must be <=0x400.
* @param[in] addr \ref Lp2pMacAddress, this can be a broadcast address. This must be non-zero.
* @param[in] group_id \ref Lp2pGroupId
* @param[in] frequency Must be >=1. See Lp2pGroupInfo::frequency.
* @param[in] channel Must be >=1. See Lp2pGroupInfo::channel.
* @param[in] flags Only bit0 is used: clear = block until the data can be sent, set = return error when the data can't be sent.
*/
lp2pSendToOtherGroup :: (buffer: *void, size: u64, addr: Lp2pMacAddress, group_id: Lp2pGroupId, frequency: s16, channel: s16, flags: u32) -> Result #foreign libnx;

/**
* @brief This receives an Action frame.
* @note The role (\ref lp2pGetRole) must be non-zero.
* @note When data is not available, the error from \ref lp2pGetNetworkInterfaceLastError will be returned if it's set.
* @param[out] buffer Output buffer containing arbitrary user data.
* @param[in] size Output buffer size.
* @param[in] flags Only bit0 is used: clear = block until data is available, set = return error when data is not available.
* @param[in] addr \ref Lp2pMacAddress
* @param[in] unk0 Unknown
* @param[in] unk1 Unknown
* @param[out] out_size This is the original size used for copying to the output buffer, before it's clamped to the output-buffer size.
* @param[out] unk2 Unknown
*/
lp2pRecvFromOtherGroup :: (buffer: *void, size: u64, flags: u32, addr: *Lp2pMacAddress, unk0: *u16, unk1: *s32, out_size: *u64, unk2: *s32) -> Result #foreign libnx;

/**
* @brief AddAcceptableGroupId
* @param[in] group_id \ref Lp2pGroupId
*/
lp2pAddAcceptableGroupId :: (group_id: Lp2pGroupId) -> Result #foreign libnx;

/**
* @brief RemoveAcceptableGroupId
*/
lp2pRemoveAcceptableGroupId :: () -> Result #foreign libnx;

/**
* @brief AttachNetworkInterfaceStateChangeEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
lp2pAttachNetworkInterfaceStateChangeEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetNetworkInterfaceLastError
*/
lp2pGetNetworkInterfaceLastError :: () -> Result #foreign libnx;

/**
* @brief GetRole
* @param[out] out Output Role.
*/
lp2pGetRole :: (out: *u8) -> Result #foreign libnx;

/**
* @brief GetAdvertiseData
* @note The role from \ref lp2pGetRole must be value 2.
* @param[out] buffer Output buffer data.
* @param[in] size Output buffer size.
* @param[out] transfer_size Size of the data copied into the buffer.
* @param[out] original_size Original size from state.
*/
lp2pGetAdvertiseData :: (buffer: *void, size: u64, transfer_size: *u16, original_size: *u16) -> Result #foreign libnx;

/**
* @brief GetAdvertiseData2
* @note This is identical to \ref lp2pGetAdvertiseData except this doesn't run the role validation.
* @param[out] buffer Output buffer data.
* @param[in] size Output buffer size.
* @param[out] transfer_size Size of the data copied into the buffer.
* @param[out] original_size Original size from state.
*/
lp2pGetAdvertiseData2 :: (buffer: *void, size: u64, transfer_size: *u16, original_size: *u16) -> Result #foreign libnx;

/**
* @brief GetGroupInfo
* @note The role from \ref lp2pGetRole must be non-zero.
* @param[out] out \ref Lp2pGroupInfo
*/
lp2pGetGroupInfo :: (out: *Lp2pGroupInfo) -> Result #foreign libnx;

/**
* @brief This runs the same code as \ref lp2pCreateGroup to generate the \ref Lp2pGroupInfo for the input struct.
* @param[out] out \ref Lp2pGroupInfo
* @param[in] info \ref Lp2pGroupInfo
*/
lp2pJoin :: (out: *Lp2pGroupInfo, info: *Lp2pGroupInfo) -> Result #foreign libnx;

/**
* @brief GetGroupOwner
* @note The role from \ref lp2pGetRole must be non-zero.
* @param[out] out \ref Lp2pNodeInfo
*/
lp2pGetGroupOwner :: (out: *Lp2pNodeInfo) -> Result #foreign libnx;

/**
* @brief GetIpConfig
* @note The role from \ref lp2pGetRole must be non-zero.
* @param[out] out \ref Lp2pIpConfig
*/
lp2pGetIpConfig :: (out: *Lp2pIpConfig) -> Result #foreign libnx;

/**
* @brief Leave
* @param[out] out Output value.
*/
lp2pLeave :: (out: *u32) -> Result #foreign libnx;

/**
* @brief AttachJoinEvent
* @note The Event must be closed by the user once finished with it.
* @param[out] out_event Output Event with autoclear=false.
*/
lp2pAttachJoinEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief GetMembers
* @note The role from \ref lp2pGetRole must be value 1.
* @param[out] members Output array of \ref Lp2pNodeInfo.
* @param[in] count Size of the members array in entries. A maximum of 8 entries can be returned.
* @param[out] total_out Total output entries.
*/
lp2pGetMembers :: (members: *Lp2pNodeInfo, count: s32, total_out: *s32) -> Result #foreign libnx;

NewsServiceType :: enum u32 {
    Administrator :: 0;
    Configuration :: 1;
    Manager       :: 2;
    Post          :: 3;
    Viewer        :: 4;

    Count         :: 5;
}

NewsTopicName :: struct {
    name: [32] u8;
}

NewsNewlyArrivedEventHolder :: struct {
    s: Service;
}

NewsDataService :: struct {
    s: Service;
}

NewsDatabaseService :: struct {
    s: Service;
}

NewsOverwriteEventHolder :: struct {
    s: Service;
}

NewsRecordV1 :: struct {
    news_id:     [24] u8;
    user_id:     [24] u8;
    received_at: s64;
    read:        s32;
    newly:       s32;
    displayed:   s32;
}

NewsRecord :: struct {
    news_id:         [24] u8;
    user_id:         [24] u8;
    topic_id:        NewsTopicName;
    received_at:     s64;
    pad_0:           s64;
    decoration_type: s32;
    read:            s32;
    newly:           s32;
    displayed:       s32;
    feedback:        s32;
    pad_1:           s32;
    extra_1:         s32;
    extra_2:         s32;
}

newsInitialize :: (service_type: NewsServiceType) -> Result #foreign libnx;
newsExit :: () -> void #foreign libnx;

newsGetServiceSession :: () -> *Service #foreign libnx;

newsCreateNewlyArrivedEventHolder :: (out: *NewsNewlyArrivedEventHolder) -> Result #foreign libnx;
newsCreateNewsDataService :: (out: *NewsDataService) -> Result #foreign libnx;
newsCreateNewsDatabaseService :: (out: *NewsDatabaseService) -> Result #foreign libnx;
newsCreateOverwriteEventHolder :: (out: *NewsOverwriteEventHolder) -> Result #foreign libnx;

newsPostLocalNews :: (news: *void, size: u64) -> Result #foreign libnx;
newsSetPassphrase :: (program_id: u64, passphrase: *u8) -> Result #foreign libnx;
newsGetSubscriptionStatus :: (filter: *u8, status: *u32) -> Result #foreign libnx;
newsGetTopicList :: (channel: u32, out_count: *u32, out: *NewsTopicName, max_count: u32) -> Result #foreign libnx;
newsGetSavedataUsage :: (current: *u64, total: *u64) -> Result #foreign libnx;
newsIsSystemUpdateRequired :: (out: *bool) -> Result #foreign libnx;
newsGetDatabaseVersion :: (version: *u32) -> Result #foreign libnx;
newsRequestImmediateReception :: (filter: *u8) -> Result #foreign libnx;
newsSetSubscriptionStatus :: (filter: *u8, status: u32) -> Result #foreign libnx;
newsClearStorage :: () -> Result #foreign libnx;
newsClearSubscriptionStatusAll :: () -> Result #foreign libnx;
newsGetNewsDatabaseDump :: (buffer: *void, size: u64, out: *u64) -> Result #foreign libnx;

newsNewlyArrivedEventHolderClose :: (srv: *NewsNewlyArrivedEventHolder) -> void #foreign libnx;
newsNewlyArrivedEventHolderGet :: (srv: *NewsNewlyArrivedEventHolder, out: *Event) -> Result #foreign libnx;

newsDataClose :: (srv: *NewsDataService) -> void #foreign libnx;
newsDataOpen :: (srv: *NewsDataService, file_name: *u8) -> Result #foreign libnx;
newsDataOpenWithNewsRecordV1 :: (srv: *NewsDataService, record: *NewsRecordV1) -> Result #foreign libnx;
newsDataRead :: (srv: *NewsDataService, bytes_read: *u64, offset: u64, out: *void, out_size: u64) -> Result #foreign libnx;
newsDataGetSize :: (srv: *NewsDataService, size: *u64) -> Result #foreign libnx;
newsDataOpenWithNewsRecord :: (srv: *NewsDataService, record: *NewsRecord) -> Result #foreign libnx;

newsDatabaseClose :: (srv: *NewsDatabaseService) -> void #foreign libnx;
newsDatabaseGetListV1 :: (srv: *NewsDatabaseService, out: *NewsRecordV1, max_count: u32, where: *u8, order: *u8, count: *u32, offset: u32) -> Result #foreign libnx;
newsDatabaseCount :: (srv: *NewsDatabaseService, filter: *u8, count: *u32) -> Result #foreign libnx;
newsDatabaseGetList :: (srv: *NewsDatabaseService, out: *NewsRecord, max_count: u32, where: *u8, order: *u8, count: *u32, offset: u32) -> Result #foreign libnx;

newsOverwriteEventHolderClose :: (srv: *NewsOverwriteEventHolder) -> void #foreign libnx;
newsOverwriteEventHolderGet :: (srv: *NewsOverwriteEventHolder, out: *Event) -> Result #foreign libnx;

/// Initialize ins:r.
insrInitialize :: () -> Result #foreign libnx;

/// Exit ins:r.
insrExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ins:r service session.
insrGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Retrieves the last system tick the event corresponding to the ID was signaled at.
* @param[in] id Ins request ID (should be 0..4).
* @param[out] tick.
* @return Result code.
* @note The tick is only updated once per second at minimum.
*/
insrGetLastTick :: (id: u32, tick: *u64) -> Result #foreign libnx;

/**
* @brief Retrieves the event corresponding to the ID.
* @param[in] id Ins request ID (should be 0..4).
* @param[out] out.
* @return Result code.
* @note The event is only signaled once per second at minimum.
*/
insrGetReadableEvent :: (id: u32, out: *Event) -> Result #foreign libnx;

/// Initialize ins:s.
inssInitialize :: () -> Result #foreign libnx;

/// Exit ins:s.
inssExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ins:s service session.
inssGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Retrieves the event corresponding to the ID.
* @param[in] id Ins send ID (should be 0..11).
* @param[out] out.
* @return Result code.
* @note The returned event cannot be waited on, only signaled. Clearing is handled by the service.
*/
inssGetWritableEvent :: (id: u32, out: *Event) -> Result #foreign libnx;

/// Initialize ectx:r.
ectxrInitialize :: () -> Result #foreign libnx;

/// Exit ectx:r.
ectxrExit :: () -> void #foreign libnx;

/// Gets the Service object for the actual ectx:r service session.
ectxrGetServiceSession :: () -> *Service #foreign libnx;

/**
* @brief Retrieves the error context associated with an error descriptor and result.
* @param[out] out0 Output value.
* @param[out] out_total_size Total error context size.
* @param[out] out_size Error context size.
* @param[out] dst Buffer for output error context.
* @param[in] dst_size Buffer size for output error context.
* @param[in] descriptor Error descriptor.
* @param[in] result Error result.
* @return Result code.
*/
ectxrPullContext :: (out0: *s32, out_total_size: *u32, out_size: *u32, dst: *void, dst_size: u64, descriptor: u32, result: Result) -> Result #foreign libnx;

AvmVersionListEntry :: struct {
    application_id: u64;
    version:        u32;
    required:       u32;
}

AvmRequiredVersionEntry :: struct {
    application_id: u64;
    version:        u32;
}

AvmVersionListImporter :: struct {
    s: Service;
}

avmInitialize :: () -> Result #foreign libnx;
avmExit :: () -> void #foreign libnx;

avmGetServiceSession :: () -> *Service #foreign libnx;

avmGetHighestAvailableVersion :: (id_1: u64, id_2: u64, version: *u32) -> Result #foreign libnx;
avmGetHighestRequiredVersion :: (id_1: u64, id_2: u64, version: *u32) -> Result #foreign libnx;
avmGetVersionListEntry :: (application_id: u64, entry: *AvmVersionListEntry) -> Result #foreign libnx;
avmGetVersionListImporter :: (out: *AvmVersionListImporter) -> Result #foreign libnx;
avmGetLaunchRequiredVersion :: (application_id: u64, version: *u32) -> Result #foreign libnx;
avmUpgradeLaunchRequiredVersion :: (application_id: u64, version: u32) -> Result #foreign libnx;
avmPushLaunchVersion :: (application_id: u64, version: u32) -> Result #foreign libnx;
avmListVersionList :: (buffer: *AvmVersionListEntry, count: u64, out: *u32) -> Result #foreign libnx;
avmListRequiredVersion :: (buffer: *AvmRequiredVersionEntry, count: u64, out: *u32) -> Result #foreign libnx;

avmVersionListImporterClose :: (srv: *AvmVersionListImporter) -> void #foreign libnx;
avmVersionListImporterSetTimestamp :: (srv: *AvmVersionListImporter, timestamp: u64) -> Result #foreign libnx;
avmVersionListImporterSetData :: (srv: *AvmVersionListImporter, entries: *AvmVersionListEntry, count: u32) -> Result #foreign libnx;
avmVersionListImporterFlush :: (srv: *AvmVersionListImporter) -> Result #foreign libnx;

MmuModuleId :: enum u32 {
    Ram   :: 2;
    Nvenc :: 5;
    Nvdec :: 6;
    Nvjpg :: 7;
}

MmuRequest :: struct {
    module: MmuModuleId;
    id:     u32;
}

mmuInitialize :: () -> Result #foreign libnx;
mmuExit :: () -> void #foreign libnx;
mmuGetServiceSession :: () -> *Service #foreign libnx;

mmuRequestInitialize :: (request: *MmuRequest, module: MmuModuleId, unk: u32, autoclear: bool) -> Result #foreign libnx;
mmuRequestFinalize :: (request: *MmuRequest) -> Result #foreign libnx;
mmuRequestGet :: (request: *MmuRequest, out_freq_hz: *u32) -> Result #foreign libnx;
mmuRequestSetAndWait :: (request: *MmuRequest, freq_hz: u32, timeout: s32) -> Result #foreign libnx;

ParcelHeader :: struct {
    payload_size: u32;
    payload_off:  u32;
    objects_size: u32;
    objects_off:  u32;
}

Parcel :: struct {
    payload:      [1024] u8;
    payload_size: u32;
    objects:      *u8;
    objects_size: u32;

    capacity:     u32;
    pos:          u32;
}

parcelCreate :: (ctx: *Parcel) -> void #foreign libnx;
parcelTransact :: (session: *Binder, code: u32, in_parcel: *Parcel, reply_parcel: *Parcel) -> Result #foreign libnx;

parcelWriteData :: (ctx: *Parcel, data: *void, data_size: u64) -> *void #foreign libnx;
parcelReadData :: (ctx: *Parcel, data: *void, data_size: u64) -> *void #foreign libnx;

parcelWriteInt32 :: (ctx: *Parcel, val: s32) -> void #foreign libnx;
parcelWriteUInt32 :: (ctx: *Parcel, val: u32) -> void #foreign libnx;
parcelWriteString16 :: (ctx: *Parcel, str: *u8) -> void #foreign libnx;

parcelReadInt32 :: (ctx: *Parcel) -> s32 #foreign libnx;
parcelReadUInt32 :: (ctx: *Parcel) -> u32 #foreign libnx;
parcelWriteInterfaceToken :: (ctx: *Parcel, str: *u8) -> void #foreign libnx;

parcelReadFlattenedObject :: (ctx: *Parcel, size: *u64) -> *void #foreign libnx;
parcelWriteFlattenedObject :: (ctx: *Parcel, data: *void, size: u64) -> *void #foreign libnx;

NvMap :: struct {
    handle:           u32;
    id:               u32;
    size:             u32;
    cpu_addr:         *void;
    kind:             NvKind;
    has_init:         bool;
    is_cpu_cacheable: bool;
}

nvMapInit :: () -> Result #foreign libnx;
nvMapGetFd :: () -> u32 #foreign libnx;
nvMapExit :: () -> void #foreign libnx;

nvMapCreate :: (m: *NvMap, cpu_addr: *void, size: u32, align: u32, kind: NvKind, is_cpu_cacheable: bool) -> Result #foreign libnx;
nvMapLoadRemote :: (m: *NvMap, id: u32) -> Result #foreign libnx;
nvMapClose :: (m: *NvMap) -> void #foreign libnx;

/// Framebuffer structure.
Framebuffer :: struct {
    win:            *NWindow;
    map:            NvMap;
    buf:            *void;
    buf_linear:     *void;
    stride:         u32;
    width_aligned:  u32;
    height_aligned: u32;
    num_fbs:        u32;
    fb_size:        u32;
    has_init:       bool;
}

/**
* @brief Creates a \ref Framebuffer object.
* @param[out] fb Output \ref Framebuffer structure.
* @param[in] win Pointer to the \ref NWindow to which the \ref Framebuffer will be registered.
* @param[in] width Desired width of the framebuffer (usually 1280).
* @param[in] height Desired height of the framebuffer (usually 720).
* @param[in] format Desired pixel format (see PIXEL_FORMAT_* enum).
* @param[in] num_fbs Number of buffers to create. Pass 1 for single-buffering, 2 for double-buffering or 3 for triple-buffering.
* @note Framebuffer images are stored in Tegra block linear format with 16Bx2 sector ordering, read TRM chapter 20.1 for more details.
*       In order to use regular linear layout, consider calling \ref framebufferMakeLinear after the \ref Framebuffer object is created.
* @note Presently, only the following pixel formats are supported:
*       \ref PIXEL_FORMAT_RGBA_8888
*       \ref PIXEL_FORMAT_RGBX_8888
*       \ref PIXEL_FORMAT_RGB_565
*       \ref PIXEL_FORMAT_BGRA_8888
*       \ref PIXEL_FORMAT_RGBA_4444
*/
framebufferCreate :: (fb: *Framebuffer, win: *NWindow, width: u32, height: u32, format: u32, num_fbs: u32) -> Result #foreign libnx;

/// Enables linear framebuffer mode in a \ref Framebuffer, allocating a shadow buffer in the process.
framebufferMakeLinear :: (fb: *Framebuffer) -> Result #foreign libnx;

/// Closes a \ref Framebuffer object, freeing all resources associated with it.
framebufferClose :: (fb: *Framebuffer) -> void #foreign libnx;

/**
* @brief Begins rendering a frame in a \ref Framebuffer.
* @param[in] fb Pointer to \ref Framebuffer structure.
* @param[out] out_stride Output variable containing the distance in bytes between rows of pixels in memory.
* @return Pointer to buffer to which new graphics data should be written to.
* @note When this function is called, a buffer will be dequeued from the corresponding \ref NWindow.
* @note This function will return pointers to different buffers, depending on the number of buffers it was initialized with.
* @note If \ref framebufferMakeLinear was used, this function will instead return a pointer to the shadow linear buffer.
*       In this case, the offset of a pixel is \p y * \p out_stride + \p x * \p bytes_per_pixel.
* @note Each call to \ref framebufferBegin must be paired with a \ref framebufferEnd call.
*/
framebufferBegin :: (fb: *Framebuffer, out_stride: *u32) -> *void #foreign libnx;

/**
* @brief Finishes rendering a frame in a \ref Framebuffer.
* @param[in] fb Pointer to \ref Framebuffer structure.
* @note When this function is called, the written image data will be flushed and queued (presented) in the corresponding \ref NWindow.
* @note If \ref framebufferMakeLinear was used, this function will copy the image from the shadow linear buffer to the actual framebuffer,
*       converting it in the process to the layout expected by the compositor.
* @note Each call to \ref framebufferBegin must be paired with a \ref framebufferEnd call.
*/
framebufferEnd :: (fb: *Framebuffer) -> void #foreign libnx;

NvAddressSpace :: struct {
    fd:        u32;
    page_size: u32;
    has_init:  bool;
}

nvAddressSpaceCreate :: (a: *NvAddressSpace, page_size: u32) -> Result #foreign libnx;
nvAddressSpaceClose :: (a: *NvAddressSpace) -> void #foreign libnx;

nvAddressSpaceAlloc :: (a: *NvAddressSpace, sparse: bool, size: u64, iova_out: *iova_t) -> Result #foreign libnx;
nvAddressSpaceAllocFixed :: (a: *NvAddressSpace, sparse: bool, size: u64, iova: iova_t) -> Result #foreign libnx;
nvAddressSpaceFree :: (a: *NvAddressSpace, iova: iova_t, size: u64) -> Result #foreign libnx;

nvAddressSpaceMap :: (a: *NvAddressSpace, nvmap_handle: u32, is_gpu_cacheable: bool, kind: NvKind, iova_out: *iova_t) -> Result #foreign libnx;
nvAddressSpaceMapFixed :: (a: *NvAddressSpace, nvmap_handle: u32, is_gpu_cacheable: bool, kind: NvKind, iova: iova_t) -> Result #foreign libnx;
nvAddressSpaceModify :: (a: *NvAddressSpace, iova: iova_t, offset: u64, size: u64, kind: NvKind) -> Result #foreign libnx;
nvAddressSpaceUnmap :: (a: *NvAddressSpace, iova: iova_t) -> Result #foreign libnx;

NvChannel :: struct {
    fd:       u32;
    has_init: bool;
}

nvChannelCreate :: (c: *NvChannel, dev: *u8) -> Result #foreign libnx;
nvChannelClose :: (c: *NvChannel) -> void #foreign libnx;

nvChannelSetPriority :: (c: *NvChannel, prio: NvChannelPriority) -> Result #foreign libnx;
nvChannelSetTimeout :: (c: *NvChannel, timeout: u32) -> Result #foreign libnx;

nvGpuInit :: () -> Result #foreign libnx;
nvGpuExit :: () -> void #foreign libnx;

nvGpuGetCharacteristics :: () -> *nvioctl_gpu_characteristics #foreign libnx;
nvGpuGetZcullCtxSize :: () -> u32 #foreign libnx;
nvGpuGetZcullInfo :: () -> *nvioctl_zcull_info #foreign libnx;
nvGpuGetTpcMasks :: (num_masks_out: *u32) -> *u32 #foreign libnx;

nvGpuZbcGetActiveSlotMask :: (out_slot: *u32, out_mask: *u32) -> Result #foreign libnx;
nvGpuZbcAddColor :: (color_l2: *[4] u32, color_ds: *[4] u32, format: u32) -> Result #foreign libnx;
nvGpuZbcAddDepth :: (depth: float) -> Result #foreign libnx;
nvGpuGetTimestamp :: (ts: *u64) -> Result #foreign libnx;

NvGpuChannel :: struct {
    base:        NvChannel;
    error_event: Event;
    object_id:   u64;
    fence:       NvFence;
    fence_incr:  u32;
    entries:     [2048] nvioctl_gpfifo_entry #align 4;
    num_entries: u32;
}

nvGpuChannelCreate :: (c: *NvGpuChannel, as: *NvAddressSpace, prio: NvChannelPriority) -> Result #foreign libnx;
nvGpuChannelClose :: (c: *NvGpuChannel) -> void #foreign libnx;

nvGpuChannelZcullBind :: (c: *NvGpuChannel, iova: iova_t) -> Result #foreign libnx;
nvGpuChannelAppendEntry :: (c: *NvGpuChannel, start: iova_t, num_cmds: u64, flags: u32, flush_threshold: u32) -> Result #foreign libnx;
nvGpuChannelKickoff :: (c: *NvGpuChannel) -> Result #foreign libnx;
nvGpuChannelGetErrorNotification :: (c: *NvGpuChannel, notif: *NvNotification) -> Result #foreign libnx;
nvGpuChannelGetErrorInfo :: (c: *NvGpuChannel, error: *NvError) -> Result #foreign libnx;

AudioDriverEtc :: struct {}

AudioDriver :: struct {
    etc:         *AudioDriverEtc;
    config:      AudioRendererConfig;
    in_mempools: *AudioRendererMemPoolInfoIn;
    in_channels: *AudioRendererChannelInfoIn;
    in_voices:   *AudioRendererVoiceInfoIn;
    in_mixes:    *AudioRendererMixInfoIn;
    in_sinks:    *AudioRendererSinkInfoIn;
}

audrvCreate :: (d: *AudioDriver, config: *AudioRendererConfig, num_final_mix_channels: s32) -> Result #foreign libnx;
audrvUpdate :: (d: *AudioDriver) -> Result #foreign libnx;
audrvClose :: (d: *AudioDriver) -> void #foreign libnx;

//-----------------------------------------------------------------------------
audrvMemPoolAdd :: (d: *AudioDriver, buffer: *void, size: u64) -> s32 #foreign libnx;
audrvMemPoolRemove :: (d: *AudioDriver, id: s32) -> bool #foreign libnx;
audrvMemPoolAttach :: (d: *AudioDriver, id: s32) -> bool #foreign libnx;
audrvMemPoolDetach :: (d: *AudioDriver, id: s32) -> bool #foreign libnx;

//-----------------------------------------------------------------------------
AudioDriverWaveBufState :: enum u32 {
    Free    :: 0;
    Waiting :: 1;
    Queued  :: 2;
    Playing :: 3;
    Done    :: 4;
}

AudioDriverWaveBuf :: struct {
    union {
        data_pcm16: *s16;
        data_adpcm: *u8;
        data_raw:   *void;
    }

    size:                u64;
    start_sample_offset: s32;
    end_sample_offset:   s32;
    context_addr:        *void;
    context_sz:          u64;
    state:               u8;
    is_looping:          bool;
    sequence_id:         u32;
    next:                *AudioDriverWaveBuf;
}

audrvVoiceInit :: (d: *AudioDriver, id: s32, num_channels: s32, format: PcmFormat, sample_rate: s32) -> bool #foreign libnx;
audrvVoiceDrop :: (d: *AudioDriver, id: s32) -> void #foreign libnx;
audrvVoiceStop :: (d: *AudioDriver, id: s32) -> void #foreign libnx;
audrvVoiceIsPaused :: (d: *AudioDriver, id: s32) -> bool #foreign libnx;
audrvVoiceIsPlaying :: (d: *AudioDriver, id: s32) -> bool #foreign libnx;
audrvVoiceAddWaveBuf :: (d: *AudioDriver, id: s32, wavebuf: *AudioDriverWaveBuf) -> bool #foreign libnx;
audrvVoiceGetWaveBufSeq :: (d: *AudioDriver, id: s32) -> u32 #foreign libnx;
audrvVoiceGetPlayedSampleCount :: (d: *AudioDriver, id: s32) -> u32 #foreign libnx;
audrvVoiceGetVoiceDropsCount :: (d: *AudioDriver, id: s32) -> u32 #foreign libnx;
audrvVoiceSetBiquadFilter :: (d: *AudioDriver, id: s32, biquad_id: s32, a0: float, a1: float, a2: float, b0: float, b1: float, b2: float) -> void #foreign libnx;

//-----------------------------------------------------------------------------
audrvMixAdd :: (d: *AudioDriver, sample_rate: s32, num_channels: s32) -> s32 #foreign libnx;
audrvMixRemove :: (d: *AudioDriver, id: s32) -> void #foreign libnx;

//-----------------------------------------------------------------------------
audrvDeviceSinkAdd :: (d: *AudioDriver, device_name: *u8, num_channels: s32, channel_ids: *u8) -> s32 #foreign libnx;
audrvSinkRemove :: (d: *AudioDriver, id: s32) -> void #foreign libnx;

/// CommonArguments
LibAppletArgs :: struct {
    CommonArgs_version: u32; ///< \ref libappletArgsCreate sets this to 1, and \ref libappletArgsPop requires value 1. v0 is not supported.
    CommonArgs_size:    u32; ///< Size of this struct.

    LaVersion:          u32; ///< LibraryApplet API version.
    ExpectedThemeColor: s32; ///< Set to the output from \ref appletGetThemeColorType by \ref libappletArgsCreate.
    PlayStartupSound:   u8; ///< bool flag, default is false.
    pad:                [7] u8; ///< Padding.
    tick:               u64; ///< System tick. Set to the output from \ref armGetSystemTick during \ref libappletArgsPush.
}

/**
* @brief Creates a LibAppletArgs struct.
* @param a LibAppletArgs struct.
* @param version LaVersion for \ref LibAppletArgs.
*/
libappletArgsCreate :: (a: *LibAppletArgs, version: u32) -> void #foreign libnx;

/**
* @brief Sets the PlayStartupSound field in \ref LibAppletArgs.
* @param a LibAppletArgs struct.
* @param flag Value for \ref LibAppletArgs PlayStartupSound.
*/
libappletArgsSetPlayStartupSound :: (a: *LibAppletArgs, flag: bool) -> void #foreign libnx;

/**
* @brief Creates an AppletStorage with the specified size and writes the buffer contents to that storage at offset 0.
* @param[out] s Storage object.
* @param buffer Input buffer.
* @param size Size to write.
*/
libappletCreateWriteStorage :: (s: *AppletStorage, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Reads data from offset 0 from the specified storage into the buffer. If the storage-size is smaller than the size param, the storage-size is used instead.
* @param s Storage object.
* @param buffer Output buffer.
* @param size Size to read.
* @param transfer_size Optional output size field for the actual size used for the read, can be NULL.
*/
libappletReadStorage :: (s: *AppletStorage, buffer: *void, size: u64, transfer_size: *u64) -> Result #foreign libnx;

/**
* @brief Sets the tick field in LibAppletArgs, then creates a storage with it which is pushed to the AppletHolder via \ref appletHolderPushInData.
* @param a LibAppletArgs struct.
* @param h AppletHolder object.
*/
libappletArgsPush :: (a: *LibAppletArgs, h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Uses \ref appletPopInData and reads it to the specified LibAppletArgs. The LibAppletArgs is validated, an error is thrown when invalid.
* @param[out] a LibAppletArgs struct.
*/
libappletArgsPop :: (a: *LibAppletArgs) -> Result #foreign libnx;

/**
* @brief Creates a storage using the input buffer which is pushed to the AppletHolder via \ref appletHolderPushInData.
* @param h AppletHolder object.
* @param buffer Input data buffer.
* @param size Input data size.
*/
libappletPushInData :: (h: *AppletHolder, buffer: *void, size: u64) -> Result #foreign libnx;

/**
* @brief Pops a storage via \ref appletHolderPopOutData, uses \ref libappletReadStorage, then closes the storage.
* @param h AppletHolder object.
* @param buffer Output buffer.
* @param size Size to read.
* @param transfer_size Optional output size field for the actual size used for the read, can be NULL.
*/
libappletPopOutData :: (h: *AppletHolder, buffer: *void, size: u64, transfer_size: *u64) -> Result #foreign libnx;

/**
* @brief Sets whether \ref libappletStart uses \ref appletHolderJump.
* @param flag Flag. Value true should not be used unless running as AppletType_LibraryApplet.
*/
libappletSetJumpFlag :: (flag: bool) -> void #foreign libnx;

/**
* @brief If the flag from \ref libappletSetJumpFlag is set, this just uses \ref appletHolderJump. Otherwise, starts the applet and waits for it to finish, then checks the \ref LibAppletExitReason.
* @note Uses \ref appletHolderStart and \ref appletHolderJoin.
* @param h AppletHolder object.
*/
libappletStart :: (h: *AppletHolder) -> Result #foreign libnx;

/**
* @brief Creates a LibraryApplet with the specified input storage data, uses \ref libappletStart, and reads the output storage reply data via \ref libappletPopOutData.
* @param id \ref AppletId
* @param commonargs \ref LibAppletArgs struct.
* @param arg Input storage data buffer. Optional, can be NULL.
* @param arg_size Size of the arg buffer.
* @param reply Output storage data buffer. Optional, can be NULL.
* @param reply_size Size to read for the reply buffer.
* @param out_reply_size Actual read reply data size, see \ref libappletPopOutData.
*/
libappletLaunch :: (id: AppletId, commonargs: *LibAppletArgs, arg: *void, arg_size: u64, reply: *void, reply_size: u64, out_reply_size: *u64) -> Result #foreign libnx;

/// Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
/// Returns to the main Home Menu, equivalent to pressing the HOME button.
libappletRequestHomeMenu :: () -> Result #foreign libnx;

/// Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
/// Equivalent to entering "System Update" under System Settings. When leaving this, it returns to the main Home Menu.
libappletRequestJumpToSystemUpdate :: () -> Result #foreign libnx;

/**
* @brief Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
* @note Only available on [11.0.0+].
* @param[in] application_id ApplicationId
* @param[in] uid \ref AccountUid
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size.
* @param[in] sender LaunchApplicationRequestSender
*/
libappletRequestToLaunchApplication :: (application_id: u64, uid: AccountUid, buffer: *void, size: u64, sender: u32) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref appletPushToGeneralChannel, see appletPushToGeneralChannel regarding the requirements for using this.
* @note Only available on [11.0.0+].
* @param[in] uid \ref AccountUid
* @param[in] application_id Optional ApplicationId, can be 0.
*/
libappletRequestJumpToStory :: (uid: AccountUid, application_id: u64) -> Result #foreign libnx;

/// Arg type values pushed for the applet input storage, stored as an u8.
AlbumLaArg :: enum u32 {
    ShowAlbumFiles               :: 0;
    ShowAllAlbumFiles            :: 1;
    ShowAllAlbumFilesForHomeMenu :: 2;
}

/**
* @brief Launches the applet with ::AlbumLaArg_ShowAlbumFiles and playStartupSound=false.
*/
albumLaShowAlbumFiles :: () -> Result #foreign libnx;

/**
* @brief Launches the applet with ::AlbumLaArg_ShowAllAlbumFiles and playStartupSound=false.
*/
albumLaShowAllAlbumFiles :: () -> Result #foreign libnx;

/**
* @brief Launches the applet with ::AlbumLaArg_ShowAllAlbumFilesForHomeMenu and playStartupSound=true.
*/
albumLaShowAllAlbumFilesForHomeMenu :: () -> Result #foreign libnx;

/// Arg type values used with \ref FriendsLaArg.
FriendsLaArgType :: enum u32 {
    ShowFriendList                    :: 0;
    ShowUserDetailInfo                :: 1;
    StartSendingFriendRequest         :: 2;
    ShowMethodsOfSendingFriendRequest :: 3;
    StartFacedFriendRequest           :: 4;
    ShowReceivedFriendRequestList     :: 5;
    ShowBlockedUserList               :: 6;
    ShowMyProfile                     :: 7;
    StartFriendInvitation             :: 8;
    StartSendingFriendInvitation      :: 9;
    ShowReceivedInvitationDetail      :: 10;
}

/// Header for the arg struct.
FriendsLaArgHeader :: struct {
    type: u32; ///< \ref FriendsLaArgType
    pad:  u32; ///< Padding.
    uid:  AccountUid; ///< \ref AccountUid
}

/// Common data for the arg struct, for the pre-9.0.0 types.
/// This is only set for ::FriendsLaArgType_ShowUserDetailInfo/::FriendsLaArgType_StartSendingFriendRequest, for everything else this is cleared.
FriendsLaArgCommonData :: struct {
    id:                     AccountNetworkServiceAccountId; ///< \ref AccountNetworkServiceAccountId for the other account.
    first_inAppScreenName:  FriendsInAppScreenName; ///< First InAppScreenName.
    second_inAppScreenName: FriendsInAppScreenName; ///< Second InAppScreenName.
}

/// Arg struct pushed for the applet input storage, for pre-9.0.0.
FriendsLaArgV1 :: struct {
    hdr:  FriendsLaArgHeader; ///< \ref FriendsLaArgHeader
    data: FriendsLaArgCommonData; ///< \ref FriendsLaArgCommonData
}

/// Arg struct pushed for the applet input storage, for [9.0.0+].
FriendsLaArg :: struct {
    hdr:  FriendsLaArgHeader; ///< \ref FriendsLaArgHeader

    data: union {
        raw:                             [4240] u8; ///< Raw data.

        common:                          FriendsLaArgCommonData; ///< \ref FriendsLaArgCommonData

        start_friend_invitation:         struct {
            id_count:      s32; ///< \ref AccountNetworkServiceAccountId count, must be 1-15.
            pad:           u32; ///< Padding.
            userdata_size: u64; ///< User-data size, must be <=0x400.
            userdata:      [1024] u8; ///< Arbitrary user-data, see above size.
            desc:          FriendsFriendInvitationGameModeDescription; ///< \ref FriendsFriendInvitationGameModeDescription
        }; ///< Data for ::FriendsLaArgType_StartFriendInvitation.

        start_sending_friend_invitation: struct {
            id_count:      s32; ///< \ref AccountNetworkServiceAccountId count, must be 1-15.
            pad:           u32; ///< Padding.
            id_list:       [16] AccountNetworkServiceAccountId; ///< \ref AccountNetworkServiceAccountId list, see above count.
            userdata_size: u64; ///< User-data size, must be <=0x400.
            userdata:      [1024] u8; ///< Arbitrary user-data, see above size.
            desc:          FriendsFriendInvitationGameModeDescription; ///< \ref FriendsFriendInvitationGameModeDescription
        }; ///< Data for ::FriendsLaArgType_StartSendingFriendInvitation.

        show_received_invitation_detail: struct {
            invitation_id:       FriendsFriendInvitationId; ///< \ref FriendsFriendInvitationId
            invitation_group_id: FriendsFriendInvitationGroupId; ///< \ref FriendsFriendInvitationGroupId
        }; ///< Data for ::FriendsLaArgType_ShowReceivedInvitationDetail.
    }; ///< Data for each \ref FriendsLaArgType.
}

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowFriendList, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaShowFriendList :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowUserDetailInfo, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
* @param[in] id \ref AccountNetworkServiceAccountId for the user to show UserDetailInfo for.
* @param[in] first_inAppScreenName First \ref FriendsInAppScreenName.
* @param[in] second_inAppScreenName Second \ref FriendsInAppScreenName.
*/
friendsLaShowUserDetailInfo :: (uid: AccountUid, id: AccountNetworkServiceAccountId, first_inAppScreenName: *FriendsInAppScreenName, second_inAppScreenName: *FriendsInAppScreenName) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_StartSendingFriendRequest, the specified input, and playStartupSound=false. On success, this will load the output Result from the output storage.
* @param[in] uid \ref AccountUid
* @param[in] id \ref AccountNetworkServiceAccountId to send the friend request to.
* @param[in] first_inAppScreenName First \ref FriendsInAppScreenName.
* @param[in] second_inAppScreenName Second \ref FriendsInAppScreenName.
*/
friendsLaStartSendingFriendRequest :: (uid: AccountUid, id: AccountNetworkServiceAccountId, first_inAppScreenName: *FriendsInAppScreenName, second_inAppScreenName: *FriendsInAppScreenName) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowMethodsOfSendingFriendRequest, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaShowMethodsOfSendingFriendRequest :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_StartFacedFriendRequest, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaStartFacedFriendRequest :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowReceivedFriendRequestList, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaShowReceivedFriendRequestList :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowBlockedUserList, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaShowBlockedUserList :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowMyProfile, the specified input, and playStartupSound=false.
* @param[in] uid \ref AccountUid
*/
friendsLaShowMyProfile :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Same as \ref friendsLaShowMyProfile except with playStartupSound=true.
* @param[in] uid \ref AccountUid
*/
friendsLaShowMyProfileForHomeMenu :: (uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_StartFriendInvitation, the specified input, and playStartupSound=false. On success, this will load the output Result from the output storage.
* @note Only available on [9.0.0+].
* @param[in] uid \ref AccountUid
* @param[in] id_count \ref AccountNetworkServiceAccountId count, must be 1-15. Number of friends to invite.
* @param[in] desc \ref FriendsFriendInvitationGameModeDescription
* @param[in] userdata Arbitrary user-data. Can be NULL.
* @param[in] userdata_size User-data size, must be <=0x400. Can be 0 if userdata is NULL.
*/
friendsLaStartFriendInvitation :: (uid: AccountUid, id_count: s32, desc: *FriendsFriendInvitationGameModeDescription, userdata: *void, userdata_size: u64) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_StartSendingFriendInvitation, the specified input, and playStartupSound=false. On success, this will load the output Result from the output storage.
* @note Only available on [9.0.0+].
* @param[in] uid \ref AccountUid
* @param[in] id_list \ref AccountNetworkServiceAccountId list.
* @param[in] id_count Size of the id_list array in entries, must be 1-15. Number of friends to invite.
* @param[in] desc \ref FriendsFriendInvitationGameModeDescription
* @param[in] userdata Arbitrary user-data. Can be NULL.
* @param[in] userdata_size User-data size, must be <=0x400. Can be 0 if userdata is NULL.
*/
friendsLaStartSendingFriendInvitation :: (uid: AccountUid, id_list: *AccountNetworkServiceAccountId, id_count: s32, desc: *FriendsFriendInvitationGameModeDescription, userdata: *void, userdata_size: u64) -> Result #foreign libnx;

/**
* @brief Launches the applet with ::FriendsLaArgType_ShowReceivedInvitationDetail, the specified input, and playStartupSound=false.
* @note Only available on [9.0.0+].
* @param[in] uid \ref AccountUid
* @param[in] invitation_id \ref FriendsFriendInvitationId
* @param[in] invitation_group_id \ref FriendsFriendInvitationGroupId
*/
friendsLaShowReceivedInvitationDetail :: (uid: AccountUid, invitation_id: FriendsFriendInvitationId, invitation_group_id: FriendsFriendInvitationGroupId) -> Result #foreign libnx;

/// Mode values for HidLaControllerSupportArgPrivate::mode.
HidLaControllerSupportMode :: enum u32 {
    ShowControllerSupport               :: 0;
    ShowControllerStrapGuide            :: 1;
    ShowControllerFirmwareUpdate        :: 2;
    ShowControllerKeyRemappingForSystem :: 4;
}

/// ControllerSupportCaller
HidLaControllerSupportCaller :: enum u32 {
    Application :: 0;
    System      :: 1;
}

/// ControllerSupportArgPrivate
HidLaControllerSupportArgPrivate :: struct {
    private_size:              u32; ///< Size of this ControllerSupportArgPrivate struct.
    arg_size:                  u32; ///< Size of the storage following this one (\ref HidLaControllerSupportArg or \ref HidLaControllerFirmwareUpdateArg).
    flag0:                     u8; ///< Flag0
    flag1:                     u8; ///< Flag1
    mode:                      u8; ///< \ref HidLaControllerSupportMode
    controller_support_caller: u8; ///< \ref HidLaControllerSupportCaller. Always zero except with \ref hidLaShowControllerFirmwareUpdateForSystem, which sets this to the input param.
    npad_style_set:            u32; ///< Output from \ref hidGetSupportedNpadStyleSet. With ShowControllerSupportForSystem on pre-3.0.0 this is value 0.
    npad_joy_hold_type:        u32; ///< Output from \ref hidGetNpadJoyHoldType. With ShowControllerSupportForSystem on pre-3.0.0 this is value 1.
}

/// Common header used by HidLaControllerSupportArg*.
/// max_supported_players is 4 on pre-8.0.0, 8 on [8.0.0+]. player_count_min and player_count_max are overriden with value 4 when larger than value 4, during conversion handling for \ref HidLaControllerSupportArg on pre-8.0.0.
HidLaControllerSupportArgHeader :: struct {
    player_count_min:            s8; ///< playerCountMin. Must be >=0 and <=max_supported_players.
    player_count_max:            s8; ///< playerCountMax. Must be >=1 and <=max_supported_players.
    enable_take_over_connection: u8; ///< enableTakeOverConnection, non-zero to enable. Disconnects the controllers when not enabled.
    enable_left_justify:         u8; ///< enableLeftJustify, non-zero to enable.
    enable_permit_joy_dual:      u8; ///< enablePermitJoyDual, non-zero to enable.
    enable_single_mode:          u8; ///< enableSingleMode, non-zero to enable. Enables using a single player in handheld-mode, dual-mode, or single-mode (player_count_* are overridden). Using handheld-mode is not allowed if this is not enabled.
    enable_identification_color: u8; ///< When non-zero enables using identification_color.
}

/// Identification color used by HidLaControllerSupportArg*. When HidLaControllerSupportArgHeader::enable_identification_color is set this controls the color of the UI player box outline.
HidLaControllerSupportArgColor :: struct {
    r: u8; ///< Red color component.
    g: u8; ///< Green color component.
    b: u8; ///< Blue color component.
    a: u8; ///< Alpha color component.
}

/// ControllerSupportArg for [1.0.0+].
HidLaControllerSupportArgV3 :: struct {
    hdr:                  HidLaControllerSupportArgHeader; ///< \ref HidLaControllerSupportArgHeader
    identification_color: [4] HidLaControllerSupportArgColor; ///< \ref HidLaControllerSupportArgColor for each player, see HidLaControllerSupportArgHeader::enable_identification_color.
    enable_explain_text:  u8; ///< Enables using the ExplainText data when non-zero.
    explain_text:         [4] [129] u8; ///< ExplainText for each player, NUL-terminated UTF-8 strings.
}

/// ControllerSupportArg for [8.0.0+], converted to \ref HidLaControllerSupportArgV3 on pre-8.0.0.
HidLaControllerSupportArg :: struct {
    hdr:                  HidLaControllerSupportArgHeader; ///< \ref HidLaControllerSupportArgHeader
    identification_color: [8] HidLaControllerSupportArgColor; ///< \ref HidLaControllerSupportArgColor for each player, see HidLaControllerSupportArgHeader::enable_identification_color.
    enable_explain_text:  u8; ///< Enables using the ExplainText data when non-zero.
    explain_text:         [8] [129] u8; ///< ExplainText for each player, NUL-terminated UTF-8 strings.
}

/// ControllerFirmwareUpdateArg
HidLaControllerFirmwareUpdateArg :: struct {
    enable_force_update: u8; ///< enableForceUpdate, non-zero to enable. Default is 0. Forces a firmware update when enabled, without an UI option to skip it.
    pad:                 [3] u8; ///< Padding.
}

/// ControllerKeyRemappingArg
HidLaControllerKeyRemappingArg :: struct {
    unk_x0: u64; ///< Unknown
    unk_x8: u32; ///< Unknown
    pad:    [4] u8; ///< Padding
}

/// ControllerSupportResultInfo. First 8-bytes from the applet output storage.
HidLaControllerSupportResultInfo :: struct {
    player_count: s8; ///< playerCount.
    pad:          [3] u8; ///< Padding.
    selected_id:  u32; ///< \ref HidNpadIdType, selectedId.
}

/// Struct for the applet output storage.
HidLaControllerSupportResultInfoInternal :: struct {
    info: HidLaControllerSupportResultInfo; ///< \ref HidLaControllerSupportResultInfo
    res:  u32; ///< Output res value.
}

/**
* @brief Initializes a \ref HidLaControllerSupportArg with the defaults.
* @note This clears the arg, then does: HidLaControllerSupportArgHeader::player_count_min = 0, HidLaControllerSupportArgHeader::player_count_max = 4, HidLaControllerSupportArgHeader::enable_take_over_connection = 1, HidLaControllerSupportArgHeader::enable_left_justify = 1, and HidLaControllerSupportArgHeader::enable_permit_joy_dual = 1.
* @note If preferred, you can also memset \ref HidLaControllerSupportArg manually and initialize it yourself.
* @param[out] arg \ref HidLaControllerSupportArg
*/
hidLaCreateControllerSupportArg :: (arg: *HidLaControllerSupportArg) -> void #foreign libnx;

/**
* @brief Initializes a \ref HidLaControllerFirmwareUpdateArg with the defaults.
* @note This just uses memset() with the arg.
* @param[out] arg \ref HidLaControllerFirmwareUpdateArg
*/
hidLaCreateControllerFirmwareUpdateArg :: (arg: *HidLaControllerFirmwareUpdateArg) -> void #foreign libnx;

/**
* @brief Initializes a \ref HidLaControllerKeyRemappingArg with the defaults.
* @note This just uses memset() with the arg.
* @param[out] arg \ref HidLaControllerKeyRemappingArg
*/
hidLaCreateControllerKeyRemappingArg :: (arg: *HidLaControllerKeyRemappingArg) -> void #foreign libnx;

/**
* @brief Sets the ExplainText for the specified player and \ref HidLaControllerSupportArg.
* @note This string is displayed in the UI box for the player.
* @note HidLaControllerSupportArg::enable_explain_text must be set, otherwise this ExplainText is ignored.
* @param arg \ref HidLaControllerSupportArg
* @param[in] str Input ExplainText UTF-8 string, max length is 0x80 excluding NUL-terminator.
+ @oaram[in] id Player controller, must be <8.
*/
hidLaSetExplainText :: (arg: *HidLaControllerSupportArg, str: *u8, id: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief Launches the applet for ControllerSupport.
* @note This seems to only display the applet UI when doing so is actually needed? This doesn't apply to \ref hidLaShowControllerSupportForSystem.
* @param[out] result_info \ref HidLaControllerSupportResultInfo. Optional, can be NULL.
* @param[in] arg \ref HidLaControllerSupportArg
*/
hidLaShowControllerSupport :: (result_info: *HidLaControllerSupportResultInfo, arg: *HidLaControllerSupportArg) -> Result #foreign libnx;

/**
* @brief Launches the applet for ControllerStrapGuide.
* @note Only available on [3.0.0+].
*/
hidLaShowControllerStrapGuide :: () -> Result #foreign libnx;

/**
* @brief Launches the applet for ControllerFirmwareUpdate.
* @note Only available on [3.0.0+].
* @param[in] arg \ref HidLaControllerFirmwareUpdateArg
*/
hidLaShowControllerFirmwareUpdate :: (arg: *HidLaControllerFirmwareUpdateArg) -> Result #foreign libnx;

/**
* @brief This is the system version of \ref hidLaShowControllerSupport.
* @param[out] result_info \ref HidLaControllerSupportResultInfo. Optional, can be NULL.
* @param[in] arg \ref HidLaControllerSupportArg
* @param[in] flag Input flag. When true, the applet displays the menu as if launched by qlaunch.
*/
hidLaShowControllerSupportForSystem :: (result_info: *HidLaControllerSupportResultInfo, arg: *HidLaControllerSupportArg, flag: bool) -> Result #foreign libnx;

/**
* @brief This is the system version of \ref hidLaShowControllerFirmwareUpdate.
* @note Only available on [3.0.0+].
* @param[in] arg \ref HidLaControllerFirmwareUpdateArg
* @param[in] caller \ref HidLaControllerSupportCaller
*/
hidLaShowControllerFirmwareUpdateForSystem :: (arg: *HidLaControllerFirmwareUpdateArg, caller: HidLaControllerSupportCaller) -> Result #foreign libnx;

/**
* @brief Launches the applet for ControllerKeyRemappingForSystem.
* @note Only available on [11.0.0+].
* @param[in] arg \ref HidLaControllerKeyRemappingArg
* @param[in] caller \ref HidLaControllerSupportCaller
*/
hidLaShowControllerKeyRemappingForSystem :: (arg: *HidLaControllerKeyRemappingArg, caller: HidLaControllerSupportCaller) -> Result #foreign libnx;

/// AppletMode
MiiLaAppletMode :: enum u32 {
    ShowMiiEdit    :: 0;
    AppendMii      :: 1;
    AppendMiiImage :: 2;
    UpdateMiiImage :: 3;
    CreateMii      :: 4;
    EditMii        :: 5;
}

/// AppletInput
MiiLaAppletInput :: struct {
    version:          s32; ///< Version
    mode:             u32; ///< \ref MiiLaAppletMode
    special_key_code: s32; ///< \ref MiiSpecialKeyCode
    union {
        valid_uuid_array: [8] Uuid; ///< ValidUuidArray. Only used with \ref MiiLaAppletMode ::NfpLaMiiLaAppletMode_AppendMiiImage / ::NfpLaMiiLaAppletMode_UpdateMiiImage.
        char_info:        struct {
            char_info:  MiiCharInfo; ///< \ref MiiCharInfo
            unused_x64: [40] u8; ///< Unused
        };
    }

    used_uuid:        Uuid; ///< UsedUuid. Only used with \ref MiiLaAppletMode ::NfpLaMiiLaAppletMode_UpdateMiiImage.
    unk_x9C:          [100] u8; ///< Unused
}

/// AppletOutput
MiiLaAppletOutput :: struct {
    res:    u32; ///< Result: 0 = Success, 1 = Cancel.
    index:  s32; ///< Index. Only set when Result is Success, where \ref MiiLaAppletMode isn't ::NfpLaMiiLaAppletMode_ShowMiiEdit.
    unk_x8: [24] u8; ///< Unused
}

/// AppletOutputForCharInfoEditing
MiiLaAppletOutputForCharInfoEditing :: struct {
    res:       u32; ///< MiiLaAppletOutput::res
    char_info: MiiCharInfo; ///< \ref MiiCharInfo
    unused:    [36] u8; ///< Unused
}

/**
* @brief Launches the applet for ShowMiiEdit.
* @param[in] special_key_code \ref MiiSpecialKeyCode
*/
miiLaShowMiiEdit :: (special_key_code: MiiSpecialKeyCode) -> Result #foreign libnx;

/**
* @brief Launches the applet for AppendMii.
* @param[in] special_key_code \ref MiiSpecialKeyCode
* @param[out] index Output Index.
*/
miiLaAppendMii :: (special_key_code: MiiSpecialKeyCode, index: *s32) -> Result #foreign libnx;

/**
* @brief Launches the applet for AppendMiiImage.
* @param[in] special_key_code \ref MiiSpecialKeyCode
* @param[in] valid_uuid_array Input array of Uuid.
* @param[in] count Total entries for the valid_uuid_array. Must be 0-8.
* @param[out] index Output Index.
*/
miiLaAppendMiiImage :: (special_key_code: MiiSpecialKeyCode, valid_uuid_array: *Uuid, count: s32, index: *s32) -> Result #foreign libnx;

/**
* @brief Launches the applet for UpdateMiiImage.
* @param[in] special_key_code \ref MiiSpecialKeyCode
* @param[in] valid_uuid_array Input array of Uuid.
* @param[in] count Total entries for the valid_uuid_array. Must be 0-8.
* @param[in] used_uuid UsedUuid
* @param[out] index Output Index.
*/
miiLaUpdateMiiImage :: (special_key_code: MiiSpecialKeyCode, valid_uuid_array: *Uuid, count: s32, used_uuid: Uuid, index: *s32) -> Result #foreign libnx;

/**
* @brief Launches the applet for CreateMii.
* @note This creates a Mii and returns it, without saving it in the database.
* @note Only available on [10.2.0+].
* @param[in] special_key_code \ref MiiSpecialKeyCode
* @param[out] out_char \ref MiiCharInfo
*/
miiLaCreateMii :: (special_key_code: MiiSpecialKeyCode, out_char: *MiiCharInfo) -> Result #foreign libnx;

/**
* @brief Launches the applet for EditMii.
* @note This edits the specified Mii and returns it, without saving it in the database.
* @note Only available on [10.2.0+].
* @param[in] special_key_code \ref MiiSpecialKeyCode
* @param[in] in_char \ref MiiCharInfo
* @param[out] out_char \ref MiiCharInfo
*/
miiLaEditMii :: (special_key_code: MiiSpecialKeyCode, in_char: *MiiCharInfo, out_char: *MiiCharInfo) -> Result #foreign libnx;

/// Values for NfpLaStartParamForAmiiboSettings::type.
NfpLaStartParamTypeForAmiiboSettings :: enum u32 {
    NicknameAndOwnerSettings :: 0;
    GameDataEraser           :: 1;
    Restorer                 :: 2;
    Formatter                :: 3;
}

/// AmiiboSettingsStartParam
NfpLaAmiiboSettingsStartParam :: struct {
    unk_x0:  [8] u8; ///< Unknown
    unk_x8:  [32] u8; ///< Unknown
    unk_x28: u8; ///< Unknown
}

/// StartParamForAmiiboSettings
NfpLaStartParamForAmiiboSettings :: struct {
    unk_x0:        u8; ///< Unknown
    type:          u8; ///< \ref NfpLaStartParamTypeForAmiiboSettings
    flags:         u8; ///< Flags
    unk_x3:        u8; ///< NfpLaAmiiboSettingsStartParam::unk_x28
    unk_x4:        [8] u8; ///< NfpLaAmiiboSettingsStartParam::unk_x0
    tag_info:      NfpTagInfo; ///< \ref NfpTagInfo, only enabled when flags bit1 is set.
    register_info: NfpRegisterInfo; ///< \ref NfpRegisterInfo, only enabled when flags bit2 is set.
    unk_x164:      [32] u8; ///< NfpLaAmiiboSettingsStartParam::unk_x8
    unk_x184:      [36] u8; ///< Unknown
}

/// ReturnValueForAmiiboSettings
NfpLaReturnValueForAmiiboSettings :: struct {
    flags:         u8; ///< 0 = error, non-zero = success.
    pad:           [3] u8; ///< Padding
    handle:        NfcDeviceHandle; ///< \ref NfcDeviceHandle
    tag_info:      NfpTagInfo; ///< \ref NfpTagInfo
    register_info: NfpRegisterInfo; ///< \ref NfpRegisterInfo, only available when flags bit2 is set.
    unk_x164:      [36] u8; ///< Unknown
}

/**
* @brief Launches the applet for NicknameAndOwnerSettings.
* @note Official sw does not expose functionality for using input/output \ref NfpTagInfo at the same time.
* @param[in] in_param \ref NfpLaAmiiboSettingsStartParam
* @param[in] in_tag_info \ref NfpTagInfo. Optional, can be NULL. If specified, this must match the scanned amiibo.
* @param[in] in_reg_info \ref NfpRegisterInfo. Optional, can be NULL. If specified, this sets the \ref NfpRegisterInfo which will be used for writing, with an option for the user to change it.
* @param[out] out_tag_info \ref NfpTagInfo. Optional, can be NULL.
* @param[out] handle \ref NfcDeviceHandle
* @param[out] reg_info_flag Flag indicating whether the data for out_reg_info is set. Optional, can be NULL.
* @param[out] out_reg_info \ref NfpRegisterInfo, see reg_info_flag. Optional, can be NULL.
*/
nfpLaStartNicknameAndOwnerSettings :: (in_param: *NfpLaAmiiboSettingsStartParam, in_tag_info: *NfpTagInfo, in_reg_info: *NfpRegisterInfo, out_tag_info: *NfpTagInfo, handle: *NfcDeviceHandle, reg_info_flag: *bool, out_reg_info: *NfpRegisterInfo) -> Result #foreign libnx;

/**
* @brief Launches the applet for GameDataEraser.
* @note Official sw does not expose functionality for using input/output \ref NfpTagInfo at the same time.
* @param[in] in_param \ref NfpLaAmiiboSettingsStartParam
* @param[in] in_tag_info \ref NfpTagInfo. Optional, can be NULL. If specified, this must match the scanned amiibo.
* @param[out] out_tag_info \ref NfpTagInfo. Optional, can be NULL.
* @param[out] handle \ref NfcDeviceHandle
*/
nfpLaStartGameDataEraser :: (in_param: *NfpLaAmiiboSettingsStartParam, in_tag_info: *NfpTagInfo, out_tag_info: *NfpTagInfo, handle: *NfcDeviceHandle) -> Result #foreign libnx;

/**
* @brief Launches the applet for Restorer.
* @note Official sw does not expose functionality for using input/output \ref NfpTagInfo at the same time.
* @param[in] in_param \ref NfpLaAmiiboSettingsStartParam
* @param[in] in_tag_info \ref NfpTagInfo. Optional, can be NULL. If specified, this must match the scanned amiibo.
* @param[out] out_tag_info \ref NfpTagInfo. Optional, can be NULL.
* @param[out] handle \ref NfcDeviceHandle
*/
nfpLaStartRestorer :: (in_param: *NfpLaAmiiboSettingsStartParam, in_tag_info: *NfpTagInfo, out_tag_info: *NfpTagInfo, handle: *NfcDeviceHandle) -> Result #foreign libnx;

/**
* @brief Launches the applet for Formatter.
* @param[in] in_param \ref NfpLaAmiiboSettingsStartParam
* @param[out] out_tag_info \ref NfpTagInfo
* @param[out] handle \ref NfcDeviceHandle
*/
nfpLaStartFormatter :: (in_param: *NfpLaAmiiboSettingsStartParam, out_tag_info: *NfpTagInfo, handle: *NfcDeviceHandle) -> Result #foreign libnx;

/**
* @brief Uses \ref nifmGetResult, then on failure launches the applet.
* @param r \ref NifmRequest
*/
nifmLaHandleNetworkRequestResult :: (r: *NifmRequest) -> Result #foreign libnx;

/// Type values for PctlAuthArg::type.
PctlAuthType :: enum u32 {
    Show             :: 0;
    RegisterPasscode :: 1;
    ChangePasscode   :: 2;
}

/// Input arg storage for the applet.
PctlAuthArg :: struct {
    unk_x0: u32; ///< Always set to 0 by the user-process.
    type:   PctlAuthType; ///< \ref PctlAuthType
    arg0:   u8; ///< Arg0
    arg1:   u8; ///< Arg1
    arg2:   u8; ///< Arg2
    pad:    u8; ///< Padding
}

/**
* @brief Launches the applet.
* @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
* @param flag Input flag. false = temporarily disable Parental Controls. true = validate the input PIN.
*/
pctlauthShow :: (flag: bool) -> Result #foreign libnx;

/**
* @brief Launches the applet. Only available with [4.0.0+].
* @param arg0 Value for PctlAuthArg.arg0.
* @param arg1 Value for PctlAuthArg.arg1.
* @param arg2 Value for PctlAuthArg.arg2.
*/
pctlauthShowEx :: (arg0: u8, arg1: u8, arg2: u8) -> Result #foreign libnx;

/**
* @brief Just calls: pctlauthShowEx(1, 0, 1). Launches the applet for checking the PIN, used when changing system-settings.
* @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
*/
pctlauthShowForConfiguration :: () -> Result #foreign libnx;

/**
* @brief Launches the applet for registering the Parental Controls PIN.
*/
pctlauthRegisterPasscode :: () -> Result #foreign libnx;

/**
* @brief Launches the applet for changing the Parental Controls PIN.
* @note Should not be used if a PIN is not already registered. See \ref pctlIsRestrictionEnabled.
*/
pctlauthChangePasscode :: () -> Result #foreign libnx;

/// playerSelect UI modes.
PselUiMode :: enum u32 {
    UserSelector                                            :: 0;
    UserCreator                                             :: 1;
    EnsureNetworkServiceAccountAvailable                    :: 2;
    UserIconEditor                                          :: 3;
    UserNicknameEditor                                      :: 4;
    UserCreatorForStarter                                   :: 5;
    NintendoAccountAuthorizationRequestContext              :: 6;
    IntroduceExternalNetworkServiceAccount                  :: 7;
    IntroduceExternalNetworkServiceAccountForRegistration   :: 8;
    NintendoAccountNnidLinker                               :: 9;
    LicenseRequirementsForNetworkService                    :: 10;
    LicenseRequirementsForNetworkServiceWithUserContextImpl :: 11;
    UserCreatorForImmediateNaLoginTest                      :: 12;
    UserQualificationPromoter                               :: 13;
}

/// UI message text to display with ::PselUiMode_UserSelector. Invalid values are handled as ::PselUserSelectionPurpose_General.
PselUserSelectionPurpose :: enum u32 {
    General                :: 0;
    GameCardRegistration   :: 1;
    EShopLaunch            :: 2;
    EShopItemShow          :: 3;
    PicturePost            :: 4;
    NintendoAccountLinkage :: 5;
    SettingsUpdate         :: 6;
    SaveDataDeletion       :: 7;
    UserMigration          :: 8;
    SaveDataTransfer       :: 9;
}

/// NintendoAccountStartupDialogType
PselNintendoAccountStartupDialogType :: enum u32 {
    LoginAndCreate :: 0;
    Login          :: 1;
    Create         :: 2;
}

/// Base UI settings for playerSelect.
PselUiSettingsV1 :: struct {
    mode:                                u32; ///< \ref PselUiMode
    pad:                                 u32; ///< Padding.
    invalid_uid_list:                    [8] AccountUid; ///< List of \ref AccountUid. TODO: This is only correct for ::PselUiMode_UserSelector, for other modes this is a single uid, followed by mode-specific data (if any).
    application_id:                      u64; ///< ApplicationId with \ref pselShowUserSelectorForLauncher.
    is_network_service_account_required: u8; ///< PselUserSelectionSettings::is_network_service_account_required.
    is_skip_enabled:                     u8; ///< PselUserSelectionSettings::is_skip_enabled
    unk_x92:                             u8; ///< Set to value 1 by \ref pselShowUserSelectorForSystem / \ref pselShowUserSelectorForLauncher.
    is_permitted:                        u8; ///< isPermitted. With ::PselUiMode_UserSelector: enables the option to create a new user. Set to the output from \ref accountIsUserRegistrationRequestPermitted with pselShowUserSelector*. When not set, a dialog will be displayed when the user attempts to create an user.
    show_skip_button:                    u8; ///< PselUserSelectionSettings::show_skip_button
    additional_select:                   u8; ///< PselUserSelectionSettings::additional_select
    unk_x96:                             u8; ///< [2.0.0+] Set to PselUserSelectionSettingsForSystemService::enable_user_creation_button. \ref pselShowUserSelectorForLauncher / \ref pselShowUserSelector sets this to value 1.
    unk_x97:                             u8; ///< [6.0.0+] Set to PselUserSelectionSettings::is_unqualified_user_selectable ^ 1.
}

/// UI settings for versions starting with 0x10000.
PselUiSettings :: struct {
    settings: PselUiSettingsV1; ///< \ref PselUiSettingsV1
    unk_x98:  u32; ///< [2.0.0+] Set to PselUserSelectionSettingsForSystemService::purpose.
    unk_x9c:  [4] u8; ///< Unknown.
}

/// UserSelectionSettings
PselUserSelectionSettings :: struct {
    invalid_uid_list:                    [8] AccountUid; ///< invalidUidList.
    is_skip_enabled:                     u8; ///< isSkipEnabled. When set, the first user in invalid_uid_list must not be set, and additional_select must be 0. When enabled \ref accountTrySelectUserWithoutInteraction will be used to select the user, in this case the applet will only be launched if \ref accountTrySelectUserWithoutInteraction doesn't return an user.
    is_network_service_account_required: u8; ///< isNetworkServiceAccountRequired. Whether the user needs to be linked to a Nintendo account.
    show_skip_button:                    u8; ///< showSkipButton. Enables the option to skip user selection with a button.
    additional_select:                   u8; ///< additionalSelect.
    is_unqualified_user_selectable:      u8; ///< [6.0.0+] isUnqualifiedUserSelectable
}

/// [2.0.0+] UserSelectionSettingsForSystemService
PselUserSelectionSettingsForSystemService :: struct {
    purpose:                     u32; ///< \ref PselUserSelectionPurpose
    enable_user_creation_button: u8; ///< Enables the user-creation button when set. Whether user-creation when pressing the button is actually allowed is controlled by PselUiSettingsV1::is_permitted.
    pad:                         [3] u8; ///< Padding.
}

/// Return data sent after execution.
PselUiReturnArg :: struct {
    res:     Result; ///< Result.
    user_id: AccountUid; ///< Selected \ref AccountUid.
}

/**
* @brief Creates a new UI config for the playerSelect applet with the specified mode.
* @param ui PseluiSettings struct.
* @param mode playerSelect UI mode.
*/
pselUiCreate :: (ui: *PselUiSettings, mode: PselUiMode) -> Result #foreign libnx;

/**
* @brief Adds an user to the user list of the applet.
* @param ui PselUiSettings struct.
* @param[in] user_id user ID.
* @note The users will be treated as invalid users for user selection mode, and as the input user for other modes.
*/
pselUiAddUser :: (ui: *PselUiSettings, user_id: AccountUid) -> void #foreign libnx;

/**
* @brief Shows the applet with the specified UI settings.
* @param ui PselUiSettings struct.
* @param out_user Selected user ID.
* @note If user skips (see \ref pselUiSetSkipEnabled) this will return successfully but the output ID will be 0.
*/
pselUiShow :: (ui: *PselUiSettings, out_user: *AccountUid) -> Result #foreign libnx;

/**
* @brief This is the System version of \ref pselShowUserSelector.
* @note This uses \ref accountIsUserRegistrationRequestPermitted, hence \ref accountInitialize must be used prior to this. See also the docs for PselUserSelectionSettings::is_skip_enabled.
* @param[out] out_user Returned selected user ID.
* @param[in] settings \ref PselUserSelectionSettings
* @param[in] settings_system [2.0.0+] \ref PselUserSelectionSettingsForSystemService, ignored on prior versions.
*/
pselShowUserSelectorForSystem :: (out_user: *AccountUid, settings: *PselUserSelectionSettings, settings_system: *PselUserSelectionSettingsForSystemService) -> Result #foreign libnx;

/**
* @brief This is the Launcher version of \ref pselShowUserSelector.
* @note This uses \ref accountIsUserRegistrationRequestPermitted, hence \ref accountInitialize must be used prior to this. See also the docs for PselUserSelectionSettings::is_skip_enabled.
* @param[out] out_user Returned selected user ID.
* @param[in] settings \ref PselUserSelectionSettings
* @param[in] application_id ApplicationId
*/
pselShowUserSelectorForLauncher :: (out_user: *AccountUid, settings: *PselUserSelectionSettings, application_id: u64) -> Result #foreign libnx;

/**
* @brief Shows the applet to select a user.
* @note This uses \ref accountIsUserRegistrationRequestPermitted, hence \ref accountInitialize must be used prior to this. See also the docs for PselUserSelectionSettings::is_skip_enabled.
* @param[out] out_user Returned selected user ID.
* @param[in] settings \ref PselUserSelectionSettings
*/
pselShowUserSelector :: (out_user: *AccountUid, settings: *PselUserSelectionSettings) -> Result #foreign libnx;

/**
* @brief Shows the applet to create a user.
* @note This uses \ref accountIsUserRegistrationRequestPermitted, hence \ref accountInitialize must be used prior to this. If the output flag is 0, an error will be thrown.
*/
pselShowUserCreator :: () -> Result #foreign libnx;

/**
* @brief Shows the applet to change a user's icon.
* @param[in] user Input user ID.
*/
pselShowUserIconEditor :: (user: AccountUid) -> Result #foreign libnx;

/**
* @brief Shows the applet to change a user's nickname.
* @param[in] user Input user ID.
*/
pselShowUserNicknameEditor :: (user: AccountUid) -> Result #foreign libnx;

/**
* @brief Shows the applet to create a user. Used by the starter applet during system setup.
*/
pselShowUserCreatorForStarter :: () -> Result #foreign libnx;

/**
* @brief Shows the applet for Nintendo Account Nnid linking.
* @note Only available on [6.0.0+].
* @param[in] user Input user ID.
*/
pselShowNintendoAccountNnidLinker :: (user: AccountUid) -> Result #foreign libnx;

/**
* @brief Shows the applet for UserQualificationPromoter.
* @note Only available on [13.0.0+].
* @param[in] user Input user ID.
*/
pselShowUserQualificationPromoter :: (user: AccountUid) -> Result #foreign libnx;

/// Output result returned by \ref SwkbdTextCheckCb.
SwkbdTextCheckResult :: enum u32 {
    OK     :: 0;
    Bad    :: 1;
    Prompt :: 2;
    Silent :: 3;
}

/// Type of keyboard.
SwkbdType :: enum u32 {
    Normal   :: 0;
    NumPad   :: 1;
    QWERTY   :: 2;
    Unknown3 :: 3;
    Latin    :: 4;
    ZhHans   :: 5;
    ZhHant   :: 6;
    Korean   :: 7;
    All      :: 8;
    Unknown9 :: 9;
}

/// Bitmask for SwkbdArgCommon::keySetDisableBitmask. This disables keys on the keyboard when the corresponding bit(s) are set.
SwkbdKeyDisableBitmask :: enum u32 {
    Space        :: 2;
    At           :: 4;
    Percent      :: 8;
    ForwardSlash :: 16;
    Backslash    :: 32;
    Numbers      :: 64;
    DownloadCode :: 128;
    UserName     :: 256;
}

/// Value for SwkbdArgCommon::textDrawType. Only applies when stringLenMax is 1..32, otherwise swkbd will only use SwkbdTextDrawType_Box.
SwkbdTextDrawType :: enum u32 {
    Line         :: 0;
    Box          :: 1;
    DownloadCode :: 2;
}

/// SwkbdInline Interactive input storage request ID.
SwkbdRequestCommand :: enum u32 {
    Finalize                    :: 4;
    SetUserWordInfo             :: 6;
    SetCustomizeDic             :: 7;
    Calc                        :: 10;
    SetCustomizedDictionaries   :: 11;
    UnsetCustomizedDictionaries :: 12;
    SetChangedStringV2Flag      :: 13;
    SetMovedCursorV2Flag        :: 14;
}

/// SwkbdInline Interactive output storage reply ID.
SwkbdReplyType :: enum u32 {
    FinishedInitialize          :: 0;
    ChangedString               :: 2;
    MovedCursor                 :: 3;
    MovedTab                    :: 4;
    DecidedEnter                :: 5;
    DecidedCancel               :: 6;
    ChangedStringUtf8           :: 7;
    MovedCursorUtf8             :: 8;
    DecidedEnterUtf8            :: 9;
    UnsetCustomizeDic           :: 10;
    ReleasedUserWordInfo        :: 11;
    UnsetCustomizedDictionaries :: 12;
    ChangedStringV2             :: 13;
    MovedCursorV2               :: 14;
    ChangedStringUtf8V2         :: 15;
    MovedCursorUtf8V2           :: 16;
}

/// SwkbdInline State
SwkbdState :: enum u32 {
    Inactive     :: 0;
    Initialized  :: 1;
    Appearing    :: 2;
    Shown        :: 3;
    Disappearing :: 4;
    Unknown5     :: 5;
    Unknown6     :: 6;
}

/// Value for \ref SwkbdInitializeArg mode. Controls the LibAppletMode when launching the applet.
SwkbdInlineMode :: enum u32 {
    UserDisplay   :: 0;
    AppletDisplay :: 1;
}

/// TextCheck callback set by \ref swkbdConfigSetTextCheckCallback, for validating the input string when the swkbd ok-button is pressed. This buffer contains an UTF-8 string. This callback should validate the input string, then return a \ref SwkbdTextCheckResult indicating success/failure. On failure, this function must write an error message to the tmp_string buffer, which will then be displayed by swkbd.
SwkbdTextCheckCb :: #type (tmp_string: *u8, tmp_string_size: u64) -> SwkbdTextCheckResult #c_call;

/// User dictionary word.
SwkbdDictWord :: struct {
    unk_x0: [100] u8;
}

/// Input data for SwkbdInline request SetCustomizeDic.
SwkbdCustomizeDicInfo :: struct {
    unk_x0: [112] u8;
}

SwkbdCustomizedDictionarySet :: struct {
    buffer:        *void; ///< 0x1000-byte aligned buffer.
    buffer_size:   u32; ///< 0x1000-byte aligned buffer size.
    entries:       [24] u64 #align 4;
    total_entries: u16;
}

/// Base swkbd arg struct.
SwkbdArgCommon :: struct {
    type:                 SwkbdType; ///< See \ref SwkbdType.
    okButtonText:         [9] u16;
    leftButtonText:       u16;
    rightButtonText:      u16;
    dicFlag:              u8; ///< Enables dictionary usage when non-zero (including the system dictionary).
    pad_x1b:              u8;
    keySetDisableBitmask: u32; ///< See SwkbdKeyDisableBitmask_*.
    initialCursorPos:     u32; ///< Initial cursor position in the string: 0 = start, 1 = end.
    headerText:           [65] u16;
    subText:              [129] u16;
    guideText:            [257] u16;
    pad_x3aa:             u16;
    stringLenMax:         u32; ///< When non-zero, specifies the max string length. When the input is too long, swkbd will stop accepting more input until text is deleted via the B button (Backspace). See also \ref SwkbdTextDrawType.
    stringLenMin:         u32; ///< When non-zero, specifies the min string length. When the input is too short, swkbd will display an icon and disable the ok-button.
    passwordFlag:         u32; ///< Use password: 0 = disable, 1 = enable.
    textDrawType:         SwkbdTextDrawType; ///< See \ref SwkbdTextDrawType.
    returnButtonFlag:     u16; ///< Controls whether the Return button is enabled, for newlines input. 0 = disabled, non-zero = enabled.
    blurBackground:       u8; ///< When enabled with value 1, the background is blurred.
    pad_x3bf:             u8;
    initialStringOffset:  u32;
    initialStringSize:    u32;
    userDicOffset:        u32;
    userDicEntries:       s32;
    textCheckFlag:        u8;
}

SwkbdArgV0 :: struct {
    arg:         SwkbdArgCommon;
    pad_x3d1:    [7] u8;
    textCheckCb: SwkbdTextCheckCb; ///< This really doesn't belong in a struct sent to another process, but official sw does this.
}

/// Arg struct for version 0x30007+.
SwkbdArgV7 :: struct {
    arg:          SwkbdArgV0;
    textGrouping: [8] u32; ///< When set and enabled via \ref SwkbdTextDrawType, controls displayed text grouping (inserts spaces, without affecting output string).
}

/// Arg struct for version 0x6000B+.
SwkbdArgVB :: struct {
    arg:           SwkbdArgCommon;
    pad_x3d1:      [3] u8;
    textGrouping:  [8] u32; ///< Same as SwkbdArgV7::textGrouping.
    entries:       [24] u64; ///< This is SwkbdCustomizedDictionarySet::entries.
    total_entries: u8; ///< This is SwkbdCustomizedDictionarySet::total_entries.
    unkFlag:       u8; ///< [8.0.0+]
    pad_x4b6:      [13] u8;
    trigger:       u8; ///< [8.0.0+]
    pad_x4c4:      [4] u8;
}

SwkbdConfig :: struct {
    arg:                     SwkbdArgV7;

    workbuf:                 *u8;
    workbuf_size:            u64;
    max_dictwords:           s32;

    customizedDictionarySet: SwkbdCustomizedDictionarySet #align 4;

    unkFlag:                 u8;
    trigger:                 u8;

    version:                 u32;
}

/// Rect
SwkbdRect :: struct {
    x:      s16; ///< X
    y:      s16; ///< Y
    width:  s16; ///< Width
    height: s16; ///< Height
}

/// InitializeArg for SwkbdInline.
SwkbdInitializeArg :: struct {
    unk_x0: u32;
    mode:   u8; ///< See \ref SwkbdInlineMode. (u8 bool)
    unk_x5: u8; ///< Only set on [5.0.0+].
    pad:    [2] u8;
}

SwkbdAppearArg :: struct {
    type:                 SwkbdType; ///< See \ref SwkbdType.
    okButtonText:         [9] u16;
    leftButtonText:       u16;
    rightButtonText:      u16;
    dicFlag:              u8; ///< Enables dictionary usage when non-zero (including the system dictionary).
    unk_x1b:              u8;
    keySetDisableBitmask: u32; ///< See SwkbdKeyDisableBitmask_*.
    stringLenMax:         s32; ///< When non-negative and non-zero, specifies the max string length. When the input is too long, swkbd will stop accepting more input until text is deleted via the B button (Backspace).
    stringLenMin:         s32; ///< When non-negative and non-zero, specifies the min string length. When the input is too short, swkbd will display an icon and disable the ok-button.
    returnButtonFlag:     u8; ///< Controls whether the Return button is enabled, for newlines input. 0 = disabled, non-zero = enabled.
    unk_x29:              u8; ///< [10.0.0+] When value 1-2, \ref swkbdInlineAppear / \ref swkbdInlineAppearEx will set keytopAsFloating=0 and footerScalable=1.
    unk_x2a:              u8;
    unk_x2b:              u8;
    flags:                u32; ///< Bitmask 0x4: unknown.
    unk_x30:              u8;
    unk_x31:              [23] u8;
}

SwkbdInlineCalcArg :: struct {
    unk_x0:                  u32;
    size:                    u16; ///< Size of this struct.
    unk_x6:                  u8;
    unk_x7:                  u8;
    flags:                   u64;
    initArg:                 SwkbdInitializeArg; ///< Flags bitmask 0x1.
    volume:                  float; ///< Flags bitmask 0x2.
    cursorPos:               s32; ///< Flags bitmask 0x10.
    appearArg:               SwkbdAppearArg;
    inputText:               [506] u16; ///< Flags bitmask 0x8.
    utf8Mode:                u8; ///< Flags bitmask 0x20.
    unk_x45d:                u8;
    enableBackspace:         u8; ///< Flags bitmask 0x8000. Only available with [5.0.0+].
    unk_x45f:                [3] u8;
    keytopAsFloating:        u8; ///< Flags bitmask 0x200.
    footerScalable:          u8; ///< Flags bitmask 0x100.
    alphaEnabledInInputMode: u8; ///< Flags bitmask 0x100.
    inputModeFadeType:       u8; ///< Flags bitmask 0x100.
    disableTouch:            u8; ///< Flags bitmask 0x200.
    disableHardwareKeyboard: u8; ///< Flags bitmask 0x800.
    unk_x468:                [5] u8;
    unk_x46d:                u8;
    unk_x46e:                u8;
    unk_x46f:                u8;
    keytopScaleX:            float; ///< Flags bitmask 0x200.
    keytopScaleY:            float; ///< Flags bitmask 0x200.
    keytopTranslateX:        float; ///< Flags bitmask 0x200.
    keytopTranslateY:        float; ///< Flags bitmask 0x200.
    keytopBgAlpha:           float; ///< Flags bitmask 0x100.
    footerBgAlpha:           float; ///< Flags bitmask 0x100.
    balloonScale:            float; ///< Flags bitmask 0x200.
    unk_x48c:                float;
    unk_x490:                [12] u8;
    seGroup:                 u8; ///< Flags bitmask: enable=0x2000, disable=0x4000. Only available with [5.0.0+].
    triggerFlag:             u8; ///< [6.0.0+] Enables using the trigger field when set.
    trigger:                 u8; ///< [6.0.0+] Trigger
    pad_x49f:                u8;
}

/// Struct data for SwkbdInline Interactive reply storage ChangedString*, at the end following the string.
SwkbdChangedStringArg :: struct {
    stringLen:         u32; ///< String length in characters, without NUL-terminator.
    dicStartCursorPos: s32; ///< Starting cursorPos for the current dictionary word in the current text string. -1 for none.
    dicEndCursorPos:   s32; ///< Ending cursorPos for the current dictionary word in the current text string. -1 for none.
    cursorPos:         s32; ///< Cursor position.
}

/// Struct data for SwkbdInline Interactive reply storage MovedCursor*, at the end following the string.
SwkbdMovedCursorArg :: struct {
    stringLen: u32; ///< String length in characters, without NUL-terminator.
    cursorPos: s32; ///< Cursor position.
}

/// Struct data for SwkbdInline Interactive reply storage MovedTab*, at the end following the string.
SwkbdMovedTabArg :: struct {
    unk_x0: u32;
    unk_x4: u32;
}

/// Struct data for SwkbdInline Interactive reply storage DecidedEnter*, at the end following the string.
SwkbdDecidedEnterArg :: struct {
    stringLen: u32; ///< String length in characters, without NUL-terminator.
}

/// This callback is used by \ref swkbdInlineUpdate when handling ChangedString* replies (text changed by the user or by \ref swkbdInlineSetInputText).
/// str is the UTF-8 string for the current text.
SwkbdChangedStringCb :: #type (str: *u8, arg: *SwkbdChangedStringArg) -> void #c_call;

/// This callback is used by \ref swkbdInlineUpdate when handling ChangedString*V2 replies (text changed by the user or by \ref swkbdInlineSetInputText).
/// str is the UTF-8 string for the current text.
SwkbdChangedStringV2Cb :: #type (str: *u8, arg: *SwkbdChangedStringArg, flag: bool) -> void #c_call;

/// This callback is used by \ref swkbdInlineUpdate when handling MovedCursor* replies.
/// str is the UTF-8 string for the current text.
SwkbdMovedCursorCb :: #type (str: *u8, arg: *SwkbdMovedCursorArg) -> void #c_call;

/// This callback is used by \ref swkbdInlineUpdate when handling MovedCursor*V2 replies.
/// str is the UTF-8 string for the current text.
SwkbdMovedCursorV2Cb :: #type (str: *u8, arg: *SwkbdMovedCursorArg, flag: bool) -> void #c_call;

/// This callback is used by \ref swkbdInlineUpdate when handling MovedTab* replies.
/// str is the UTF-8 string for the current text.
SwkbdMovedTabCb :: #type (str: *u8, arg: *SwkbdMovedTabArg) -> void #c_call;

/// This callback is used by \ref swkbdInlineUpdate when handling DecidedEnter* replies (when the final text was submitted via the button).
/// str is the UTF-8 string for the current text.
SwkbdDecidedEnterCb :: #type (str: *u8, arg: *SwkbdDecidedEnterArg) -> void #c_call;

/// InlineKeyboard
SwkbdInline :: struct {
    version:                           u32;
    holder:                            AppletHolder;
    calcArg:                           SwkbdInlineCalcArg;
    directionalButtonAssignFlag:       bool;
    state:                             SwkbdState;

    dicCustomInitialized:              bool;
    customizedDictionariesInitialized: bool;
    dicStorage:                        AppletStorage;

    wordInfoInitialized:               bool;
    wordInfoStorage:                   AppletStorage;

    interactive_tmpbuf:                *u8;
    interactive_tmpbuf_size:           u64;
    interactive_strbuf:                *u8;
    interactive_strbuf_size:           u64;

    finishedInitializeCb:              VoidFn;
    decidedCancelCb:                   VoidFn;
    changedStringCb:                   SwkbdChangedStringCb;
    changedStringV2Cb:                 SwkbdChangedStringV2Cb;
    movedCursorCb:                     SwkbdMovedCursorCb;
    movedCursorV2Cb:                   SwkbdMovedCursorV2Cb;
    movedTabCb:                        SwkbdMovedTabCb;
    decidedEnterCb:                    SwkbdDecidedEnterCb;
    releasedUserWordInfoCb:            VoidFn;
}

/**
* @brief Creates a SwkbdConfig struct.
* @param c SwkbdConfig struct.
* @param max_dictwords Max \ref SwkbdDictWord entries, 0 for none.
*/
swkbdCreate :: (c: *SwkbdConfig, max_dictwords: s32) -> Result #foreign libnx;

/**
* @brief Closes a SwkbdConfig struct.
* @param c SwkbdConfig struct.
*/
swkbdClose :: (c: *SwkbdConfig) -> void #foreign libnx;

/**
* @brief Clears the args in the SwkbdConfig struct and initializes it with the Default Preset.
* @note Do not use this before \ref swkbdCreate.
* @note Uses the following: swkbdConfigSetType() with \ref SwkbdType_QWERTY, swkbdConfigSetInitialCursorPos() with value 1, swkbdConfigSetReturnButtonFlag() with value 1, and swkbdConfigSetBlurBackground() with value 1. Pre-5.0.0: swkbdConfigSetTextDrawType() with \ref SwkbdTextDrawType_Box.
* @param c SwkbdConfig struct.
*/
swkbdConfigMakePresetDefault :: (c: *SwkbdConfig) -> void #foreign libnx;

/**
* @brief Clears the args in the SwkbdConfig struct and initializes it with the Password Preset.
* @note Do not use this before \ref swkbdCreate.
* @note Uses the following: swkbdConfigSetType() with \ref SwkbdType_QWERTY, swkbdConfigSetInitialCursorPos() with value 1, swkbdConfigSetPasswordFlag() with value 1, and swkbdConfigSetBlurBackground() with value 1.
* @param c SwkbdConfig struct.
*/
swkbdConfigMakePresetPassword :: (c: *SwkbdConfig) -> void #foreign libnx;

/**
* @brief Clears the args in the SwkbdConfig struct and initializes it with the UserName Preset.
* @note Do not use this before \ref swkbdCreate.
* @note Uses the following: swkbdConfigSetType() with \ref SwkbdType_Normal, swkbdConfigSetKeySetDisableBitmask() with SwkbdKeyDisableBitmask_UserName, swkbdConfigSetInitialCursorPos() with value 1, and swkbdConfigSetBlurBackground() with value 1.
* @param c SwkbdConfig struct.
*/
swkbdConfigMakePresetUserName :: (c: *SwkbdConfig) -> void #foreign libnx;

/**
* @brief Clears the args in the SwkbdConfig struct and initializes it with the DownloadCode Preset.
* @note Do not use this before \ref swkbdCreate.
* @note Uses the following: swkbdConfigSetType() with \ref SwkbdType_Normal (\ref SwkbdType_QWERTY on [5.0.0+]), swkbdConfigSetKeySetDisableBitmask() with SwkbdKeyDisableBitmask_DownloadCode, swkbdConfigSetInitialCursorPos() with value 1, and swkbdConfigSetBlurBackground() with value 1. [5.0.0+]: swkbdConfigSetStringLenMax() with value 16, swkbdConfigSetStringLenMin() with value 1, and swkbdConfigSetTextDrawType() with SwkbdTextDrawType_DownloadCode. Uses swkbdConfigSetTextGrouping() for [0-2] with: 0x3, 0x7, and 0xb.
* @param c SwkbdConfig struct.
*/
swkbdConfigMakePresetDownloadCode :: (c: *SwkbdConfig) -> void #foreign libnx;

/**
* @brief Sets the Ok button text. The default is "".
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetOkButtonText :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the LeftOptionalSymbolKey, for \ref SwkbdType_NumPad. The default is "".
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetLeftOptionalSymbolKey :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the RightOptionalSymbolKey, for \ref SwkbdType_NumPad. The default is "".
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetRightOptionalSymbolKey :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the Header text. The default is "".
* @note See SwkbdArgCommon::stringLenMax.
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetHeaderText :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the Sub text. The default is "".
* @note See SwkbdArgCommon::stringLenMax.
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetSubText :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the Guide text. The default is "".
* @note The swkbd applet only displays this when the current displayed cursor position is 0.
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetGuideText :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the Initial text. The default is "".
* @param c SwkbdConfig struct.
* @param str UTF-8 input string.
*/
swkbdConfigSetInitialText :: (c: *SwkbdConfig, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the user dictionary.
* @param c SwkbdConfig struct.
* @param input Input data.
* @param entries Total entries in the buffer.
*/
swkbdConfigSetDictionary :: (c: *SwkbdConfig, input: *SwkbdDictWord, entries: s32) -> void #foreign libnx;

/**
* @brief Sets the CustomizedDictionaries.
* @note Only available on [6.0.0+].
* @param c SwkbdConfig struct.
* @param dic Input \ref SwkbdCustomizedDictionarySet
*/
swkbdConfigSetCustomizedDictionaries :: (c: *SwkbdConfig, dic: *SwkbdCustomizedDictionarySet) -> Result #foreign libnx;

/**
* @brief Sets the TextCheck callback.
* @param c SwkbdConfig struct.
* @param cb \ref SwkbdTextCheckCb callback.
*/
swkbdConfigSetTextCheckCallback :: (c: *SwkbdConfig, cb: SwkbdTextCheckCb) -> void #foreign libnx;

/**
* @brief Launch swkbd with the specified config. This will return once swkbd is finished running.
* @note The string buffer is also used for the buffer passed to the \ref SwkbdTextCheckCb, when it's set. Hence, in that case this buffer should be large enough to handle TextCheck string input/output. The size passed to the callback is the same size passed here, -1.
* @param c SwkbdConfig struct.
* @param out_string UTF-8 Output string buffer.
* @param out_string_size UTF-8 Output string buffer size, including NUL-terminator.
*/
swkbdShow :: (c: *SwkbdConfig, out_string: *u8, out_string_size: u64) -> Result #foreign libnx;

/**
* @brief Creates a SwkbdInline object. Only available on [2.0.0+].
* @note This is essentially an asynchronous version of the regular swkbd.
* @note This calls \ref swkbdInlineSetUtf8Mode internally with flag=true.
* @param s SwkbdInline object.
*/
swkbdInlineCreate :: (s: *SwkbdInline) -> Result #foreign libnx;

/**
* @brief Closes a SwkbdInline object. If the applet is running, this will tell the applet to exit, then wait for the applet to exit + applet exit handling.
* @param s SwkbdInline object.
*/
swkbdInlineClose :: (s: *SwkbdInline) -> Result #foreign libnx;

/**
* @brief Does setup for \ref SwkbdInitializeArg and launches the applet with the SwkbdInline object.
* @note The initArg is cleared, and on [5.0.0+] unk_x5 is set to 1.
* @param s SwkbdInline object.
*/
swkbdInlineLaunch :: (s: *SwkbdInline) -> Result #foreign libnx;

/**
* @brief Same as \ref swkbdInlineLaunch, except mode and unk_x5 for \ref SwkbdInitializeArg are set to the input params.
* @param s SwkbdInline object.
* @param mode Value for SwkbdInitializeArg::mode.
* @param unk_x5 Value for SwkbdInitializeArg::unk_x5.
*/
swkbdInlineLaunchForLibraryApplet :: (s: *SwkbdInline, mode: u8, unk_x5: u8) -> Result #foreign libnx;

/**
* @brief GetImageMemoryRequirement
* @note Wrapper for \ref viGetIndirectLayerImageRequiredMemoryInfo.
* @param[out] out_size Output size.
* @param[out] out_alignment Output alignment.
*/
swkbdInlineGetImageMemoryRequirement :: (out_size: *u64, out_alignment: *u64) -> Result #foreign libnx;

/**
* @brief GetImage
* @note Only available with ::SwkbdInlineMode_UserDisplay.
* @note For width/height, see \ref swkbdInlineGetWindowSize.
* @param s SwkbdInline object.
* @param[out] buffer Output RGBA8 image buffer, this must use the alignment from \ref swkbdInlineGetImageMemoryRequirement.
* @param[in] size Output buffer size, this must match the size from \ref swkbdInlineGetImageMemoryRequirement.
* @param[out] data_available Whether data is available.
*/
swkbdInlineGetImage :: (s: *SwkbdInline, buffer: *void, size: u64, data_available: *bool) -> Result #foreign libnx;

/**
* @brief Gets the image max height, relative to the bottom of the screen.
* @param s SwkbdInline object.
*/
swkbdInlineGetMaxHeight :: (s: *SwkbdInline) -> s32 #foreign libnx;

/**
* @brief Gets the MiniaturizedHeight, relative to the bottom of the screen.
* @param s SwkbdInline object.
*/
swkbdInlineGetMiniaturizedHeight :: (s: *SwkbdInline) -> s32 #foreign libnx;

/**
* @brief GetTouchRectangles. Returns number of valid Rects: 1 for only keytop, 2 for keytop/footer.
* @param s SwkbdInline object.
* @param[out] keytop \ref SwkbdRect for keytop. Optional, can be NULL.
* @param[out] footer \ref SwkbdRect for footer. Optional, can be NULL.
*/
swkbdInlineGetTouchRectangles :: (s: *SwkbdInline, keytop: *SwkbdRect, footer: *SwkbdRect) -> s32 #foreign libnx;

/**
* @brief Gets whether the input x/y are within the output from \ref swkbdInlineGetTouchRectangles.
* @param s SwkbdInline object.
* @param[out] x X
* @param[out] y Y
*/
swkbdInlineIsUsedTouchPointByKeyboard :: (s: *SwkbdInline, x: s32, y: s32) -> bool #foreign libnx;

/**
* @brief Handles updating SwkbdInline state, this should be called periodically.
* @note Handles applet exit if needed, and also sends the \ref SwkbdInlineCalcArg to the applet if needed. Hence, this should be called at some point after writing to \ref SwkbdInlineCalcArg.
* @note Handles applet Interactive storage output when needed.
* @param s SwkbdInline object.
* @param out_state Optional output \ref SwkbdState.
*/
swkbdInlineUpdate :: (s: *SwkbdInline, out_state: *SwkbdState) -> Result #foreign libnx;

/**
* @brief Sets the FinishedInitialize callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @param s SwkbdInline object.
* @param cb Callback
*/
swkbdInlineSetFinishedInitializeCallback :: (s: *SwkbdInline, cb: VoidFn) -> void #foreign libnx;

/**
* @brief Sets the DecidedCancel callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @param s SwkbdInline object.
* @param cb Callback
*/
swkbdInlineSetDecidedCancelCallback :: (s: *SwkbdInline, cb: VoidFn) -> void #foreign libnx;

/**
* @brief Sets the ChangedString callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @note This clears the callback set by \ref swkbdInlineSetChangedStringV2Callback.
* @note This should be called after \ref swkbdInlineLaunch / \ref swkbdInlineLaunchForLibraryApplet.
* @param s SwkbdInline object.
* @param cb \ref SwkbdChangedStringCb Callback
*/
swkbdInlineSetChangedStringCallback :: (s: *SwkbdInline, cb: SwkbdChangedStringCb) -> void #foreign libnx;

/**
* @brief Sets the ChangedStringV2 callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @note Only available with [8.0.0+].
* @note This must be called after \ref swkbdInlineLaunch / \ref swkbdInlineLaunchForLibraryApplet.
* @param s SwkbdInline object.
* @param cb \ref SwkbdChangedStringV2Cb Callback
*/
swkbdInlineSetChangedStringV2Callback :: (s: *SwkbdInline, cb: SwkbdChangedStringV2Cb) -> void #foreign libnx;

/**
* @brief Sets the MovedCursor callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @note This clears the callback set by \ref swkbdInlineSetMovedCursorV2Callback.
* @note This should be called after \ref swkbdInlineLaunch / \ref swkbdInlineLaunchForLibraryApplet.
* @param s SwkbdInline object.
* @param cb \ref SwkbdMovedCursorCb Callback
*/
swkbdInlineSetMovedCursorCallback :: (s: *SwkbdInline, cb: SwkbdMovedCursorCb) -> void #foreign libnx;

/**
* @brief Sets the MovedCursorV2 callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @note Only available with [8.0.0+].
* @note This must be called after \ref swkbdInlineLaunch / \ref swkbdInlineLaunchForLibraryApplet.
* @param s SwkbdInline object.
* @param cb \ref SwkbdMovedCursorV2Cb Callback
*/
swkbdInlineSetMovedCursorV2Callback :: (s: *SwkbdInline, cb: SwkbdMovedCursorV2Cb) -> void #foreign libnx;

/**
* @brief Sets the MovedTab callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @param s SwkbdInline object.
* @param cb \ref SwkbdMovedTabCb Callback
*/
swkbdInlineSetMovedTabCallback :: (s: *SwkbdInline, cb: SwkbdMovedTabCb) -> void #foreign libnx;

/**
* @brief Sets the DecidedEnter callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @param s SwkbdInline object.
* @param cb \ref SwkbdDecidedEnterCb Callback
*/
swkbdInlineSetDecidedEnterCallback :: (s: *SwkbdInline, cb: SwkbdDecidedEnterCb) -> void #foreign libnx;

/**
* @brief Sets the ReleasedUserWordInfo callback, used by \ref swkbdInlineUpdate. The default is NULL for none.
* @param s SwkbdInline object.
* @param cb Callback
*/
swkbdInlineSetReleasedUserWordInfoCallback :: (s: *SwkbdInline, cb: VoidFn) -> void #foreign libnx;

/**
* @brief Appear the kbd and set \ref SwkbdAppearArg.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Wrapper for \ref swkbdInlineAppearEx, with trigger=0.
* @param s SwkbdInline object.
* @param arg Input SwkbdAppearArg.
*/
swkbdInlineAppear :: (s: *SwkbdInline, arg: *SwkbdAppearArg) -> void #foreign libnx;

/**
* @brief Appear the kbd and set \ref SwkbdAppearArg.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param arg Input SwkbdAppearArg.
* @param trigger Trigger, default is 0. Requires [6.0.0+], on eariler versions this will always use value 0 internally.
*/
swkbdInlineAppearEx :: (s: *SwkbdInline, arg: *SwkbdAppearArg, trigger: u8) -> void #foreign libnx;

/**
* @brief Disappear the kbd.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
*/
swkbdInlineDisappear :: (s: *SwkbdInline) -> void #foreign libnx;

/**
* @brief Creates a \ref SwkbdAppearArg which can then be passed to \ref swkbdInlineAppear. arg is initialized with the defaults, with type being set to the input type.
* @param arg Output \ref SwkbdAppearArg.
* @param type \ref SwkbdType type
*/
swkbdInlineMakeAppearArg :: (arg: *SwkbdAppearArg, type: SwkbdType) -> void #foreign libnx;

/**
* @brief Sets okButtonText for the specified SwkbdAppearArg, which was previously initialized with \ref swkbdInlineMakeAppearArg.
* @param arg \ref SwkbdAppearArg
* @param str Input UTF-8 string for the Ok button text, this can be empty/NULL to use the default.
*/
swkbdInlineAppearArgSetOkButtonText :: (arg: *SwkbdAppearArg, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the LeftButtonText, for \ref SwkbdType_NumPad. The default is "". Equivalent to \ref swkbdConfigSetLeftOptionalSymbolKey.
* @param arg \ref SwkbdAppearArg, previously initialized by \ref swkbdInlineMakeAppearArg.
* @param str UTF-8 input string.
*/
swkbdInlineAppearArgSetLeftButtonText :: (arg: *SwkbdAppearArg, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the RightButtonText, for \ref SwkbdType_NumPad. The default is "". Equivalent to \ref swkbdConfigSetRightOptionalSymbolKey.
* @param arg \ref SwkbdAppearArg, previously initialized by \ref swkbdInlineMakeAppearArg.
* @param str UTF-8 input string.
*/
swkbdInlineAppearArgSetRightButtonText :: (arg: *SwkbdAppearArg, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the audio volume.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param volume Volume
*/
swkbdInlineSetVolume :: (s: *SwkbdInline, volume: float) -> void #foreign libnx;

/**
* @brief Sets the current input text string. Overrides the entire user input string if the user previously entered any text.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note This will not affect the cursor position, see \ref swkbdInlineSetCursorPos for that.
* @param s SwkbdInline object.
* @param str UTF-8 input string.
*/
swkbdInlineSetInputText :: (s: *SwkbdInline, str: *u8) -> void #foreign libnx;

/**
* @brief Sets the cursor character position in the string.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param pos Position
*/
swkbdInlineSetCursorPos :: (s: *SwkbdInline, pos: s32) -> void #foreign libnx;

/**
* @brief Sets the UserWordInfo.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized. Can't be used if this was already used previously.
* @note The specified buffer must not be used after this, until \ref swkbdInlineClose is used.
* @note \ref swkbdInlineUpdate must be called at some point afterwards.
* @note If input==NULL or total_entries==0, this will just call \ref swkbdInlineUnsetUserWordInfo internally.
* @param s SwkbdInline object.
* @param input Input data.
* @param entries Total entries in the buffer.
*/
swkbdInlineSetUserWordInfo :: (s: *SwkbdInline, input: *SwkbdDictWord, entries: s32) -> Result #foreign libnx;

/**
* @brief Request UnsetUserWordInfo.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized.
* @param s SwkbdInline object.
*/
swkbdInlineUnsetUserWordInfo :: (s: *SwkbdInline) -> Result #foreign libnx;

/**
* @brief Sets the utf8Mode.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Automatically used internally by \ref swkbdInlineCreate.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetUtf8Mode :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets the CustomizeDic.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized. Can't be used if this or \ref swkbdInlineSetCustomizedDictionaries was already used previously.
* @note The specified buffer must not be used after this, until \ref swkbdInlineClose is used. However, it will also become available once \ref swkbdInlineUpdate handles SwkbdReplyType_UnsetCustomizeDic internally.
* @param s SwkbdInline object.
* @param buffer 0x1000-byte aligned buffer.
* @param size 0x1000-byte aligned buffer size.
* @param info Input \ref SwkbdCustomizeDicInfo
*/
swkbdInlineSetCustomizeDic :: (s: *SwkbdInline, buffer: *void, size: u64, info: *SwkbdCustomizeDicInfo) -> Result #foreign libnx;

/**
* @brief Request UnsetCustomizeDic.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized.
* @param s SwkbdInline object.
*/
swkbdInlineUnsetCustomizeDic :: (s: *SwkbdInline) -> void #foreign libnx;

/**
* @brief Sets the CustomizedDictionaries.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized. Can't be used if this or \ref swkbdInlineSetCustomizeDic was already used previously.
* @note The specified buffer in dic must not be used after this, until \ref swkbdInlineClose is used. However, it will also become available once \ref swkbdInlineUpdate handles SwkbdReplyType_UnsetCustomizedDictionaries internally.
* @note Only available on [6.0.0+].
* @param s SwkbdInline object.
* @param dic Input \ref SwkbdCustomizedDictionarySet
*/
swkbdInlineSetCustomizedDictionaries :: (s: *SwkbdInline, dic: *SwkbdCustomizedDictionarySet) -> Result #foreign libnx;

/**
* @brief Request UnsetCustomizedDictionaries.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized.
* @note Only available on [6.0.0+].
* @param s SwkbdInline object.
*/
swkbdInlineUnsetCustomizedDictionaries :: (s: *SwkbdInline) -> Result #foreign libnx;

/**
* @brief Sets InputModeFadeType.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param type Type
*/
swkbdInlineSetInputModeFadeType :: (s: *SwkbdInline, type: u8) -> void #foreign libnx;

/**
* @brief Sets AlphaEnabledInInputMode.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetAlphaEnabledInInputMode :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets KeytopBgAlpha.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param alpha Alpha, clamped to range 0.0f..1.0f.
*/
swkbdInlineSetKeytopBgAlpha :: (s: *SwkbdInline, alpha: float) -> void #foreign libnx;

/**
* @brief Sets FooterBgAlpha.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param alpha Alpha, clamped to range 0.0f..1.0f.
*/
swkbdInlineSetFooterBgAlpha :: (s: *SwkbdInline, alpha: float) -> void #foreign libnx;

/**
* @brief Sets gfx scaling. Configures KeytopScale* and BalloonScale based on the input value.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note The BalloonScale is not updated when \ref SwkbdState is above ::SwkbdState_Initialized.
* @param s SwkbdInline object.
* @param scale Scale
*/
swkbdInlineSetKeytopScale :: (s: *SwkbdInline, scale: float) -> void #foreign libnx;

/**
* @brief Sets gfx translation for the displayed swkbd image position.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param x X
* @param y Y
*/
swkbdInlineSetKeytopTranslate :: (s: *SwkbdInline, x: float, y: float) -> void #foreign libnx;

/**
* @brief Sets KeytopAsFloating.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Not available when \ref SwkbdState is above ::SwkbdState_Initialized.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetKeytopAsFloating :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets FooterScalable.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetFooterScalable :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets whether touch is enabled. The default is enabled.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetTouchFlag :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets whether Hardware-keyboard is enabled. The default is enabled.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetHardwareKeyboardFlag :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets whether DirectionalButtonAssign is enabled. The default is disabled.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Only available on [4.0.0+].
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetDirectionalButtonAssignFlag :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/**
* @brief Sets whether the specified SeGroup (sound effect) is enabled. The default is enabled.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect. If called again with a different seGroup, \ref swkbdInlineUpdate must be called prior to calling this again.
* @note Only available on [5.0.0+].
* @param s SwkbdInline object.
* @param seGroup SeGroup
* @param flag Flag
*/
swkbdInlineSetSeGroup :: (s: *SwkbdInline, seGroup: u8, flag: bool) -> void #foreign libnx;

/**
* @brief Sets whether the backspace button is enabled. The default is enabled.
* @note \ref swkbdInlineUpdate must be called at some point afterwards for this to take affect.
* @note Only available on [5.0.0+].
* @param s SwkbdInline object.
* @param flag Flag
*/
swkbdInlineSetBackspaceFlag :: (s: *SwkbdInline, flag: bool) -> void #foreign libnx;

/// This indicates the type of web-applet.
WebShimKind :: enum u32 {
    Shop    :: 1;
    Login   :: 2;
    Offline :: 3;
    Share   :: 4;
    Web     :: 5;
    Wifi    :: 6;
    Lobby   :: 7;
}

/// ExitReason
WebExitReason :: enum u32 {
    ExitButton  :: 0;
    BackButton  :: 1;
    Requested   :: 2;
    LastUrl     :: 3;
    ErrorDialog :: 7;
    UnknownE    :: 14;
}

/// Button values for \ref webConfigSetBootFooterButtonVisible.
WebFooterButtonId :: enum u32 {
    None  :: 0;
    Type1 :: 1;
    Type2 :: 2;
    Type3 :: 3;
    Type4 :: 4;
    Type5 :: 5;
    Type6 :: 6;
    Max   :: 7;
}

/// WebSessionBootMode
WebSessionBootMode :: enum u32 {
    AllForeground                :: 0;
    AllForegroundInitiallyHidden :: 1;
}

/// WebSessionSendMessageKind
WebSessionSendMessageKind :: enum u32 {
    BrowserEngineContent :: 0;
    SystemMessageAppear  :: 256;
    Ack                  :: 4096;
}

/// WebSessionReceiveMessageKind
WebSessionReceiveMessageKind :: enum u32 {
    BrowserEngineContent :: 0;
    AckBrowserEngine     :: 4096;
    AckSystemMessage     :: 4097;
}

/// Struct for the WebWifi applet input storage.
WebWifiPageArg :: struct {
    unk_x0:       u32; ///< Official sw sets this to 0 with appletStorageWrite, separately from the rest of the config struct.
    conntest_url: [256] u8; ///< Connection-test URL.
    initial_url:  [1024] u8; ///< Initial URL navigated to by the applet.
    uuid:         Uuid; ///< NIFM Network UUID. Only used by the applet when conntest_url is set.
    rev:          u32; ///< Input value for nifm cmd SetRequirementByRevision. Only used by the applet when conntest_url is set.
}

/// Struct for the WebWifi applet output storage.
WebWifiReturnValue :: struct {
    unk_x0: u32; ///< Unknown.
    res:    Result; ///< Result
}

/// Config for WebWifi.
WebWifiConfig :: struct {
    arg: WebWifiPageArg; ///< Arg data.
}

/// TLV storage, starts with \ref WebArgHeader followed by \ref WebArgTLV entries.
WebCommonTLVStorage :: struct {
    data: [8192] u8; ///< Raw TLV data storage.
}

/// Common struct for the applet output storage, for non-TLV-storage.
WebCommonReturnValue :: struct {
    exitReason:  WebExitReason; ///< ExitReason
    pad:         u32; ///< Padding
    lastUrl:     [4096] u8; ///< LastUrl string
    lastUrlSize: u64; ///< Size of LastUrl, including NUL-terminator.
}

/// Header struct at offset 0 in the web Arg storage (non-webWifi).
WebArgHeader :: struct {
    total_entries: u16; ///< Total \ref WebArgTLV entries following this struct.
    pad:           u16; ///< Padding
    shimKind:      WebShimKind; ///< ShimKind
}

/// Web TLV used in the web Arg storage.
WebArgTLV :: struct {
    type: u16; ///< Type of this arg.
    size: u16; ///< Size of the arg data following this struct.
    pad:  [4] u8; ///< Padding
}

/// Config struct for web applets, non-WebWifi.
WebCommonConfig :: struct {
    arg:      WebCommonTLVStorage; ///< TLV storage.
    appletid: AppletId; ///< AppletId
    version:  u32; ///< CommonArgs applet version.
    holder:   AppletHolder; ///< AppletHolder
}

/// Common container struct for applets' reply data, from the output storage.
WebCommonReply :: struct {
    type:     bool; ///< Type of reply: false = ret, true = storage.
    shimKind: WebShimKind; ///< ShimKind
    ret:      WebCommonReturnValue; ///< Reply data for reply=false.
    storage:  WebCommonTLVStorage; ///< Reply data for reply=true.
}

/// Entry data for ::WebArgType_BootFooterButton.
WebBootFooterButtonEntry :: struct {
    id:      WebFooterButtonId;
    visible: u8;
    unk_x5:  u16 #align 1;
    unk_x7:  u8;
}

/// StorageHandleQueue
WebSessionStorageHandleQueue :: struct {
    read_pos:     s32;
    write_pos:    s32;
    max_storages: s32;
    is_full:      bool;
    storages:     [16] AppletStorage;
}

/// WebSession
WebSession :: struct {
    mutex:         Mutex;
    config:        *WebCommonConfig;
    queue:         [2] struct {
        count:    u32;
        cur_size: u32;
    };

    storage_queue: WebSessionStorageHandleQueue;
}

/// SessionMessageHeader
WebSessionMessageHeader :: struct {
    kind:     u32; ///< Message Kind (\ref WebSessionSendMessageKind / \ref WebSessionReceiveMessageKind)
    size:     u32; ///< Data size following the header.
    reserved: [8] u8; ///< Unused
}

/// Types for \ref WebArgTLV, input storage.
WebArgType :: enum u32 {
    Url                               :: 1;
    CallbackUrl                       :: 3;
    CallbackableUrl                   :: 4;
    ApplicationId                     :: 5;
    DocumentPath                      :: 6;
    DocumentKind                      :: 7;
    SystemDataId                      :: 8;
    ShareStartPage                    :: 9;
    Whitelist                         :: 10;
    NewsFlag                          :: 11;
    UnknownC                          :: 12;
    UnknownD                          :: 13;
    Uid                               :: 14;
    AlbumEntry0                       :: 15;
    ScreenShot                        :: 16;
    EcClientCert                      :: 17;
    Unknown12                         :: 18;
    PlayReport                        :: 19;
    Unknown14                         :: 20;
    Unknown15                         :: 21;
    BootDisplayKind                   :: 23;
    BackgroundKind                    :: 24;
    Footer                            :: 25;
    Pointer                           :: 26;
    LeftStickMode                     :: 27;
    KeyRepeatFrame0                   :: 28;
    KeyRepeatFrame1                   :: 29;
    BootAsMediaPlayerInverted         :: 30;
    DisplayUrlKind                    :: 31;
    BootAsMediaPlayer                 :: 33;
    ShopJump                          :: 34;
    MediaPlayerUserGestureRestriction :: 35;
    MediaAutoPlay                     :: 35;
    LobbyParameter                    :: 36;
    ApplicationAlbumEntry             :: 38;
    JsExtension                       :: 39;
    AdditionalCommentText             :: 40;
    TouchEnabledOnContents            :: 41;
    UserAgentAdditionalString         :: 42;
    AdditionalMediaData0              :: 43;
    MediaPlayerAutoClose              :: 44;
    PageCache                         :: 45;
    WebAudio                          :: 46;
    _2F                               :: 47;
    YouTubeVideoFlag                  :: 49;
    FooterFixedKind                   :: 50;
    PageFade                          :: 51;
    MediaCreatorApplicationRatingAge  :: 52;
    BootLoadingIcon                   :: 53;
    PageScrollIndicator               :: 54;
    MediaPlayerSpeedControl           :: 55;
    AlbumEntry1                       :: 56;
    AlbumEntry2                       :: 57;
    AlbumEntry3                       :: 58;
    AdditionalMediaData1              :: 59;
    AdditionalMediaData2              :: 60;
    AdditionalMediaData3              :: 61;
    BootFooterButton                  :: 62;
    OverrideWebAudioVolume            :: 63;
    OverrideMediaAudioVolume          :: 64;
    SessionBootMode                   :: 65;
    SessionFlag                       :: 66;
    MediaPlayerUi                     :: 67;
    TransferMemory                    :: 68;
}

/// Types for \ref WebArgTLV, output storage.
WebReplyType :: enum u32 {
    ExitReason                        :: 1;
    LastUrl                           :: 2;
    LastUrlSize                       :: 3;
    SharePostResult                   :: 4;
    PostServiceName                   :: 5;
    PostServiceNameSize               :: 6;
    PostId                            :: 7;
    PostIdSize                        :: 8;
    MediaPlayerAutoClosedByCompletion :: 9;
}

/// This controls the kind of content to mount with Offline-applet.
WebDocumentKind :: enum u32 {
    OfflineHtmlPage             :: 1;
    ApplicationLegalInformation :: 2;
    SystemDataPage              :: 3;
}

/// This controls the initial page for ShareApplet, used by \ref webShareCreate.
WebShareStartPage :: enum u32 {
    Default  :: 0;
    Settings :: 1;
}

/// Kind values for \ref webConfigSetBootDisplayKind. Controls the background color while displaying the loading screen during applet boot. Also controls the BackgroundKind when value is non-zero.
WebBootDisplayKind :: enum u32 {
    Default  :: 0;
    White    :: 1;
    Black    :: 2;
    Unknown3 :: 3;
    Unknown4 :: 4;
}

/// Kind values for \ref webConfigSetBackgroundKind. Controls the background color while displaying the loading screen during applet boot. Only used when \ref WebBootDisplayKind is ::WebBootDisplayKind_Default. If the applet was not launched by an Application, the applet will only use WebBackgroundKind_Default.
WebBackgroundKind :: enum u32 {
    Default  :: 0;
    Unknown1 :: 1;
    Unknown2 :: 2;
}

/// Mode values for \ref webConfigSetLeftStickMode. Controls the initial mode, this can be toggled by the user via the pressing the left-stick button. If the Pointer flag is set to false (\ref webConfigSetPointer), only ::WebLeftStickMode_Cursor will be used and mode toggle by the user is disabled (input value ignored).
WebLeftStickMode :: enum u32 {
    Pointer :: 0;
    Cursor  :: 1;
}

/// Kind values for \ref webConfigSetFooterFixedKind. Controls UI footer display behaviour.
WebFooterFixedKind :: enum u32 {
    Default :: 0;
    Always  :: 1;
    Hidden  :: 2;
}

/**
* @brief Creates the config for WifiWebAuthApplet. This is the captive portal applet.
* @param config WebWifiConfig object.
* @param conntest_url URL used for the connection-test requests. When empty/NULL the applet will test the connection with nifm and throw an error on failure.
* @param initial_url Initial URL navigated to by the applet.
* @param uuid NIFM Network UUID, for nifm cmd SetNetworkProfileId. Value 0 can be used. Only used by the applet when conntest_url is set.
* @param rev Input value for nifm cmd SetRequirementByRevision. Value 0 can be used. Only used by the applet when conntest_url is set.
*/
webWifiCreate :: (config: *WebWifiConfig, conntest_url: *u8, initial_url: *u8, uuid: Uuid, rev: u32) -> void #foreign libnx;

/**
* @brief Launches WifiWebAuthApplet with the specified config and waits for it to exit.
* @param config WebWifiConfig object.
* @param out Optional output applet reply data, can be NULL.
*/
webWifiShow :: (config: *WebWifiConfig, out: *WebWifiReturnValue) -> Result #foreign libnx;

/**
* @brief Creates the config for WebApplet. This applet uses an URL whitelist loaded from the user-process host Application, which is only loaded when running under an Application.
* @note Sets ::WebArgType_UnknownD, and ::WebArgType_Unknown12 on pre-3.0.0, to value 1.
* @param config WebCommonConfig object.
* @param url Initial URL navigated to by the applet.
*/
webPageCreate :: (config: *WebCommonConfig, url: *u8) -> Result #foreign libnx;

/**
* @brief Creates the config for WebApplet. This is based on \ref webPageCreate, for News. Hence other functions referencing \ref webPageCreate also apply to this.
* @note The domain from the input URL is automatically whitelisted, in addition to any already loaded whitelist.
* @note Sets ::WebArgType_UnknownD to value 1, and sets ::WebArgType_NewsFlag to true. Also uses \ref webConfigSetEcClientCert and \ref webConfigSetShopJump with flag=true.
* @param config WebCommonConfig object.
* @param url Initial URL navigated to by the applet.
*/
webNewsCreate :: (config: *WebCommonConfig, url: *u8) -> Result #foreign libnx;

/**
* @brief Creates the config for WebApplet. This is based on \ref webPageCreate, for YouTubeVideo. Hence other functions referencing \ref webPageCreate also apply to this. This uses a whitelist which essentially only allows youtube embed/ URLs (without mounting content from the host Application).
* @note This is only available on [5.0.0+].
* @note Sets ::WebArgType_UnknownD to value 1, and sets ::WebArgType_YouTubeVideoFlag to true. Also uses \ref webConfigSetBootAsMediaPlayer with flag=true.
* @param config WebCommonConfig object.
* @param url Initial URL navigated to by the applet.
*/
webYouTubeVideoCreate :: (config: *WebCommonConfig, url: *u8) -> Result #foreign libnx;

/**
* @brief Creates the config for Offline-applet. This applet uses data loaded from content.
* @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor and sets ::WebArgType_BootAsMediaPlayerInverted to false. Uses \ref webConfigSetPointer with flag = docKind == ::WebDocumentKind_OfflineHtmlPage.
* @note For docKind ::WebDocumentKind_ApplicationLegalInformation / ::WebDocumentKind_SystemDataPage, uses \ref webConfigSetFooter with flag=true and \ref webConfigSetBackgroundKind with ::WebBackgroundKind_Default.
* @note For docKind ::WebDocumentKind_SystemDataPage, uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_White.
* @note Sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. With docKind ::WebDocumentKind_ApplicationLegalInformation, uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_White.
* @note Sets ::WebArgType_UnknownC to value 1.
* @note With docKind ::WebDocumentKind_ApplicationLegalInformation, uses \ref webConfigSetEcClientCert with flag=true.
* @note With docKind ::WebDocumentKind_OfflineHtmlPage on pre-3.0.0, sets ::WebArgType_Unknown12 to value 1.
* @note Lastly, sets the TLVs as needed for the input params.
* @param config WebCommonConfig object.
* @param docKind \ref WebDocumentKind
* @param id Id to load the content from. With docKind = ::WebDocumentKind_OfflineHtmlPage, id=0 should be used to specify the user-process application (non-zero is ignored with this docKind).
* @param docPath Initial document path in RomFS, without the leading '/'. For ::WebDocumentKind_OfflineHtmlPage, this is relative to "html-document/" in RomFS. For the other docKind values, this is relative to "/" in RomFS. This path must contain ".htdocs/".
*/
webOfflineCreate :: (config: *WebCommonConfig, docKind: WebDocumentKind, id: u64, docPath: *u8) -> Result #foreign libnx;

/**
* @brief Creates the config for ShareApplet. This applet is for social media posting/settings.
* @note If a non-zero uid isn't set with \ref webConfigSetUid prior to using \ref webConfigShow, the applet will launch the profile-selector applet to select an account.
* @note An error will be displayed if neither \ref webConfigSetAlbumEntry, nor \ref webConfigSetApplicationAlbumEntry, nor \ref webConfigAddAlbumEntryAndMediaData are used prior to using \ref webConfigShow, with ::WebShareStartPage_Default.
* @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor, \ref webConfigSetUid with uid=0, \ref webConfigSetDisplayUrlKind with kind=true, and sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. Uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_Unknown3.
* @param config WebCommonConfig object.
* @param page \ref WebShareStartPage
*/
webShareCreate :: (config: *WebCommonConfig, page: WebShareStartPage) -> Result #foreign libnx;

/**
* @brief Creates the config for LobbyApplet. This applet is for "Nintendo Switch Online Lounge".
* @note Only available on [2.0.0+].
* @note If a non-zero uid isn't set with \ref webConfigSetUid prior to using \ref webConfigShow, the applet will launch the profile-selector applet to select an account.
* @note Uses \ref webConfigSetLeftStickMode with ::WebLeftStickMode_Cursor, \ref webConfigSetPointer with flag=false on [3.0.0+], \ref webConfigSetUid with uid=0, and sets ::WebArgType_Unknown14/::WebArgType_Unknown15 to value 1. Uses \ref webConfigSetBootDisplayKind with ::WebBootDisplayKind_Unknown4, \ref webConfigSetBackgroundKind with ::WebBackgroundKind_Unknown2, and sets ::WebArgType_BootAsMediaPlayerInverted to false.
* @param config WebCommonConfig object.
*/
webLobbyCreate :: (config: *WebCommonConfig) -> Result #foreign libnx;

/**
* @brief Sets the CallbackUrl. See also \ref webReplyGetLastUrl.
* @note With Offline-applet for LastUrl handling, it compares the domain with "localhost" instead.
* @note Only available with config created by \ref webPageCreate or with Share-applet.
* @param config WebCommonConfig object.
* @param url URL
*/
webConfigSetCallbackUrl :: (config: *WebCommonConfig, url: *u8) -> Result #foreign libnx;

/**
* @brief Sets the CallbackableUrl.
* @note Only available with config created by \ref webPageCreate.
* @param config WebCommonConfig object.
* @param url URL
*/
webConfigSetCallbackableUrl :: (config: *WebCommonConfig, url: *u8) -> Result #foreign libnx;

/**
* @brief Sets the whitelist.
* @note Only available with config created by \ref webPageCreate.
* @note If the whitelist isn't formatted properly, the applet will exit briefly after the applet is launched.
* @param config WebCommonConfig object.
* @param whitelist Whitelist string, each line is a regex for each whitelisted URL.
*/
webConfigSetWhitelist :: (config: *WebCommonConfig, whitelist: *u8) -> Result #foreign libnx;

/**
* @brief Sets the account uid. Controls which user-specific savedata to mount.
* @note Only available with config created by \ref webPageCreate, \ref webLobbyCreate, or with Share-applet.
* @note Used automatically by \ref webShareCreate and \ref webLobbyCreate with uid=0.
* @param config WebCommonConfig object.
* @param uid \ref AccountUid
*/
webConfigSetUid :: (config: *WebCommonConfig, uid: AccountUid) -> Result #foreign libnx;

/**
* @brief Sets the Share CapsAlbumEntry.
* @note Only available with config created by \ref webShareCreate.
* @param config WebCommonConfig object.
* @param entry \ref CapsAlbumEntry
*/
webConfigSetAlbumEntry :: (config: *WebCommonConfig, entry: *CapsAlbumEntry) -> Result #foreign libnx;

/**
* @brief Sets the ScreenShot flag, which controls whether screen-shot capture is allowed.
* @note Only available with config created by \ref webPageCreate.
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetScreenShot :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the EcClientCert flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate.
* @note Used automatically by \ref webOfflineCreate, depending on the docKind.
* @note Used automatically by \ref webNewsCreate with flag=true.
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetEcClientCert :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether PlayReport is enabled.
* @note Only available with config created by \ref webOfflineCreate.
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetPlayReport :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the BootDisplayKind.
* @note Only available with config created by \ref webOfflineCreate, \ref webShareCreate, \ref webPageCreate, or \ref webLobbyCreate..
* @note Used automatically by \ref webOfflineCreate, depending on the docKind.
* @note Used automatically by \ref webShareCreate with kind=::WebBootDisplayKind_Unknown3.
* @note Used automatically by \ref webLobbyCreate with kind=::WebBootDisplayKind_Unknown4.
* @param config WebCommonConfig object.
* @param kind \ref WebBootDisplayKind
*/
webConfigSetBootDisplayKind :: (config: *WebCommonConfig, kind: WebBootDisplayKind) -> Result #foreign libnx;

/**
* @brief Sets the BackgroundKind.
* @note Only available with config created by \ref webOfflineCreate, \ref webPageCreate, or \ref webLobbyCreate.
* @note Used automatically by \ref webOfflineCreate, depending on the docKind.
* @note Used automatically by \ref webLobbyCreate with kind=2.
* @param config WebCommonConfig object.
* @param kind \ref WebBackgroundKind
*/
webConfigSetBackgroundKind :: (config: *WebCommonConfig, kind: WebBackgroundKind) -> Result #foreign libnx;

/**
* @brief Sets the whether the UI footer is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate.
* @note Used automatically by \ref webOfflineCreate, depending on the docKind.
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetFooter :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the whether the Pointer is enabled. See also \ref WebLeftStickMode.
* @note Only available with config created by \ref webOfflineCreate, \ref webPageCreate, or \ref webLobbyCreate.
* @note Used automatically by \ref webOfflineCreate.
* @note Used automatically by \ref webLobbyCreate with flag=false on [3.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetPointer :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the LeftStickMode.
* @note Only available with config created by \ref webOfflineCreate, \ref webShareCreate, \ref webPageCreate, or \ref webLobbyCreate.
* @note Used automatically by \ref webOfflineCreate, \ref webShareCreate, and \ref webLobbyCreate with ::WebLeftStickMode_Cursor.
* @param config WebCommonConfig object.
* @param mode Mode, different enums for Web and Offline.
*/
webConfigSetLeftStickMode :: (config: *WebCommonConfig, mode: WebLeftStickMode) -> Result #foreign libnx;

/**
* @brief Sets the KeyRepeatFrame.
* @note Only available with config created by \ref webOfflineCreate.
* @param config WebCommonConfig object.
* @param inval0 First input param.
* @param inval1 Second input param.
*/
webConfigSetKeyRepeatFrame :: (config: *WebCommonConfig, inval0: s32, inval1: s32) -> Result #foreign libnx;

/**
* @brief Sets the DisplayUrlKind.
* @note Only available with config created by \ref webShareCreate or \ref webPageCreate.
* @param config WebCommonConfig object.
* @note Used automatically by \ref webShareCreate with kind=true.
* @param kind Kind
*/
webConfigSetDisplayUrlKind :: (config: *WebCommonConfig, kind: bool) -> Result #foreign libnx;

/**
* @brief Sets the BootAsMediaPlayer flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [2.0.0+].
* @note With config created by \ref webNewsCreate on [3.0.0+], this also sets ::WebArgType_BootAsMediaPlayerInverted to !flag.
* @param config WebCommonConfig object.
* @param flag Flag. true = BootAsMediaPlayer, false = BootAsWebPage.
*/
webConfigSetBootAsMediaPlayer :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the ShopJump flag.
* @note Only available with config created by \ref webPageCreate on [2.0.0+].
* @note Used automatically by \ref webNewsCreate with flag=true.
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetShopJump :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the MediaPlayerUserGestureRestriction flag.
* @note Only available with config created by \ref webPageCreate on [2.0.0-5.1.0].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetMediaPlayerUserGestureRestriction :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether MediaAutoPlay is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [6.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetMediaAutoPlay :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the LobbyParameter.
* @note Only available with config created by \ref webLobbyCreate.
* @param config WebCommonConfig object.
* @param str String
*/
webConfigSetLobbyParameter :: (config: *WebCommonConfig, str: *u8) -> Result #foreign libnx;

/**
* @brief Sets the Share CapsApplicationAlbumEntry.
* @note Only available with config created by \ref webShareCreate on [3.0.0+].
* @param config WebCommonConfig object.
* @param entry \ref CapsApplicationAlbumEntry, see also capssu.h.
*/
webConfigSetApplicationAlbumEntry :: (config: *WebCommonConfig, entry: *CapsApplicationAlbumEntry) -> Result #foreign libnx;

/**
* @brief Sets whether JsExtension is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [3.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetJsExtension :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the Share AdditionalCommentText.
* @note Only available with config created by \ref webShareCreate on [4.0.0+].
* @param config WebCommonConfig object.
* @param str String
*/
webConfigSetAdditionalCommentText :: (config: *WebCommonConfig, str: *u8) -> Result #foreign libnx;

/**
* @brief Sets the TouchEnabledOnContents flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetTouchEnabledOnContents :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the UserAgentAdditionalString. " " followed by this string are appended to the normal User-Agent string.
* @note Only available with config created by \ref webPageCreate on [4.0.0+].
* @param config WebCommonConfig object.
* @param str String
*/
webConfigSetUserAgentAdditionalString :: (config: *WebCommonConfig, str: *u8) -> Result #foreign libnx;

/**
* @brief Sets the Share AdditionalMediaData.
* @note Only available with config created by \ref webShareCreate on [4.0.0+].
* @param config WebCommonConfig object.
* @param data Input data
* @param size Size of the input data, max size is 0x10.
*/
webConfigSetAdditionalMediaData :: (config: *WebCommonConfig, data: *u8, size: u64) -> Result #foreign libnx;

/**
* @brief Sets the MediaPlayerAutoClose flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetMediaPlayerAutoClose :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether PageCache is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetPageCache :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether WebAudio is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [4.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetWebAudio :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the FooterFixedKind.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
* @param config WebCommonConfig object.
* @param kind \ref WebFooterFixedKind
*/
webConfigSetFooterFixedKind :: (config: *WebCommonConfig, kind: WebFooterFixedKind) -> Result #foreign libnx;

/**
* @brief Sets the PageFade flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetPageFade :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the Share MediaCreatorApplicationRatingAge.
* @note Only available with config created by \ref webShareCreate on [5.0.0+].
* @param config WebCommonConfig object.
* @param data 0x20-byte input data
*/
webConfigSetMediaCreatorApplicationRatingAge :: (config: *WebCommonConfig, data: *s8) -> Result #foreign libnx;

/**
* @brief Sets the BootLoadingIcon flag.
* @note Only available with config created by \ref webOfflineCreate on [5.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetBootLoadingIcon :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets the PageScrollIndicator flag.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [5.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetPageScrollIndicator :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether MediaPlayerSpeedControl is enabled.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [6.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetMediaPlayerSpeedControl :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Adds a pair of Share CapsAlbumEntry + optionally AdditionalMediaData. This can be used up to 4 times, for setting multiple pairs.
* @note Only available with config created by \ref webShareCreate on [6.0.0+].
* @param config WebCommonConfig object.
* @param entry \ref CapsAlbumEntry
* @param data Input data for AdditionalMediaData. Optional, can be NULL.
* @param size Size of the input data, max size is 0x10. Optional, can be 0.
*/
webConfigAddAlbumEntryAndMediaData :: (config: *WebCommonConfig, entry: *CapsAlbumEntry, data: *u8, size: u64) -> Result #foreign libnx;

/**
* @brief Sets whether the specified BootFooterButton is visible.
* @note Only available with config created by \ref webOfflineCreate on [6.0.0+].
* @param config WebCommonConfig object.
* @param button \ref WebFooterButtonId
* @param visible Visible flag.
*/
webConfigSetBootFooterButtonVisible :: (config: *WebCommonConfig, button: WebFooterButtonId, visible: bool) -> Result #foreign libnx;

/**
* @brief Sets OverrideWebAudioVolume.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [6.0.0+].
* @param config WebCommonConfig object.
* @param value Value
*/
webConfigSetOverrideWebAudioVolume :: (config: *WebCommonConfig, value: float) -> Result #foreign libnx;

/**
* @brief Sets OverrideMediaAudioVolume.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [6.0.0+].
* @param config WebCommonConfig object.
* @param value Value
*/
webConfigSetOverrideMediaAudioVolume :: (config: *WebCommonConfig, value: float) -> Result #foreign libnx;

/**
* @brief Sets \ref WebSessionBootMode.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [7.0.0+].
* @param config WebCommonConfig object.
* @param mode \ref WebSessionBootMode
*/
webConfigSetBootMode :: (config: *WebCommonConfig, mode: WebSessionBootMode) -> Result #foreign libnx;

/**
* @brief Sets whether MediaPlayerUi is enabled.
* @note Only available with config created by \ref webOfflineCreate on [8.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetMediaPlayerUi :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Sets whether TransferMemory is enabled.
* @note Only available with config created by \ref webPageCreate on [11.0.0+].
* @param config WebCommonConfig object.
* @param flag Flag
*/
webConfigSetTransferMemory :: (config: *WebCommonConfig, flag: bool) -> Result #foreign libnx;

/**
* @brief Launches the {web applet} with the specified config and waits for it to exit.
* @param config WebCommonConfig object.
* @param out Optional output applet reply data, can be NULL.
*/
webConfigShow :: (config: *WebCommonConfig, out: *WebCommonReply) -> Result #foreign libnx;

/**
* @brief Request the applet to exit after \ref webConfigShow was used, while the applet is still running. This is for use from another thread.
* @param config WebCommonConfig object.
*/
webConfigRequestExit :: (config: *WebCommonConfig) -> Result #foreign libnx;

/**
* @brief Gets the ExitReason from the specified reply.
* @param reply WebCommonReply object.
* @param exitReason Output \ref WebExitReason
*/
webReplyGetExitReason :: (reply: *WebCommonReply, exitReason: *WebExitReason) -> Result #foreign libnx;

/**
* @brief Gets the LastUrl from the specified reply. When the applet loads a page where the beginning of the URL matches the URL from \ref webConfigSetCallbackUrl, the applet will exit and set LastUrl to that URL (exit doesn't occur when \ref webConfigSetCallbackableUrl was used).
* @note This is only available with ::WebExitReason_LastUrl (string is empty otherwise).
* @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
* @param reply WebCommonReply object.
* @param outstr Output string buffer. If NULL, the string is not loaded.
* @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
* @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
*/
webReplyGetLastUrl :: (reply: *WebCommonReply, outstr: *u8, outstr_maxsize: u64, out_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the SharePostResult from the specified reply.
* @note Only available with reply data from ShareApplet on [3.0.0+].
* @param reply WebCommonReply object.
* @param sharePostResult Output sharePostResult
*/
webReplyGetSharePostResult :: (reply: *WebCommonReply, sharePostResult: *u32) -> Result #foreign libnx;

/**
* @brief Gets the PostServiceName from the specified reply.
* @note Only available with reply data from ShareApplet on [3.0.0+].
* @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
* @param reply WebCommonReply object.
* @param outstr Output string buffer. If NULL, the string is not loaded.
* @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
* @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
*/
webReplyGetPostServiceName :: (reply: *WebCommonReply, outstr: *u8, outstr_maxsize: u64, out_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the PostId from the specified reply.
* @note Only available with reply data from ShareApplet on [3.0.0+].
* @note If you want to allocate a string buffer on heap, you can call this with outstr=NULL/outstr_maxsize=0 to get the out_size, then call it again with the allocated buffer.
* @param reply WebCommonReply object.
* @param outstr Output string buffer. If NULL, the string is not loaded.
* @param outstr_maxsize Size of the buffer, including NUL-terminator. If outstr is set, this size must be >1. The size used for the actual string-copy is this size-1, to make sure the output is NUL-terminated (the entire buffer is cleared first).
* @param out_size Output string length including NUL-terminator, for the original input string in the reply loaded from a separate size field.
*/
webReplyGetPostId :: (reply: *WebCommonReply, outstr: *u8, outstr_maxsize: u64, out_size: *u64) -> Result #foreign libnx;

/**
* @brief Gets the MediaPlayerAutoClosedByCompletion flag from the specified reply.
* @note Only available with reply data from Web on [8.0.0+].
* @param reply WebCommonReply object.
* @param flag Output flag
*/
webReplyGetMediaPlayerAutoClosedByCompletion :: (reply: *WebCommonReply, flag: *bool) -> Result #foreign libnx;

/**
* @brief Creates a \ref WebSession object.
* @param s \ref WebSession
* @param config WebCommonConfig object.
*/
webSessionCreate :: (s: *WebSession, config: *WebCommonConfig) -> void #foreign libnx;

/**
* @brief Closes a \ref WebSession object.
* @param s \ref WebSession
*/
webSessionClose :: (s: *WebSession) -> void #foreign libnx;

/**
* @brief Launches the applet for \ref WebSession.
* @note Only available with config created by \ref webOfflineCreate or \ref webPageCreate, on [7.0.0+].
* @note Do not use \ref webConfigShow when using WebSession.
* @param s \ref WebSession
* @param[out] out_event Output Event with autoclear=false, from \ref appletHolderGetExitEvent. Optional, can be NULL.
*/
webSessionStart :: (s: *WebSession, out_event: **Event) -> Result #foreign libnx;

/**
* @brief Waits for the applet to exit.
* @note This must be used before \ref webSessionClose, when \ref webSessionStart was used successfully.
* @param s \ref WebSession
* @param out Optional output applet reply data, can be NULL.
*/
webSessionWaitForExit :: (s: *WebSession, out: *WebCommonReply) -> Result #foreign libnx;

/**
* @brief Request the applet to exit.
* @note Use this instead of \ref webConfigRequestExit, when using WebSession.
* @param s \ref WebSession
*/
webSessionRequestExit :: (s: *WebSession) -> Result #foreign libnx;

/**
* @brief Request the applet to Appear, this is only needed with ::WebSessionBootMode_AllForegroundInitiallyHidden.
* @note This should not be used before \ref webSessionStart.
* @param s \ref WebSession
* @param[out] flag Whether the message was sent successfully.
*/
webSessionAppear :: (s: *WebSession, flag: *bool) -> Result #foreign libnx;

/**
* @brief TrySendContentMessage
* @note This should not be used before \ref webSessionStart.
* @note The JS-side for this is only available when JsExtension is enabled via \ref webConfigSetJsExtension.
* @note The JS-side may ignore this if it's sent too soon after the applet launches.
* @param s \ref WebSession
* @param[in] content Input content NUL-terminated string.
* @param[in] size Size of content.
* @param[out] flag Whether the message was sent successfully.
*/
webSessionTrySendContentMessage :: (s: *WebSession, content: *u8, size: u32, flag: *bool) -> Result #foreign libnx;

/**
* @brief TryReceiveContentMessage
* @note This should not be used before \ref webSessionStart.
* @note The JS-side for this is only available when JsExtension is enabled via \ref webConfigSetJsExtension.
* @param s \ref WebSession
* @param[out] content Output content string, always NUL-terminated.
* @param[in] size Max size of content.
* @param[out] out_size Original content size, prior to being clamped to the specified size param.
* @param[out] flag Whether the message was received successfully.
*/
webSessionTryReceiveContentMessage :: (s: *WebSession, content: *u8, size: u64, out_size: *u64, flag: *bool) -> Result #foreign libnx;

/// Structure representing an entry in the homebrew environment configuration.
ConfigEntry :: struct {
    Key:   u32; ///< Type of entry
    Flags: u32; ///< Entry flags
    Value: [2] u64; ///< Entry arguments (type-specific)
}

/// Entry flags
anon_enum_1 :: enum u32 {
    EntryFlag_IsMandatory :: 1;
}

EntryType :: enum u32 {
    EndOfList             :: 0;
    MainThreadHandle      :: 1;
    NextLoadPath          :: 2;
    OverrideHeap          :: 3;
    OverrideService       :: 4;
    Argv                  :: 5;
    SyscallAvailableHint  :: 6;
    AppletType            :: 7;
    AppletWorkaround      :: 8;
    Reserved9             :: 9;
    ProcessHandle         :: 10;
    LastLoadResult        :: 11;
    RandomSeed            :: 14;
    UserIdStorage         :: 15;
    HosVersion            :: 16;
    SyscallAvailableHint2 :: 17;
}

anon_enum_2 :: enum u32 {
    EnvAppletFlags_ApplicationOverride :: 1;
}

/// Loader return function.
LoaderReturnFn :: #type (result_code: s32) -> void #c_call;

/**
* @brief Parses the homebrew loader environment block (internally called).
* @param ctx Reserved.
* @param main_thread Reserved.
* @param saved_lr Reserved.
*/
envSetup :: (ctx: *void, main_thread: Handle, saved_lr: LoaderReturnFn) -> void #foreign libnx;

/// Returns information text about the loader, if present.
envGetLoaderInfo :: () -> *u8 #foreign libnx;

/// Returns the size of the loader information text.
envGetLoaderInfoSize :: () -> u64 #foreign libnx;

/// Retrieves the handle to the main thread.
envGetMainThreadHandle :: () -> Handle #foreign libnx;

/// Returns true if the application is running as NSO, otherwise NRO.
envIsNso :: () -> bool #foreign libnx;

/// Returns true if the environment has a heap override.
envHasHeapOverride :: () -> bool #foreign libnx;

/// Returns the address of the overriden heap.
envGetHeapOverrideAddr :: () -> *void #foreign libnx;

/// Returns the size of the overriden heap.
envGetHeapOverrideSize :: () -> u64 #foreign libnx;

/// Returns true if the environment has an argv array.
envHasArgv :: () -> bool #foreign libnx;

/// Returns the pointer to the argv array.
envGetArgv :: () -> *void #foreign libnx;

/**
* @brief Returns whether a syscall is hinted to be available.
* @param svc Syscall number to test.
* @returns true if the syscall is available.
*/
envIsSyscallHinted :: (svc: u32) -> bool #foreign libnx;

/// Returns the handle to the running homebrew process.
envGetOwnProcessHandle :: () -> Handle #foreign libnx;

/// Returns the loader's return function, to be called on program exit.
envGetExitFuncPtr :: () -> LoaderReturnFn #foreign libnx;

/// Sets the return function to be called on program exit.
envSetExitFuncPtr :: (addr: LoaderReturnFn) -> void #foreign libnx;

/**
* @brief Configures the next homebrew application to load.
* @param path Path to the next homebrew application to load (.nro).
* @param argv Argument string to pass.
*/
envSetNextLoad :: (path: *u8, argv: *u8) -> Result #foreign libnx;

/// Returns true if the environment supports envSetNextLoad.
envHasNextLoad :: () -> bool #foreign libnx;

/// Returns the Result from the last NRO.
envGetLastLoadResult :: () -> Result #foreign libnx;

/// Returns true if the environment provides a random seed.
envHasRandomSeed :: () -> bool #foreign libnx;

/**
* @brief Retrieves the random seed provided by the environment.
* @param out Pointer to a u64[2] buffer which will contain the random seed on return.
*/
envGetRandomSeed :: (out: *[2] u64) -> void #foreign libnx;

/// Returns a pointer to the user id storage area (if present).
envGetUserIdStorage :: () -> *AccountUid #foreign libnx;

/// Returns the current HOS version that was previously set with \ref hosversionSet. If version initialization fails during startup (such as in the case set:sys is not available), this function returns zero.
hosversionGet :: () -> u32 #foreign libnx;

/// Sets or overrides the current HOS version. This function is normally called automatically by libnx on startup with the version info obtained with \ref setsysGetFirmwareVersion.
hosversionSet :: (version: u32) -> void #foreign libnx;

/// Returns whether the current HOS version is augmented by running the Atmosphère custom firmware.
hosversionIsAtmosphere :: () -> bool #foreign libnx;

/**
* @brief Aborts program execution with a result code.
* @param[in] res Result code.
*/
diagAbortWithResult :: (res: Result) -> void #foreign libnx;

in_addr :: struct {}

/// Address of the host connected through nxlink
__nxlink_host: in_addr #elsewhere libnx;

/**
* @brief Connects to the nxlink host, setting up an output stream.
* @param[in] redirStdout Whether to redirect stdout to nxlink output.
* @param[in] redirStderr Whether to redirect stderr to nxlink output.
* @return Socket fd on success, negative number on failure.
* @note The socket should be closed with close() during application cleanup.
*/
nxlinkConnectToHost :: (redirStdout: bool, redirStderr: bool) -> s32 #foreign libnx;

/// Fetches the last resolver Switch result code of the current thread.
resolverGetLastResult :: () -> Result #foreign libnx;

/// Retrieves a handle used to cancel the next resolver command on the current thread.
resolverGetCancelHandle :: () -> u32 #foreign libnx;

/// Retrieves whether service discovery is enabled for resolver commands on the current thread.
resolverGetEnableServiceDiscovery :: () -> bool #foreign libnx;

/// [5.0.0+] Retrieves whether the DNS cache is used to resolve queries on the current thread (not implemented).
resolverGetEnableDnsCache :: () -> bool #foreign libnx;

/// Enables or disables service discovery for the current thread.
resolverSetEnableServiceDiscovery :: (enable: bool) -> void #foreign libnx;

/// [5.0.0+] Enables or disables the usage of the DNS cache on the current thread (not implemented).
resolverSetEnableDnsCache :: (enable: bool) -> void #foreign libnx;

/// Cancels a previous resolver command (handle obtained with \ref resolverGetCancelHandle prior to calling the command).
resolverCancel :: (handle: u32) -> Result #foreign libnx;

/// [5.0.0+] Removes a hostname from the DNS cache (not implemented).
resolverRemoveHostnameFromCache :: (hostname: *u8) -> Result #foreign libnx;

/// [5.0.0+] Removes an IP address from the DNS cache (not implemented).
resolverRemoveIpAddressFromCache :: (ip: u32) -> Result #foreign libnx;

/// Pad state object.
PadState :: struct {
    id_mask:         u8;
    active_id_mask:  u8;
    read_handheld:   bool;
    active_handheld: bool;
    style_set:       u32;
    attributes:      u32;
    buttons_cur:     u64;
    buttons_old:     u64;
    sticks:          [2] HidAnalogStickState;
    gc_triggers:     [2] u32;
}

/// Pad button repeater state object.
PadRepeater :: struct {
    button_mask: u64;
    counter:     s32;
    delay:       u16;
    repeat:      u16;
}

/**
* @brief Configures the input layout supported by the application.
* @param[in] max_players The maximum supported number of players (1 to 8).
* @param[in] style_set Bitfield of supported controller styles (see \ref HidNpadStyleTag).
*/
padConfigureInput :: (max_players: u32, style_set: u32) -> void #foreign libnx;

/**
* @brief Same as \ref padInitialize, but taking a bitfield of controller IDs directly.
* @param[in] pad Pointer to \ref PadState.
* @param[in] mask Bitfield of controller IDs (each bit's position indicates a different \ref HidNpadIdType value).
*/
padInitializeWithMask :: (pad: *PadState, mask: u64) -> void #foreign libnx;

/**
* @brief Updates pad state by reading from the controller input sources specified during initialization.
* @param[in] pad Pointer to \ref PadState.
*/
padUpdate :: (pad: *PadState) -> void #foreign libnx;

/**
* @brief Updates pad repeat state.
* @param[in] r Pointer to \ref PadRepeater.
* @param[in] button_mask Bitfield of currently pressed \ref HidNpadButton that will be considered for repeat.
*/
padRepeaterUpdate :: (r: *PadRepeater, button_mask: u64) -> void #foreign libnx;

/// Whether the output data is valid.
RingConDataValid :: enum u32 {
    Ok  :: 0;
    CRC :: 1;
    Cal :: 2;
}

RingConErrorFlag :: enum u32 {
    BadUserCalUpdate :: 0;
    BadFlag          :: 4;
    BadUserCal       :: 5;
    BadManuCal       :: 6;
}

/// Ring-Con firmware version.
RingConFwVersion :: struct {
    fw_main_ver: u8; ///< Main firmware version.
    fw_sub_ver:  u8; ///< Sub firmware version.
}

/// Ring-Con manufacturer calibration.
RingConManuCal :: struct {
    os_max:   s16; ///< (manu_)os_max
    hk_max:   s16; ///< (manu_)hk_max
    zero_min: s16; ///< (manu_)zero_min
    zero_max: s16; ///< (manu_)zero_max
}

/// Ring-Con user calibration.
RingConUserCal :: struct {
    os_max:     s16; ///< (user_)os_max
    hk_max:     s16; ///< (user_)hk_max
    zero:       s16; ///< (user_)zero
    data_valid: RingConDataValid; ///< \ref RingConDataValid
}

/// Polling data extracted from \ref HidbusJoyPollingReceivedData.
RingConPollingData :: struct {
    data:            s16; ///< Sensor state data.
    sampling_number: u64; ///< SamplingNumber
}

/// Ring-Con state object.
RingCon :: struct {
    bus_initialized:              bool;
    handle:                       HidbusBusHandle;
    workbuf:                      *void;
    workbuf_size:                 u64;
    polling_last_sampling_number: u64;
    error_flags:                  u32;

    id_l:                         u64;
    id_h:                         u64;
    fw_ver:                       RingConFwVersion;
    flag:                         u32;
    unk_cal:                      s16;
    total_push_count:             s32;

    manu_cal:                     RingConManuCal;
    user_cal:                     RingConUserCal;
}

/**
* @brief Creates a \ref RingCon object, and handles the various initialization for it.
* @param c \ref RingCon
* @param[in] id \ref HidNpadIdType. A Ring-Con must be attached to this controller.
*/
ringconCreate :: (c: *RingCon, id: HidNpadIdType) -> Result #foreign libnx;

/**
* @brief Close a \ref RingCon.
* @param c \ref RingCon
*/
ringconClose :: (c: *RingCon) -> void #foreign libnx;

/**
* @brief Updates the \ref RingConUserCal.
* @note The input \ref RingConUserCal is used with \ref ringconWriteUserCal, and the output from \ref ringconReadUserCal is verified with the input \ref RingConUserCal. This does not update the \ref RingConUserCal returned by \ref ringconGetUserCal.
* @note The Ring-Con UserCal doesn't seem to be calibrated normally?
* @param c \ref RingCon
* @param[in] cal \ref RingConUserCal
*/
ringconUpdateUserCal :: (c: *RingCon, cal: RingConUserCal) -> Result #foreign libnx;

/**
* @brief Reads the \ref RingConFwVersion.
* @note This is used internally by \ref ringconCreate. Normally you should use \ref ringconGetFwVersion instead.
* @param c \ref RingCon
* @param[out] out \ref RingConFwVersion
*/
ringconReadFwVersion :: (c: *RingCon, out: *RingConFwVersion) -> Result #foreign libnx;

/**
* @brief Reads the Id.
* @note This is used internally by \ref ringconCreate. Normally you should use \ref ringconGetId instead.
* @param c \ref RingCon
* @param[out] id_l Id low.
* @param[out] id_h Id high.
*/
ringconReadId :: (c: *RingCon, id_l: *u64, id_h: *u64) -> Result #foreign libnx;

/**
* @brief Gets the \ref RingConPollingData. Only returns entries which are new since the last time this was called (or if not previously called, all available entries up to count).
* @param c \ref RingCon
* @param[out] out Output array of \ref RingConPollingData. Entry order is newest -> oldest.
* @param[in] count Total size of the out array in entries, max value is 0x9.
* @param[out] total_out Total output entries.
*/
ringconGetPollingData :: (c: *RingCon, out: *RingConPollingData, count: s32, total_out: *s32) -> Result #foreign libnx;

/**
* @brief Uses cmd 0x00020105.
* @note Used internally by \ref ringconCreate.
* @param c \ref RingCon
* @param[out] out Output value.
*/
ringconCmdx00020105 :: (c: *RingCon, out: *u32) -> Result #foreign libnx;

/**
* @brief Reads the \ref RingConManuCal.
* @note Used internally by \ref ringconCreate and \ref ringconReadUnkCal.
* @param c \ref RingCon
* @param[out] out \ref RingConManuCal
*/
ringconReadManuCal :: (c: *RingCon, out: *RingConManuCal) -> Result #foreign libnx;

/**
* @brief Gets the unknown value derived from the output of cmd 0x00020504 and \ref ringconReadManuCal.
* @note Used internally by \ref ringconCreate.
* @param c \ref RingCon
* @param[out] out Output value.
*/
ringconReadUnkCal :: (c: *RingCon, out: *s16) -> Result #foreign libnx;

/**
* @brief Reads the \ref RingConUserCal.
* @note Used internally by \ref ringconCreate and \ref ringconUpdateUserCal.
* @param c \ref RingCon
* @param[out] out \ref RingConUserCal
*/
ringconReadUserCal :: (c: *RingCon, out: *RingConUserCal) -> Result #foreign libnx;

/**
* @brief Reads the rep-count for Multitask Mode.
* @param c \ref RingCon
* @param[out] out Output value. Official sw using this clamps the output to range 0-500.
* @param[out] data_valid \ref RingConDataValid
*/
ringconReadRepCount :: (c: *RingCon, out: *s32, data_valid: *RingConDataValid) -> Result #foreign libnx;

/**
* @brief Reads the total-push-count, for Multitask Mode.
* @note Used internally by \ref ringconCreate. Normally \ref ringconGetTotalPushCount should be used instead.
* @param c \ref RingCon
* @param[out] out Output value.
* @param[out] data_valid \ref RingConDataValid
*/
ringconReadTotalPushCount :: (c: *RingCon, out: *s32, data_valid: *RingConDataValid) -> Result #foreign libnx;

/**
* @brief This resets the value returned by \ref ringconReadRepCount to 0.
* @param c \ref RingCon
*/
ringconResetRepCount :: (c: *RingCon) -> Result #foreign libnx;

/**
* @brief Writes the \ref RingConUserCal.
* @note Used internally by \ref ringconUpdateUserCal.
* @param c \ref RingCon
* @param[in] cal \ref RingConUserCal
*/
ringconWriteUserCal :: (c: *RingCon, cal: RingConUserCal) -> Result #foreign libnx;

/// GattAttribute
BtdevGattAttribute :: struct {
    type:              u8; ///< Type
    uuid:              BtdrvGattAttributeUuid; ///< \ref BtdrvGattAttributeUuid
    handle:            u16; ///< Handle
    connection_handle: u32; ///< ConnectionHandle
}

/// GattService
BtdevGattService :: struct {
    attr:             BtdevGattAttribute; ///< \ref BtdevGattAttribute
    instance_id:      u16; ///< InstanceId
    end_group_handle: u16; ///< EndGroupHandle
    primary_service:  bool; ///< PrimaryService
}

/// GattCharacteristic
BtdevGattCharacteristic :: struct {
    attr:        BtdevGattAttribute; ///< \ref BtdevGattAttribute
    instance_id: u16; ///< InstanceId
    properties:  u8; ///< Properties
    value_size:  u64; ///< Size of value.
    value:       [512] u8; ///< Value
}

/// GattDescriptor
BtdevGattDescriptor :: struct {
    attr:       BtdevGattAttribute; ///< \ref BtdevGattAttribute
    value_size: u64; ///< Size of value.
    value:      [512] u8; ///< Value
}

/// Initialize bt/btmu.
btdevInitialize :: () -> Result #foreign libnx;

/// Exit bt/btmu.
btdevExit :: () -> void #foreign libnx;

/// Compares two \ref BtdrvGattAttributeUuid, returning whether these match.
btdevGattAttributeUuidIsSame :: (a: *BtdrvGattAttributeUuid, b: *BtdrvGattAttributeUuid) -> bool #foreign libnx;

/// Wrapper for \ref btmuAcquireBleScanEvent.
btdevAcquireBleScanEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Wrapper for \ref btmuGetBleScanFilterParameter.
btdevGetBleScanParameter :: (parameter_id: u16, out: *BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuGetBleScanFilterParameter2.
btdevGetBleScanParameter2 :: (parameter_id: u16, out: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/// Wrapper for \ref btdevStartBleScanGeneral.
btdevStartBleScanGeneral :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuStopBleScanForGeneral.
btdevStopBleScanGeneral :: () -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetBleScanResultsForGeneral and \ref btmuGetBleScanResultsForSmartDevice.
* @param[out] results Output array of \ref BtdrvBleScanResult.
* @param[in] count Size of the results array in entries.
* @param[out] total_out Total output entries.
*/
btdevGetBleScanResult :: (results: *BtdrvBleScanResult, count: u8, total_out: *u8) -> Result #foreign libnx;

/// Wrapper for \ref btmuStartBleScanForPaired.
btdevEnableBleAutoConnection :: (param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuStopBleScanForPaired.
btdevDisableBleAutoConnection :: () -> Result #foreign libnx;

/// Wrapper for \ref btmuStartBleScanForSmartDevice.
btdevStartBleScanSmartDevice :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/// Wrapper for \ref btmuStopBleScanForSmartDevice.
btdevStopBleScanSmartDevice :: () -> Result #foreign libnx;

/// Wrapper for \ref btmuAcquireBleConnectionEvent.
btdevAcquireBleConnectionStateChangedEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleConnect.
btdevConnectToGattServer :: (addr: BtdrvAddress) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleDisconnect.
btdevDisconnectFromGattServer :: (connection_handle: u32) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleGetConnectionState.
btdevGetBleConnectionInfoList :: (info: *BtdrvBleConnectionInfo, count: u8, total_out: *u8) -> Result #foreign libnx;

/// Wrapper for \ref btmuAcquireBleServiceDiscoveryEvent.
btdevAcquireBleServiceDiscoveryEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattServices.
* @param[in] connection_handle ConnectionHandle
* @param[out] services Output array of \ref BtdevGattService.
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btdevGetGattServices :: (connection_handle: u32, services: *BtdevGattService, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattService.
* @param[in] connection_handle ConnectionHandle
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[out] service \ref BtdevGattService
* @param[out] flag Whether a \ref BtdevGattService was returned.
*/
btdevGetGattService :: (connection_handle: u32, uuid: *BtdrvGattAttributeUuid, service: *BtdevGattService, flag: *bool) -> Result #foreign libnx;

/// Wrapper for \ref btmuAcquireBlePairingEvent.
btdevAcquireBlePairingEvent :: (out_event: *Event) -> Result #foreign libnx;

/// Wrapper for \ref btmuBlePairDevice.
btdevPairGattServer :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleUnPairDevice.
btdevUnpairGattServer :: (connection_handle: u32, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleUnPairDevice2.
btdevUnpairGattServer2 :: (addr: BtdrvAddress, param: BtdrvBleAdvertisePacketParameter) -> Result #foreign libnx;

/// Wrapper for \ref btmuBleGetPairedDevices.
btdevGetPairedGattServerAddress :: (param: BtdrvBleAdvertisePacketParameter, addrs: *BtdrvAddress, count: u8, total_out: *u8) -> Result #foreign libnx;

/// Wrapper for \ref btmuAcquireBleMtuConfigEvent.
btdevAcquireBleMtuConfigEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuConfigureBleMtu.
* @param[in] connection_handle Same as \ref btmuBleDisconnect.
* @param[in] mtu MTU, must be 0x18-0x200.
*/
btdevConfigureBleMtu :: (connection_handle: u32, mtu: u16) -> Result #foreign libnx;

/// Wrapper for \ref btmuGetBleMtu.
btdevGetBleMtu :: (connection_handle: u32, out: *u16) -> Result #foreign libnx;

/// Wrapper for \ref btRegisterBleEvent.
btdevAcquireBleGattOperationEvent :: (out_event: *Event) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuRegisterBleGattDataPath.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdevRegisterGattOperationNotification :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuUnregisterBleGattDataPath.
* @param[in] uuid \ref BtdrvGattAttributeUuid
*/
btdevUnregisterGattOperationNotification :: (uuid: *BtdrvGattAttributeUuid) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btGetLeEventInfo.
* @param[out] out \ref BtdrvBleClientGattOperationInfo
*/
btdevGetGattOperationResult :: (out: *BtdrvBleClientGattOperationInfo) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btLeClientReadCharacteristic.
* @note An error is thrown if the properties from \ref btdevGattCharacteristicGetProperties don't allow using this.
* @param c \ref BtdevGattCharacteristic
*/
btdevReadGattCharacteristic :: (c: *BtdevGattCharacteristic) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btLeClientWriteCharacteristic.
* @note An error is thrown if the properties from \ref btdevGattCharacteristicGetProperties don't allow using this.
* @note This uses the Value from \ref btdevGattCharacteristicSetValue.
* @param c \ref BtdevGattCharacteristic
*/
btdevWriteGattCharacteristic :: (c: *BtdevGattCharacteristic) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btLeClientRegisterNotification / \ref btLeClientDeregisterNotification.
* @note An error is thrown if the properties from \ref btdevGattCharacteristicGetProperties don't allow using this.
* @param c \ref BtdevGattCharacteristic
* @param[in] flag Whether to enable/disable, controls which func to call.
*/
btdevEnableGattCharacteristicNotification :: (c: *BtdevGattCharacteristic, flag: bool) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btLeClientReadDescriptor.
* @param d \ref BtdevGattDescriptor
*/
btdevReadGattDescriptor :: (d: *BtdevGattDescriptor) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btLeClientWriteDescriptor.
* @note This uses the Value from \ref btdevGattDescriptorSetValue.
* @param d \ref BtdevGattDescriptor
*/
btdevWriteGattDescriptor :: (d: *BtdevGattDescriptor) -> Result #foreign libnx;

/**
* @brief Creates a \ref BtdevGattAttribute object. This is intended for internal use.
* @param a \ref BtdevGattAttribute
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[in] handle Handle
* @param[in] connection_handle ConnectionHandle
*/
btdevGattAttributeCreate :: (a: *BtdevGattAttribute, uuid: *BtdrvGattAttributeUuid, handle: u16, connection_handle: u32) -> void #foreign libnx;

/**
* @brief Creates a \ref BtdevGattService object. This is intended for internal use.
* @param s \ref BtdevGattService
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[in] handle Handle
* @param[in] connection_handle ConnectionHandle
* @param[in] instance_id InstanceId
* @param[in] end_group_handle EndGroupHandle
* @param[in] primary_service PrimaryService
*/
btdevGattServiceCreate :: (s: *BtdevGattService, uuid: *BtdrvGattAttributeUuid, handle: u16, connection_handle: u32, instance_id: u16, end_group_handle: u16, primary_service: bool) -> void #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattIncludedServices.
* @param s \ref BtdevGattService
* @param[out] services Output array of \ref BtdevGattService.
* @param[in] count Size of the services array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btdevGattServiceGetIncludedServices :: (s: *BtdevGattService, services: *BtdevGattService, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattCharacteristics.
* @param s \ref BtdevGattService
* @param[out] characteristics Output array of \ref BtdevGattCharacteristic.
* @param[in] count Size of the characteristics array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btdevGattServiceGetCharacteristics :: (s: *BtdevGattService, characteristics: *BtdevGattCharacteristic, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Same as \ref btdevGattServiceGetCharacteristics except this only returns the \ref BtdevGattCharacteristic which contains a matching \ref BtdrvGattAttributeUuid.
* @param s \ref BtdevGattService
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[out] characteristic \ref BtdevGattCharacteristic
* @param[out] flag Whether a \ref BtdevGattService was returned.
*/
btdevGattServiceGetCharacteristic :: (s: *BtdevGattService, uuid: *BtdrvGattAttributeUuid, characteristic: *BtdevGattCharacteristic, flag: *bool) -> Result #foreign libnx;

/**
* @brief Creates a \ref BtdevGattCharacteristic object. This is intended for internal use.
* @param c \ref BtdevGattCharacteristic
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[in] handle Handle
* @param[in] connection_handle ConnectionHandle
* @param[in] instance_id InstanceId
* @param[in] properties Properties
*/
btdevGattCharacteristicCreate :: (c: *BtdevGattCharacteristic, uuid: *BtdrvGattAttributeUuid, handle: u16, connection_handle: u32, instance_id: u16, properties: u8) -> void #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetBelongingGattService.
* @note Gets the \ref BtdevGattService which belongs to this object.
* @param c \ref BtdevGattCharacteristic.
* @param[out] service \ref BtdevGattService
*/
btdevGattCharacteristicGetService :: (c: *BtdevGattCharacteristic, service: *BtdevGattService) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattDescriptors.
* @note Gets the descriptors which belongs to this object.
* @param c \ref BtdevGattCharacteristic
* @param[out] descriptors Output array of \ref BtdevGattDescriptor.
* @param[in] count Size of the descriptors array in entries. The max is 100.
* @param[out] total_out Total output entries.
*/
btdevGattCharacteristicGetDescriptors :: (c: *BtdevGattCharacteristic, descriptors: *BtdevGattDescriptor, count: u8, total_out: *u8) -> Result #foreign libnx;

/**
* @brief Same as \ref btdevGattCharacteristicGetDescriptors except this only returns a \ref BtdevGattDescriptor which contains a matching \ref BtdrvGattAttributeUuid.
* @param c \ref BtdevGattCharacteristic
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[out] descriptor \ref BtdevGattDescriptor
* @param[out] flag Whether a \ref BtdevGattDescriptor was returned.
*/
btdevGattCharacteristicGetDescriptor :: (c: *BtdevGattCharacteristic, uuid: *BtdrvGattAttributeUuid, descriptor: *BtdevGattDescriptor, flag: *bool) -> Result #foreign libnx;

/**
* @brief Sets the Value in the object.
* @note See also \ref btdevWriteGattCharacteristic.
* @param c \ref BtdevGattCharacteristic
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, max is 0x200.
*/
btdevGattCharacteristicSetValue :: (c: *BtdevGattCharacteristic, buffer: *void, size: u64) -> void #foreign libnx;

/**
* @brief Gets the Value in the object, returns the copied value size.
* @param c \ref BtdevGattCharacteristic
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size, max is 0x200.
*/
btdevGattCharacteristicGetValue :: (c: *BtdevGattCharacteristic, buffer: *void, size: u64) -> u64 #foreign libnx;

/**
* @brief Creates a \ref BtdevGattDescriptor object. This is intended for internal use.
* @param d \ref BtdevGattDescriptor
* @param[in] uuid \ref BtdrvGattAttributeUuid
* @param[in] handle Handle
* @param[in] connection_handle ConnectionHandle
*/
btdevGattDescriptorCreate :: (d: *BtdevGattDescriptor, uuid: *BtdrvGattAttributeUuid, handle: u16, connection_handle: u32) -> void #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetBelongingGattService.
* @note Gets the \ref BtdevGattService which belongs to this object.
* @param d \ref BtdevGattDescriptor
* @param[out] service \ref BtdevGattService
*/
btdevGattDescriptorGetService :: (d: *BtdevGattDescriptor, service: *BtdevGattService) -> Result #foreign libnx;

/**
* @brief Wrapper for \ref btmuGetGattCharacteristics.
* @note Gets the \ref BtdevGattCharacteristic which belongs to this object.
* @param d \ref BtdevGattDescriptor
* @param[out] characteristic \ref BtdevGattCharacteristic
*/
btdevGattDescriptorGetCharacteristic :: (d: *BtdevGattDescriptor, characteristic: *BtdevGattCharacteristic) -> Result #foreign libnx;

/**
* @brief Sets the Value in the object.
* @note See also \ref btdevWriteGattDescriptor.
* @param d \ref BtdevGattDescriptor
* @param[in] buffer Input buffer.
* @param[in] size Input buffer size, max is 0x200.
*/
btdevGattDescriptorSetValue :: (d: *BtdevGattDescriptor, buffer: *void, size: u64) -> void #foreign libnx;

/**
* @brief Gets the Value in the object, returns the copied value size.
* @param d \ref BtdevGattDescriptor
* @param[out] buffer Output buffer.
* @param[in] size Output buffer size, max is 0x200.
*/
btdevGattDescriptorGetValue :: (d: *BtdevGattDescriptor, buffer: *void, size: u64) -> u64 #foreign libnx;

/** Convert a UTF-8 sequence into a UTF-32 codepoint
*
*  @param[out] out Output codepoint
*  @param[in]  in  Input sequence
*
*  @returns number of input code units consumed
*  @returns -1 for error
*/
decode_utf8 :: (out: *u32, in: *u8) -> ssize_t #foreign libnx;

/** Convert a UTF-16 sequence into a UTF-32 codepoint
*
*  @param[out] out Output codepoint
*  @param[in]  in  Input sequence
*
*  @returns number of input code units consumed
*  @returns -1 for error
*/
decode_utf16 :: (out: *u32, in: *u16) -> ssize_t #foreign libnx;

/** Convert a UTF-32 codepoint into a UTF-8 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input codepoint
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out must be able to store 4 code units
*/
encode_utf8 :: (out: *u8, in: u32) -> ssize_t #foreign libnx;

/** Convert a UTF-32 codepoint into a UTF-16 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input codepoint
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out must be able to store 2 code units
*/
encode_utf16 :: (out: *u16, in: u32) -> ssize_t #foreign libnx;

/** Convert a UTF-8 sequence into a UTF-16 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf8_to_utf16 :: (out: *u16, in: *u8, len: u64) -> ssize_t #foreign libnx;

/** Convert a UTF-8 sequence into a UTF-32 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf8_to_utf32 :: (out: *u32, in: *u8, len: u64) -> ssize_t #foreign libnx;

/** Convert a UTF-16 sequence into a UTF-8 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf16_to_utf8 :: (out: *u8, in: *u16, len: u64) -> ssize_t #foreign libnx;

/** Convert a UTF-16 sequence into a UTF-32 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf16_to_utf32 :: (out: *u32, in: *u16, len: u64) -> ssize_t #foreign libnx;

/** Convert a UTF-32 sequence into a UTF-8 sequence
*
*  Fills the output buffer up to \a len code units.
*  Returns the number of code units that the input would produce;
*  if it returns greater than \a len, the output has been
*  truncated.
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf32_to_utf8 :: (out: *u8, in: *u32, len: u64) -> ssize_t #foreign libnx;

/** Convert a UTF-32 sequence into a UTF-16 sequence
*
*  @param[out] out Output sequence
*  @param[in]  in  Input sequence (null-terminated)
*  @param[in]  len Output length
*
*  @returns number of output code units produced
*  @returns -1 for error
*
*  @note \a out is not null-terminated
*/
utf32_to_utf16 :: (out: *u16, in: *u32, len: u64) -> ssize_t #foreign libnx;

/// Renderer interface for the console.
ConsoleRenderer :: struct {
    init:         #type (con: *PrintConsole) -> bool #c_call;
    deinit:       #type (con: *PrintConsole) -> void #c_call;
    drawChar:     #type (con: *PrintConsole, x: s32, y: s32, c: s32) -> void #c_call;
    scrollWindow: #type (con: *PrintConsole) -> void #c_call;
    flushAndSwap: #type (con: *PrintConsole) -> void #c_call;
}

/// A font struct for the console.
ConsoleFont :: struct {
    gfx:         *void; ///< A pointer to the font graphics
    asciiOffset: u16; ///< Offset to the first valid character in the font table
    numChars:    u16; ///< Number of characters in the font graphics
    tileWidth:   u16;
    tileHeight:  u16;
}

/**
* @brief Console structure used to store the state of a console render context.
*
* Default values from consoleGetDefault();
* @code
* PrintConsole defaultConsole =
* {
* 	//Font:
* 	{
* 		default_font_bin, //font gfx
* 		0, //first ascii character in the set
* 		256, //number of characters in the font set
* 		16, //tile width
* 		16, //tile height
*	},
*	NULL, //renderer
*	0,0, //cursorX cursorY
*	0,0, //prevcursorX prevcursorY
*	80, //console width
*	45, //console height
*	0,  //window x
*	0,  //window y
*	80, //window width
*	45, //window height
*	3, //tab size
*	7, // foreground color
*	0, // background color
*	0, // flags
*	false //console initialized
* };
* @endcode
*/
PrintConsole :: struct {
    font:               ConsoleFont; ///< Font of the console
    renderer:           *ConsoleRenderer; ///< Renderer of the console

    cursorX:            s32; ///< Current X location of the cursor (as a tile offset by default)
    cursorY:            s32; ///< Current Y location of the cursor (as a tile offset by default)

    prevCursorX:        s32; ///< Internal state
    prevCursorY:        s32; ///< Internal state

    consoleWidth:       s32; ///< Width of the console hardware layer in characters
    consoleHeight:      s32; ///< Height of the console hardware layer in characters

    windowX:            s32; ///< Window X location in characters
    windowY:            s32; ///< Window Y location in characters
    windowWidth:        s32; ///< Window width in characters
    windowHeight:       s32; ///< Window height in characters

    tabSize:            s32; ///< Size of a tab
    fg:                 u16; ///< Foreground color
    bg:                 u16; ///< Background color
    flags:              s32; ///< Reverse/bright flags

    consoleInitialised: bool; ///< True if the console is initialized
}

/// Console debug devices supported by libnx.
debugDevice :: enum u32 {
    NULL    :: 0;
    SVC     :: 1;
    CONSOLE :: 2;
}

/**
* @brief Loads the font into the console.
* @param console Pointer to the console to update, if NULL it will update the current console.
* @param font The font to load.
*/
consoleSetFont :: (console: *PrintConsole, font: *ConsoleFont) -> void #foreign libnx;

/**
* @brief Sets the print window.
* @param console Console to set, if NULL it will set the current console window.
* @param x X location of the window.
* @param y Y location of the window.
* @param width Width of the window.
* @param height Height of the window.
*/
consoleSetWindow :: (console: *PrintConsole, x: s32, y: s32, width: s32, height: s32) -> void #foreign libnx;

/**
* @brief Gets a pointer to the console with the default values.
* This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().
* @return A pointer to the console with the default values.
*/
consoleGetDefault :: () -> *PrintConsole #foreign libnx;

/**
* @brief Make the specified console the render target.
* @param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).
* @return A pointer to the previous console.
*/
consoleSelect :: (console: *PrintConsole) -> *PrintConsole #foreign libnx;

/**
* @brief Initialise the console.
* @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
* @return A pointer to the current console.
*/
consoleInit :: (console: *PrintConsole) -> *PrintConsole #foreign libnx;

/**
* @brief Deinitialise the console.
* @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
*/
consoleExit :: (console: *PrintConsole) -> void #foreign libnx;

/**
* @brief Updates the console, submitting a new frame to the display.
* @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).
* @remark This function should be called periodically. Failure to call this function will result in lack of screen updating.
*/
consoleUpdate :: (console: *PrintConsole) -> void #foreign libnx;

/**
* @brief Initializes debug console output on stderr to the specified device.
* @param device The debug device (or devices) to output debug print statements to.
*/
consoleDebugInit :: (device: debugDevice) -> void #foreign libnx;

/// Clears the screan by using printf("\x1b[2J");
consoleClear :: () -> void #foreign libnx;

UsbCommsInterfaceInfo :: struct {
    bInterfaceClass:    u8;
    bInterfaceSubClass: u8;
    bInterfaceProtocol: u8;
}

/// Initializes usbComms with the default number of interfaces (1)
usbCommsInitialize :: () -> Result #foreign libnx;

/// Initializes usbComms with a specific number of interfaces.
usbCommsInitializeEx :: (num_interfaces: u32, infos: *UsbCommsInterfaceInfo, idVendor: u16, idProduct: u16) -> Result #foreign libnx;

/// Exits usbComms.
usbCommsExit :: () -> void #foreign libnx;

/// Sets whether to throw a fatal error in usbComms{Read/Write}* on failure, or just return the transferred size. By default (false) the latter is used.
usbCommsSetErrorHandling :: (flag: bool) -> void #foreign libnx;

/// Read data with the default interface.
usbCommsRead :: (buffer: *void, size: u64) -> u64 #foreign libnx;

/// Write data with the default interface.
usbCommsWrite :: (buffer: *void, size: u64) -> u64 #foreign libnx;

/// Same as usbCommsRead except with the specified interface.
usbCommsReadEx :: (buffer: *void, size: u64, _interface: u32) -> u64 #foreign libnx;

/// Same as usbCommsWrite except with the specified interface.
usbCommsWriteEx :: (buffer: *void, size: u64, _interface: u32) -> u64 #foreign libnx;

/// Retrieve event used for read completion with the given interface.
usbCommsGetReadCompletionEvent :: (_interface: u32) -> *Event #foreign libnx;

/// Start an asynchronous read. The completion event will be signaled when the read completes.
/// The buffer must be page-aligned and no larger than one page.
usbCommsReadAsync :: (buffer: *void, size: u64, urbId: *u32, _interface: u32) -> Result #foreign libnx;

/// Complete an asynchronous read, clearing the completion event, and return the amount of data which was read.
usbCommsGetReadResult :: (urbId: u32, transferredSize: *u32, _interface: u32) -> Result #foreign libnx;

/// Retrieve event used for write completion with the given interface.
usbCommsGetWriteCompletionEvent :: (_interface: u32) -> *Event #foreign libnx;

/// Start an asynchronous write. The completion event will be signaled when the write completes.
/// The buffer must be page-aligned and no larger than one page.
usbCommsWriteAsync :: (buffer: *void, size: u64, urbId: *u32, _interface: u32) -> Result #foreign libnx;

/// Complete an asynchronous write, clearing the completion event, and return the amount of data which was written.
usbCommsGetWriteResult :: (urbId: u32, transferredSize: *u32, _interface: u32) -> Result #foreign libnx;

/// Open directory struct
fsdev_dir_t :: struct {
    magic: u32; ///< "fsdv"
    fd:    FsDir; ///< File descriptor
    index: ssize_t; ///< Current entry index
    size:  u64; ///< Current batch size
}

/// Initializes and mounts the sdmc device if accessible.
fsdevMountSdmc :: () -> Result #foreign libnx;

/// Mounts the specified SaveData.
fsdevMountSaveData :: (name: *u8, application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Mounts the specified SaveData as ReadOnly.
/// Only available on [2.0.0+].
fsdevMountSaveDataReadOnly :: (name: *u8, application_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Mounts the specified BcatSaveData.
fsdevMountBcatSaveData :: (name: *u8, application_id: u64) -> Result #foreign libnx;

/// Mounts the specified DeviceSaveData.
fsdevMountDeviceSaveData :: (name: *u8, application_id: u64) -> Result #foreign libnx;

/// Mounts the TemporaryStorage for the current process.
/// Only available on [3.0.0+].
fsdevMountTemporaryStorage :: (name: *u8) -> Result #foreign libnx;

/// Mounts the specified CacheStorage.
/// Only available on [3.0.0+].
fsdevMountCacheStorage :: (name: *u8, application_id: u64, save_data_index: u16) -> Result #foreign libnx;

/// Mounts the specified SystemSaveData.
fsdevMountSystemSaveData :: (name: *u8, save_data_space_id: FsSaveDataSpaceId, system_save_data_id: u64, uid: AccountUid) -> Result #foreign libnx;

/// Mounts the specified SystemBcatSaveData.
/// Only available on [4.0.0+].
fsdevMountSystemBcatSaveData :: (name: *u8, system_save_data_id: u64) -> Result #foreign libnx;

/// Mounts the input fs with the specified device name. fsdev will handle closing the fs when required, including when fsdevMountDevice() fails.
/// Returns -1 when any errors occur.
/// Input device name string shouldn't exceed 31 characters, and shouldn't have a trailing colon.
fsdevMountDevice :: (name: *u8, fs: FsFileSystem) -> s32 #foreign libnx;

/// Unmounts the specified device.
fsdevUnmountDevice :: (name: *u8) -> s32 #foreign libnx;

/// Uses fsFsCommit() with the specified device. This must be used after any savedata-write operations(not just file-write). This should be used after each file-close where file-writing was done.
/// This is not used automatically at device unmount.
fsdevCommitDevice :: (name: *u8) -> Result #foreign libnx;

/// Returns the FsFileSystem for the specified device. Returns NULL when the specified device isn't found.
fsdevGetDeviceFileSystem :: (name: *u8) -> *FsFileSystem #foreign libnx;

/// Writes the FS-path to outpath (which has buffer size FS_MAX_PATH), for the input path (as used in stdio). The FsFileSystem is also written to device when not NULL.
fsdevTranslatePath :: (path: *u8, device: **FsFileSystem, outpath: *u8) -> s32 #foreign libnx;

/// This calls fsFsSetConcatenationFileAttribute on the filesystem specified by the input path (as used in stdio).
fsdevSetConcatenationFileAttribute :: (path: *u8) -> Result #foreign libnx;

// Uses \ref fsFsIsValidSignedSystemPartitionOnSdCard with the specified device.
fsdevIsValidSignedSystemPartitionOnSdCard :: (name: *u8, out: *bool) -> Result #foreign libnx;

/// This calls fsFsCreateFile on the filesystem specified by the input path (as used in stdio).
fsdevCreateFile :: (path: *u8, size: u64, flags: u32) -> Result #foreign libnx;

/// Recursively deletes the directory specified by the input path (as used in stdio).
fsdevDeleteDirectoryRecursively :: (path: *u8) -> Result #foreign libnx;

/// Unmounts all devices and cleans up any resources used by the FS driver.
fsdevUnmountAll :: () -> Result #foreign libnx;

/// Retrieves the last native result code generated during a failed fsdev operation.
fsdevGetLastResult :: () -> Result #foreign libnx;

/// RomFS header.
romfs_header :: struct {
    headerSize:        u64; ///< Size of the header.
    dirHashTableOff:   u64; ///< Offset of the directory hash table.
    dirHashTableSize:  u64; ///< Size of the directory hash table.
    dirTableOff:       u64; ///< Offset of the directory table.
    dirTableSize:      u64; ///< Size of the directory table.
    fileHashTableOff:  u64; ///< Offset of the file hash table.
    fileHashTableSize: u64; ///< Size of the file hash table.
    fileTableOff:      u64; ///< Offset of the file table.
    fileTableSize:     u64; ///< Size of the file table.
    fileDataOff:       u64; ///< Offset of the file data.
}

/// RomFS directory.
romfs_dir :: struct {
    parent:    u32; ///< Offset of the parent directory.
    sibling:   u32; ///< Offset of the next sibling directory.
    childDir:  u32; ///< Offset of the first child directory.
    childFile: u32; ///< Offset of the first file.
    nextHash:  u32; ///< Directory hash table pointer.
    nameLen:   u32; ///< Name length.
//     name:      *u8; ///< Name. (UTF-8)// Incomplete array in C (zero-sized)
}

/// RomFS file.
romfs_file :: struct {
    parent:   u32; ///< Offset of the parent directory.
    sibling:  u32; ///< Offset of the next sibling file.
    dataOff:  u64; ///< Offset of the file's data.
    dataSize: u64; ///< Length of the file's data.
    nextHash: u32; ///< File hash table pointer.
    nameLen:  u32; ///< Name length.
//     name:     *u8; ///< Name. (UTF-8)// Incomplete array in C (zero-sized)
}

/**
* @brief Mounts the Application's RomFS.
* @param name Device mount name.
* @remark This function is intended to be used to access one's own RomFS.
*         If the application is running as NRO, it mounts the embedded RomFS section inside the NRO.
*         If on the other hand it's an NSO, it behaves identically to \ref romfsMountFromCurrentProcess.
*/
romfsMountSelf :: (name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS from an open file.
* @param file FsFile of the RomFS image.
* @param offset Offset of the RomFS within the file.
* @param name Device mount name.
*/
romfsMountFromFile :: (file: FsFile, offset: u64, name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS from an open storage.
* @param storage FsStorage of the RomFS image.
* @param offset Offset of the RomFS within the storage.
* @param name Device mount name.
*/
romfsMountFromStorage :: (storage: FsStorage, offset: u64, name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS using the current process host program RomFS.
* @param name Device mount name.
*/
romfsMountFromCurrentProcess :: (name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS of a running program.
* @note Permission needs to be set in the NPDM.
* @param program_id ProgramId to mount.
* @param name Device mount name.
*/
romfsMountDataStorageFromProgram :: (program_id: u64, name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS from a file path in a mounted fsdev device.
* @param path File path.
* @param offset Offset of the RomFS within the file.
* @param name Device mount name.
*/
romfsMountFromFsdev :: (path: *u8, offset: u64, name: *u8) -> Result #foreign libnx;

/**
* @brief Mounts RomFS from SystemData.
* @param dataId SystemDataId to mount.
* @param storageId Storage ID to mount from.
* @param name Device mount name.
*/
romfsMountFromDataArchive :: (dataId: u64, storageId: NcmStorageId, name: *u8) -> Result #foreign libnx;

/// Unmounts the RomFS device.
romfsUnmount :: (name: *u8) -> Result #foreign libnx;

/// BSD service type used by the socket driver.
BsdServiceType :: enum u32 {
    User   :: 1;
    System :: 2;
    Auto   :: 3;
}

/// Configuration structure for socketInitalize
SocketInitConfig :: struct {
    tcp_tx_buf_size:     u32; ///< Size of the TCP transfer (send) buffer (initial or fixed).
    tcp_rx_buf_size:     u32; ///< Size of the TCP receive buffer (initial or fixed).
    tcp_tx_buf_max_size: u32; ///< Maximum size of the TCP transfer (send) buffer. If it is 0, the size of the buffer is fixed to its initial value.
    tcp_rx_buf_max_size: u32; ///< Maximum size of the TCP receive buffer. If it is 0, the size of the buffer is fixed to its initial value.

    udp_tx_buf_size:     u32; ///< Size of the UDP transfer (send) buffer (typically 0x2400 bytes).
    udp_rx_buf_size:     u32; ///< Size of the UDP receive buffer (typically 0xA500 bytes).

    sb_efficiency:       u32; ///< Number of buffers for each socket (standard values range from 1 to 8).

    num_bsd_sessions:    u32; ///< Number of BSD service sessions (typically 3).
    bsd_service_type:    BsdServiceType; ///< BSD service type (typically \ref BsdServiceType_User).
}

/// Fetch the default configuration for the socket driver.
socketGetDefaultInitConfig :: () -> *SocketInitConfig #foreign libnx;

/// Initalize the socket driver.
socketInitialize :: (config: *SocketInitConfig) -> Result #foreign libnx;

/// Fetch the last bsd:u/s Switch result code (thread-local).
socketGetLastResult :: () -> Result #foreign libnx;

/// Deinitialize the socket driver.
socketExit :: () -> void #foreign libnx;

/// Wrapper for \ref sslConnectionSetSocketDescriptor. Returns the output sockfd on success and -1 on error. errno==ENOENT indicates that no sockfd was returned, this error must be ignored.
socketSslConnectionSetSocketDescriptor :: (c: *SslConnection, sockfd: s32) -> s32 #foreign libnx;

/// Wrapper for \ref sslConnectionGetSocketDescriptor. Returns the output sockfd on success and -1 on error.
socketSslConnectionGetSocketDescriptor :: (c: *SslConnection) -> s32 #foreign libnx;

/// Wrapper for \ref nifmRequestRegisterSocketDescriptor. Returns 0 on success and -1 on error.
socketNifmRequestRegisterSocketDescriptor :: (r: *NifmRequest, sockfd: s32) -> s32 #foreign libnx;

/// Wrapper for \ref nifmRequestUnregisterSocketDescriptor. Returns 0 on success and -1 on error.
socketNifmRequestUnregisterSocketDescriptor :: (r: *NifmRequest, sockfd: s32) -> s32 #foreign libnx;

/// Context for AES-128 operations.
Aes128Context :: struct {
    round_keys: [11] [16] u8;
}

/// Context for AES-192 operations.
Aes192Context :: struct {
    round_keys: [13] [16] u8;
}

/// Context for AES-256 operations.
Aes256Context :: struct {
    round_keys: [15] [16] u8;
}

/// Initialize a 128-bit AES context.
aes128ContextCreate :: (out: *Aes128Context, key: *void, is_encryptor: bool) -> void #foreign libnx;

/// Encrypt using an AES context (Requires is_encryptor when initializing)
aes128EncryptBlock :: (ctx: *Aes128Context, dst: *void, src: *void) -> void #foreign libnx;

/// Decrypt using an AES context (Requires !is_encryptor when initializing)
aes128DecryptBlock :: (ctx: *Aes128Context, dst: *void, src: *void) -> void #foreign libnx;

/// Initialize a 192-bit AES context.
aes192ContextCreate :: (out: *Aes192Context, key: *void, is_encryptor: bool) -> void #foreign libnx;

/// Encrypt using an AES context (Requires is_encryptor when initializing)
aes192EncryptBlock :: (ctx: *Aes192Context, dst: *void, src: *void) -> void #foreign libnx;

/// Decrypt using an AES context (Requires !is_encryptor when initializing)
aes192DecryptBlock :: (ctx: *Aes192Context, dst: *void, src: *void) -> void #foreign libnx;

/// Initialize a 256-bit AES context.
aes256ContextCreate :: (out: *Aes256Context, key: *void, is_encryptor: bool) -> void #foreign libnx;

/// Encrypt using an AES context (Requires is_encryptor when initializing)
aes256EncryptBlock :: (ctx: *Aes256Context, dst: *void, src: *void) -> void #foreign libnx;

/// Decrypt using an AES context (Requires !is_encryptor when initializing)
aes256DecryptBlock :: (ctx: *Aes256Context, dst: *void, src: *void) -> void #foreign libnx;

/// Context for AES-128 CBC.
Aes128CbcContext :: struct {
    aes_ctx:      Aes128Context;
    iv:           [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// Context for AES-192 CBC.
Aes192CbcContext :: struct {
    aes_ctx:      Aes192Context;
    iv:           [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// Context for AES-256 CBC.
Aes256CbcContext :: struct {
    aes_ctx:      Aes256Context;
    iv:           [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// 128-bit CBC API.
aes128CbcContextCreate :: (out: *Aes128CbcContext, key: *void, iv: *void, is_encryptor: bool) -> void #foreign libnx;
aes128CbcContextResetIv :: (ctx: *Aes128CbcContext, iv: *void) -> void #foreign libnx;
aes128CbcEncrypt :: (ctx: *Aes128CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes128CbcDecrypt :: (ctx: *Aes128CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// 192-bit CBC API.
aes192CbcContextCreate :: (out: *Aes192CbcContext, key: *void, iv: *void, is_encryptor: bool) -> void #foreign libnx;
aes192CbcContextResetIv :: (ctx: *Aes192CbcContext, iv: *void) -> void #foreign libnx;
aes192CbcEncrypt :: (ctx: *Aes192CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes192CbcDecrypt :: (ctx: *Aes192CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// 256-bit CBC API.
aes256CbcContextCreate :: (out: *Aes256CbcContext, key: *void, iv: *void, is_encryptor: bool) -> void #foreign libnx;
aes256CbcContextResetIv :: (ctx: *Aes256CbcContext, iv: *void) -> void #foreign libnx;
aes256CbcEncrypt :: (ctx: *Aes256CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes256CbcDecrypt :: (ctx: *Aes256CbcContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// Context for AES-128 CTR.
Aes128CtrContext :: struct {
    aes_ctx:        Aes128Context;
    ctr:            [16] u8;
    enc_ctr_buffer: [16] u8;
    buffer_offset:  u64;
}

/// Context for AES-192 CTR.
Aes192CtrContext :: struct {
    aes_ctx:        Aes192Context;
    ctr:            [16] u8;
    enc_ctr_buffer: [16] u8;
    buffer_offset:  u64;
}

/// Context for AES-256 CTR.
Aes256CtrContext :: struct {
    aes_ctx:        Aes256Context;
    ctr:            [16] u8;
    enc_ctr_buffer: [16] u8;
    buffer_offset:  u64;
}

/// 128-bit CTR API.
aes128CtrContextCreate :: (out: *Aes128CtrContext, key: *void, ctr: *void) -> void #foreign libnx;
aes128CtrContextResetCtr :: (ctx: *Aes128CtrContext, ctr: *void) -> void #foreign libnx;
aes128CtrCrypt :: (ctx: *Aes128CtrContext, dst: *void, src: *void, size: u64) -> void #foreign libnx;

/// 192-bit CTR API.
aes192CtrContextCreate :: (out: *Aes192CtrContext, key: *void, ctr: *void) -> void #foreign libnx;
aes192CtrContextResetCtr :: (ctx: *Aes192CtrContext, ctr: *void) -> void #foreign libnx;
aes192CtrCrypt :: (ctx: *Aes192CtrContext, dst: *void, src: *void, size: u64) -> void #foreign libnx;

/// 256-bit CTR API.
aes256CtrContextCreate :: (out: *Aes256CtrContext, key: *void, ctr: *void) -> void #foreign libnx;
aes256CtrContextResetCtr :: (ctx: *Aes256CtrContext, ctr: *void) -> void #foreign libnx;
aes256CtrCrypt :: (ctx: *Aes256CtrContext, dst: *void, src: *void, size: u64) -> void #foreign libnx;

/// Context for AES-128 XTS.
Aes128XtsContext :: struct {
    aes_ctx:      Aes128Context;
    tweak_ctx:    Aes128Context;
    tweak:        [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// Context for AES-192 XTS.
Aes192XtsContext :: struct {
    aes_ctx:      Aes192Context;
    tweak_ctx:    Aes192Context;
    tweak:        [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// Context for AES-256 XTS.
Aes256XtsContext :: struct {
    aes_ctx:      Aes256Context;
    tweak_ctx:    Aes256Context;
    tweak:        [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
}

/// 128-bit XTS API.
aes128XtsContextCreate :: (out: *Aes128XtsContext, key0: *void, key1: *void, is_encryptor: bool) -> void #foreign libnx;
aes128XtsContextResetTweak :: (ctx: *Aes128XtsContext, tweak: *void) -> void #foreign libnx;
aes128XtsContextResetSector :: (ctx: *Aes128XtsContext, sector: u64, is_nintendo: bool) -> void #foreign libnx;
aes128XtsEncrypt :: (ctx: *Aes128XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes128XtsDecrypt :: (ctx: *Aes128XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// 192-bit XTS API.
aes192XtsContextCreate :: (out: *Aes192XtsContext, key0: *void, key1: *void, is_encryptor: bool) -> void #foreign libnx;
aes192XtsContextResetTweak :: (ctx: *Aes192XtsContext, tweak: *void) -> void #foreign libnx;
aes192XtsContextResetSector :: (ctx: *Aes192XtsContext, sector: u64, is_nintendo: bool) -> void #foreign libnx;
aes192XtsEncrypt :: (ctx: *Aes192XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes192XtsDecrypt :: (ctx: *Aes192XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// 256-bit XTS API.
aes256XtsContextCreate :: (out: *Aes256XtsContext, key0: *void, key1: *void, is_encryptor: bool) -> void #foreign libnx;
aes256XtsContextResetTweak :: (ctx: *Aes256XtsContext, tweak: *void) -> void #foreign libnx;
aes256XtsContextResetSector :: (ctx: *Aes256XtsContext, sector: u64, is_nintendo: bool) -> void #foreign libnx;
aes256XtsEncrypt :: (ctx: *Aes256XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;
aes256XtsDecrypt :: (ctx: *Aes256XtsContext, dst: *void, src: *void, size: u64) -> u64 #foreign libnx;

/// Context for AES-128 CMAC.
Aes128CmacContext :: struct {
    ctx:          Aes128Context;
    subkey:       [16] u8;
    mac:          [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
    finalized:    bool;
}

/// Context for AES-192 CMAC.
Aes192CmacContext :: struct {
    ctx:          Aes192Context;
    subkey:       [16] u8;
    mac:          [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
    finalized:    bool;
}

/// Context for AES-256 CMAC.
Aes256CmacContext :: struct {
    ctx:          Aes256Context;
    subkey:       [16] u8;
    mac:          [16] u8;
    buffer:       [16] u8;
    num_buffered: u64;
    finalized:    bool;
}

/// Initialize an AES-128-CMAC context.
cmacAes128ContextCreate :: (out: *Aes128CmacContext, key: *void) -> void #foreign libnx;

/// Updates AES-128-CMAC context with data to hash
cmacAes128ContextUpdate :: (ctx: *Aes128CmacContext, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output mac, finalizes the context.
cmacAes128ContextGetMac :: (ctx: *Aes128CmacContext, dst: *void) -> void #foreign libnx;

/// Simple all-in-one AES-128-CMAC calculator.
cmacAes128CalculateMac :: (dst: *void, key: *void, src: *void, size: u64) -> void #foreign libnx;

/// Initialize an AES-192-CMAC context.
cmacAes192ContextCreate :: (out: *Aes192CmacContext, key: *void) -> void #foreign libnx;

/// Updates AES-192-CMAC context with data to hash
cmacAes192ContextUpdate :: (ctx: *Aes192CmacContext, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output mac, finalizes the context.
cmacAes192ContextGetMac :: (ctx: *Aes192CmacContext, dst: *void) -> void #foreign libnx;

/// Simple all-in-one AES-192-CMAC calculator.
cmacAes192CalculateMac :: (dst: *void, key: *void, src: *void, size: u64) -> void #foreign libnx;

/// Initialize an AES-256-CMAC context.
cmacAes256ContextCreate :: (out: *Aes256CmacContext, key: *void) -> void #foreign libnx;

/// Updates AES-256-CMAC context with data to hash
cmacAes256ContextUpdate :: (ctx: *Aes256CmacContext, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output mac, finalizes the context.
cmacAes256ContextGetMac :: (ctx: *Aes256CmacContext, dst: *void) -> void #foreign libnx;

/// Simple all-in-one AES-256-CMAC calculator.
cmacAes256CalculateMac :: (dst: *void, key: *void, src: *void, size: u64) -> void #foreign libnx;

/// Context for SHA1 operations.
Sha1Context :: struct {
    intermediate_hash: [5] u32;
    buffer:            [64] u8;
    bits_consumed:     u64;
    num_buffered:      u64;
    finalized:         bool;
}

/// Initialize a SHA1 context.
sha1ContextCreate :: (out: *Sha1Context) -> void #foreign libnx;

/// Updates SHA1 context with data to hash
sha1ContextUpdate :: (ctx: *Sha1Context, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output hash, finalizes the context.
sha1ContextGetHash :: (ctx: *Sha1Context, dst: *void) -> void #foreign libnx;

/// Simple all-in-one SHA1 calculator.
sha1CalculateHash :: (dst: *void, src: *void, size: u64) -> void #foreign libnx;

/// Context for HMAC-SHA1 operations.
HmacSha1Context :: struct {
    sha_ctx:   Sha1Context;
    key:       [16] u32;
    mac:       [5] u32;
    finalized: bool;
}

/// Context for HMAC-SHA256 operations.
HmacSha256Context :: struct {
    sha_ctx:   Sha256Context;
    key:       [16] u32;
    mac:       [8] u32;
    finalized: bool;
}

/// Initialize a HMAC-SHA256 context.
hmacSha256ContextCreate :: (out: *HmacSha256Context, key: *void, key_size: u64) -> void #foreign libnx;

/// Updates HMAC-SHA256 context with data to hash
hmacSha256ContextUpdate :: (ctx: *HmacSha256Context, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output mac, finalizes the context.
hmacSha256ContextGetMac :: (ctx: *HmacSha256Context, dst: *void) -> void #foreign libnx;

/// Simple all-in-one HMAC-SHA256 calculator.
hmacSha256CalculateMac :: (dst: *void, key: *void, key_size: u64, src: *void, size: u64) -> void #foreign libnx;

/// Initialize a HMAC-SHA1 context.
hmacSha1ContextCreate :: (out: *HmacSha1Context, key: *void, key_size: u64) -> void #foreign libnx;

/// Updates HMAC-SHA1 context with data to hash
hmacSha1ContextUpdate :: (ctx: *HmacSha1Context, src: *void, size: u64) -> void #foreign libnx;

/// Gets the context's output mac, finalizes the context.
hmacSha1ContextGetMac :: (ctx: *HmacSha1Context, dst: *void) -> void #foreign libnx;

/// Simple all-in-one HMAC-SHA1 calculator.
hmacSha1CalculateMac :: (dst: *void, key: *void, key_size: u64, src: *void, size: u64) -> void #foreign libnx;

#scope_module

libnx :: #system_library,no_dll "libnx";

#scope_export

#insert #run bitfields_struct(
    "UTimer",
    .{ "waitable", #type Waitable, 0, .NONE },
    .{ "type", #type u8, 8, .NONE },
    .{ "started", #type bool, 1, .NONE },
    .{ "next_tick", #type u64, 0, .NONE },
    .{ "interval", #type u64, 0, .NONE },
);

#insert #run bitfields_struct(
    "HipcHeader",
    .{ "type", #type u32, 16, .NONE },
    .{ "num_send_statics", #type u32, 4, .NONE },
    .{ "num_send_buffers", #type u32, 4, .NONE },
    .{ "num_recv_buffers", #type u32, 4, .NONE },
    .{ "num_exch_buffers", #type u32, 4, .NONE },
    .{ "num_data_words", #type u32, 10, .NONE },
    .{ "recv_static_mode", #type u32, 4, .NONE },
    .{ "padding", #type u32, 6, .NONE },
    .{ "recv_list_offset", #type u32, 11, .NONE },
    .{ "has_special_header", #type u32, 1, .NONE },
);

#insert #run bitfields_struct(
    "HipcSpecialHeader",
    .{ "send_pid", #type u32, 1, .NONE },
    .{ "num_copy_handles", #type u32, 4, .NONE },
    .{ "num_move_handles", #type u32, 4, .NONE },
    .{ "padding", #type u32, 23, .NONE },
);

#insert #run bitfields_struct(
    "HipcStaticDescriptor",
    .{ "index", #type u32, 6, .NONE },
    .{ "address_high", #type u32, 6, .NONE },
    .{ "address_mid", #type u32, 4, .NONE },
    .{ "size", #type u32, 16, .NONE },
    .{ "address_low", #type u32, 0, .NONE },
);

#insert #run bitfields_struct(
    "HipcBufferDescriptor",
    .{ "size_low", #type u32, 0, .NONE },
    .{ "address_low", #type u32, 0, .NONE },
    .{ "mode", #type u32, 2, .NONE },
    .{ "address_high", #type u32, 22, .NONE },
    .{ "size_high", #type u32, 4, .NONE },
    .{ "address_mid", #type u32, 4, .NONE },
);

#insert #run bitfields_struct(
    "HipcRecvListEntry",
    .{ "address_low", #type u32, 0, .NONE },
    .{ "address_high", #type u32, 16, .NONE },
    .{ "size", #type u32, 16, .NONE },
);

#insert #run bitfields_struct(
    "SetSysModeLine",
    .{ "pixel_clock", #type u16, 0, .NONE },
    .{ "horizontal_active_pixels_lsb", #type u8, 0, .NONE },
    .{ "horizontal_blanking_pixels_lsb", #type u8, 0, .NONE },
    .{ "horizontal_blanking_pixels_msb", #type u8, 4, .NONE },
    .{ "horizontal_active_pixels_msb", #type u8, 4, .NONE },
    .{ "vertical_active_lines_lsb", #type u8, 0, .NONE },
    .{ "vertical_blanking_lines_lsb", #type u8, 0, .NONE },
    .{ "vertical_blanking_lines_msb", #type u8, 4, .NONE },
    .{ "vertical_active_lines_msb", #type u8, 4, .NONE },
    .{ "horizontal_sync_offset_pixels_lsb", #type u8, 0, .NONE },
    .{ "horizontal_sync_pulse_width_pixels_lsb", #type u8, 0, .NONE },
    .{ "horizontal_sync_pulse_width_lines_lsb", #type u8, 4, .NONE },
    .{ "horizontal_sync_offset_lines_lsb", #type u8, 4, .NONE },
    .{ "vertical_sync_pulse_width_lines_msb", #type u8, 2, .NONE },
    .{ "vertical_sync_offset_lines_msb", #type u8, 2, .NONE },
    .{ "horizontal_sync_pulse_width_pixels_msb", #type u8, 2, .NONE },
    .{ "horizontal_sync_offset_pixels_msb", #type u8, 2, .NONE },
    .{ "horizontal_image_size_mm_lsb", #type u8, 0, .NONE },
    .{ "vertical_image_size_mm_lsb", #type u8, 0, .NONE },
    .{ "vertical_image_size_mm_msb", #type u8, 4, .NONE },
    .{ "horizontal_image_size_mm_msb", #type u8, 4, .NONE },
    .{ "horizontal_border_pixels", #type u8, 0, .NONE },
    .{ "vertical_border_lines", #type u8, 0, .NONE },
    .{ "features_bitmap_0", #type u8, 1, .NONE },
    .{ "features_bitmap_1", #type u8, 1, .NONE },
    .{ "features_bitmap_2", #type u8, 1, .NONE },
    .{ "features_bitmap_34", #type u8, 2, .NONE },
    .{ "features_bitmap_56", #type u8, 2, .NONE },
    .{ "interlaced", #type u8, 1, .NONE },
);

#insert #run bitfields_struct(
    "__anon_struct_20_anon_svd",
    .{ "svd_index", #type u8, 7, .NONE },
    .{ "native_flag", #type u8, 1, .NONE },
);

#insert #run bitfields_struct(
    "anon_struct_20",
    .{ "size", #type u8, 5, .NONE },
    .{ "block_type", #type u8, 3, .NONE },
    .{ "svd", #type [12] __anon_struct_20_anon_svd, 0, .NONE },
);

#insert #run bitfields_struct(
    "anon_struct_22",
    .{ "size", #type u8, 5, .NONE },
    .{ "block_type", #type u8, 3, .NONE },
    .{ "channel_count", #type u8, 3, .NONE },
    .{ "format_code", #type u8, 4, .NONE },
    .{ "padding1", #type u8, 1, .NONE },
    .{ "sampling_rates_bitmap", #type u8, 0, .NONE },
    .{ "bitrate", #type u8, 0, .NONE },
);

#insert #run bitfields_struct(
    "anon_struct_23",
    .{ "size", #type u8, 5, .NONE },
    .{ "block_type", #type u8, 3, .NONE },
    .{ "ieee_registration_id", #type [3] u8, 0, .NONE },
    .{ "source_physical_address", #type u16, 0, .NONE },
    .{ "mode_bitmap", #type u8, 0, .NONE },
    .{ "max_tmds_frequency", #type u8, 0, .NONE },
    .{ "latency_bitmap", #type u8, 0, .NONE },
);

#insert #run bitfields_struct(
    "__SetSysEdid_anon_chromaticity",
    .{ "green_y_lsb", #type u8, 2, .NONE },
    .{ "green_x_lsb", #type u8, 2, .NONE },
    .{ "red_y_lsb", #type u8, 2, .NONE },
    .{ "red_x_lsb", #type u8, 2, .NONE },
    .{ "blue_lsb", #type u8, 4, .NONE },
    .{ "white_lsb", #type u8, 4, .NONE },
    .{ "red_x_msb", #type u8, 0, .NONE },
    .{ "red_y_msb", #type u8, 0, .NONE },
    .{ "green_x_msb", #type u8, 0, .NONE },
    .{ "green_y_msb", #type u8, 0, .NONE },
    .{ "blue_x_msb", #type u8, 0, .NONE },
    .{ "blue_y_msb", #type u8, 0, .NONE },
    .{ "white_x_msb", #type u8, 0, .NONE },
    .{ "white_y_msb", #type u8, 0, .NONE },
);

#insert #run bitfields_struct(
    "__SetSysEdid_anon_timing_info",
    .{ "x_resolution", #type u8, 0, .NONE },
    .{ "vertical_frequency", #type u8, 6, .NONE },
    .{ "aspect_ratio", #type u8, 2, .NONE },
);

__SetSysEdid_anon_display_descriptor_name :: struct {
    display_descriptor_zero: u16;
    padding1:                u8;
    descriptor_type:         u8;
    padding2:                u8;
    name:                    [13] u8;
}

__SetSysEdid_anon_display_descriptor_range_limits :: struct {
    display_descriptor_zero:  u16;
    padding1:                 u8;
    descriptor_type:          u8;
    range_limit_offsets:      u8;
    vertical_field_rate_min:  u8;
    vertical_field_rate_max:  u8;
    horizontal_line_rate_min: u8;
    horizontal_line_rate_max: u8;
    pixel_clock_rate_max:     u8; ///< Rounded up to multiples of 10 MHz.
    extended_timing_info:     u8;
    padding:                  [7] u8;
}

#insert #run bitfields_struct(
    "SetSysEdid",
    .{ "pattern", #type [8] u8, 0, .NONE },
    .{ "pnp_id", #type u16, 0, .NONE },
    .{ "product_code", #type u16, 0, .NONE },
    .{ "serial_number", #type u32, 0, .NONE },
    .{ "manufacture_week", #type u8, 0, .NONE },
    .{ "manufacture_year", #type u8, 0, .NONE },
    .{ "edid_version", #type u8, 0, .NONE },
    .{ "edid_revision", #type u8, 0, .NONE },
    .{ "video_input_parameters_bitmap", #type u8, 0, .NONE },
    .{ "display_width", #type u8, 0, .NONE },
    .{ "display_height", #type u8, 0, .NONE },
    .{ "display_gamma", #type u8, 0, .NONE },
    .{ "supported_features_bitmap", #type u8, 0, .NONE },
    .{ "chromaticity", __SetSysEdid_anon_chromaticity, 0, .NONE },
    .{ "timing_bitmap", #type [3] u8, 0, .NONE },
    .{ "timing_info", #type [8] __SetSysEdid_anon_timing_info, 0, .NONE },
    .{ "timing_descriptor", #type [2] SetSysModeLine, 0, .NONE },
    .{ "display_descriptor_name", __SetSysEdid_anon_display_descriptor_name, 0, .NONE },
    .{ "display_descriptor_range_limits", __SetSysEdid_anon_display_descriptor_range_limits, 0, .NONE },
    .{ "extension_count", #type u8, 0, .NONE },
    .{ "checksum", #type u8, 0, .NONE },
    .{ "extension_tag", #type u8, 0, .NONE },
    .{ "revision", #type u8, 0, .NONE },
    .{ "dtd_start", #type u8, 0, .NONE },
    .{ "native_dtd_count", #type u8, 4, .NONE },
    .{ "native_dtd_feature_bitmap", #type u8, 4, .NONE },
    .{ "data_block", #type SetSysDataBlock, 0, .NONE },
    .{ "extended_timing_descriptor", #type [5] SetSysModeLine, 0, .NONE },
    .{ "padding", #type [5] u8, 0, .NONE },
    .{ "extended_checksum", #type u8, 0, .NONE },
);

#insert #run bitfields_struct(
    "AudioRendererVoiceInfoIn",
    .{ "id", #type u32, 0, .NONE },
    .{ "node_id", #type u32, 0, .NONE },
    .{ "is_new", #type bool, 0, .NONE },
    .{ "is_used", #type bool, 0, .NONE },
    .{ "state", #type u16, 8, .NONE },
    .{ "sample_format", #type u16, 8, .NONE },
    .{ "sample_rate", #type u32, 0, .NONE },
    .{ "priority", #type u32, 0, .NONE },
    .{ "sorting_order", #type u32, 0, .NONE },
    .{ "channel_count", #type u32, 0, .NONE },
    .{ "pitch", #type float, 0, .NONE },
    .{ "volume", #type float, 0, .NONE },
    .{ "biquads", #type [2] AudioRendererBiquadFilter, 0, .NONE },
    .{ "wavebuf_count", #type u32, 0, .NONE },
    .{ "wavebuf_head", #type s16, 0, .NONE },
    .{ "_padding1", #type u16, 0, .NONE },
    .{ "_padding2", #type u32, 0, .NONE },
    .{ "extra_params_ptr", #type *void, 0, .NONE },
    .{ "extra_params_sz", #type u64, 0, .NONE },
    .{ "dest_mix_id", #type u32, 0, .NONE },
    .{ "dest_splitter_id", #type u32, 0, .NONE },
    .{ "wavebufs", #type [4] AudioRendererWaveBuf, 0, .NONE },
    .{ "channel_ids", #type [6] u32, 0, .NONE },
    .{ "_padding3", #type [24] u8, 0, .NONE },
);

__AudioRendererSinkInfoIn_anon_0 :: union {
    device_sink:          AudioRendererDeviceSinkInfoIn;
    circular_buffer_sink: AudioRendererCircularBufferSinkInfoIn;
}

#insert #run bitfields_struct(
    "AudioRendererSinkInfoIn",
    .{ "type", #type u8, 8, .NONE },
    .{ "is_used", #type bool, 0, .NONE },
    .{ "_padding1", #type [2] u8, 0, .NONE },
    .{ "node_id", #type u32, 0, .NONE },
    .{ "_padding2", #type [3] u64, 0, .NONE },
    .{ "anon_struct_28", __AudioRendererSinkInfoIn_anon_0, 0, .USING },
);

#insert #run bitfields_struct(
    "HidNpadSystemProperties",
    .{ "is_charging", #type u64, 3, .NONE },
    .{ "is_powered", #type u64, 3, .NONE },
    .{ "bit6", #type u64, 1, .NONE },
    .{ "bit7", #type u64, 1, .NONE },
    .{ "bit8", #type u64, 1, .NONE },
    .{ "is_unsupported_button_pressed_on_npad_system", #type u64, 1, .NONE },
    .{ "is_unsupported_button_pressed_on_npad_system_ext", #type u64, 1, .NONE },
    .{ "is_abxy_button_oriented", #type u64, 1, .NONE },
    .{ "is_sl_sr_button_oriented", #type u64, 1, .NONE },
    .{ "is_plus_available", #type u64, 1, .NONE },
    .{ "is_minus_available", #type u64, 1, .NONE },
    .{ "is_directional_buttons_available", #type u64, 1, .NONE },
    .{ "unused", #type u64, 48, .NONE },
);

#insert #run bitfields_struct(
    "HidNpadSystemButtonProperties",
    .{ "is_unintended_home_button_input_protection_enabled", #type u32, 1, .NONE },
);

#insert #run bitfields_struct(
    "anon_struct_37",
    .{ "npad_style_index", #type u32, 8, .NONE },
    .{ "player_number", #type u32, 8, .NONE },
    .{ "device_idx", #type u32, 8, .NONE },
    .{ "pad", #type u32, 8, .NONE },
);

#insert #run bitfields_struct(
    "anon_struct_38",
    .{ "npad_style_index", #type u32, 8, .NONE },
    .{ "player_number", #type u32, 8, .NONE },
    .{ "device_idx", #type u32, 8, .NONE },
    .{ "pad", #type u32, 8, .NONE },
);

#insert #run bitfields_struct(
    "ViLayer",
    .{ "layer_id", #type u64, 0, .NONE },
    .{ "igbp_binder_obj_id", #type u32, 0, .NONE },
    .{ "initialized", #type bool, 1, .NONE },
    .{ "stray_layer", #type bool, 1, .NONE },
);

